"#","No","Issue Title","Issue Details","State","Labels","User name","created","Updated"
"","28471","hello   您对spring bean的生命周期怎么看","面试经常被问spring bean的生命周期 我很苦恼，能不能简单说下","closed","for: stackoverflow,","sakura-maple","2022-05-17T11:35:22Z","2022-05-17T11:43:55Z"
"","28186","CustomEditorConfigurer中维护的Map并没有对应关系","在使用XMl文件的方式注入属性编辑器的过程中，使用，我发现map的键和值并不是一一对应的关系，于是找到CustomEditorConfigurer类发现CustomEditorConfigurer中维护的Map并没有对应关系，这个问题意味着，我只需要注入值（属性编辑器）就可以使用","closed","for: stackoverflow,","ImUglyZ","2022-03-16T06:17:15Z","2022-03-16T08:18:49Z"
"","28402","5.2x","创建5.2x","closed","status: waiting-for-triage,","csiichao","2022-04-30T13:55:12Z","2022-04-30T13:55:32Z"
"","28355","Treat MariaDB as an independent database type","…b.com/spring-projects/spring-framework/issues/28305  In this commit we added MariaDB as an independent database type as per #28305   Thanks for taking time to look at it!","open","status: waiting-for-triage,","ben-enfuse-io","2022-04-18T17:34:00Z","2022-07-29T15:54:48Z"
"","28136","Update README.md","фыв","closed","status: invalid,","Solyaris","2022-03-04T20:05:05Z","2022-03-04T21:08:44Z"
"","28398","Avoid collectList when sending a Flux of objects as JSON using WebClient","Would it be possible to send a flux of objects in the request body using WebClient with ""Content-Type: application/json"" but avoid having to collect the whole flux as a list in memory?  Let's say I have a Flux containing millions of elements and my target server only accepts non-streaming content-types, the Jackson2JsonEncoder would then call ""collectList()"" on the flux, possibly running out of memory.  Couldn't the Jackson2JsonEncoder somehow write the objects as they come available?","closed","type: enhancement,","micopiira","2022-04-29T20:51:36Z","2022-05-23T10:32:13Z"
"","28009","Review @Nullable annotations on DefaultJmsListenerContainerFactory","Working on a Kotlin sample where we call `DefaultJmsListenerContainerFactory.setTransactionManager(null)` and I see an error. I think it might be because the parameter on the method isn't marked as `@Nullable` even though the field is.","closed","status: declined,","philwebb","2022-02-04T19:12:41Z","2022-02-08T06:30:23Z"
"","28887","Introduce RuntimeHintsUtils#registerComposableAnnotation","Working on #28767 and the use case in Spring Boot revealed that we could use an explicit method to register a composable annotation when we know it is going to be the used with attribute override (`@AliasFor`). This requires not only the regular annotation hint but also a proxy.  The only way to trigger this is to register a composed annotation (i.e. an annotation using that annotation) but if the underlying code is only using the annotation and not of the composed one, that would register an unnecessary hint.","closed","theme: aot,","snicoll","2022-07-29T13:22:18Z","2022-07-29T13:39:43Z"
"","28890","Fix typo in BasicJsonWriter.java","withing -> within","closed","type: documentation,","eltociear","2022-07-30T03:41:53Z","2022-08-01T07:19:15Z"
"","28417","Add Throwable functional interfaces","Within the framework and portfolio projects we often need to deal with checked exceptions inside the body of a `Function`, `Supplier`, `Consumer`, etc. This usually involves writing `try`/`catch` blocks inside the body. Since exception handling is usually also handled by the framework, it would be nice if we could offer `Throwing...` versions of common functional interfaces that do the wrapping for us.","closed","type: enhancement,","philwebb","2022-05-05T06:21:25Z","2022-05-06T14:01:50Z"
"","28860","CGLIB / Spring 6 throws BeanCreationException / CodeGenerationException on JDK 17 for proxy interfaces in different packages","With this ticket I would like to re-open #27802 as I'm still experiencing the same issue with 6.0.0-M5 when the interface that is to be proxied resided in a different package: ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'foo': FactoryBean threw exception on object creation 	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:154) 	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:124) 	at foo.BugTest$TestFactoryBeanRegistrySupport.getObjectFromFactoryBean(BugTest.java:34) 	at foo.BugTest.testServiceInterfaceInDifferentPackage(BugTest.java:27) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 	at org.apache.maven.surefire.junitplatform.LazyLauncher.execute(LazyLauncher.java:55) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.execute(JUnitPlatformProvider.java:223) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:175) 	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:139) 	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:456) 	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:169) 	at org.apache.maven.surefire.booter.ForkedBooter.run(ForkedBooter.java:595) 	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:581) Caused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class foo.TargetClass: Common causes of this problem include using a final class or a non-visible class 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:209) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2.CGLIB$getProxy$4() 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2$$FastClassByCGLIB$$2511f502.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) 	at foo.FooProxyFactory.lambda$createAopProxy$0(FooProxyFactory.java:41) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2.getProxy() 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:156) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2.CGLIB$getProxy$3() 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2$$FastClassByCGLIB$$2511f502.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) 	at foo.FooProxyFactory.lambda$createAopProxy$0(FooProxyFactory.java:41) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2.getProxy() 	at foo.FooBeanFactory.getObject(FooBeanFactory.java:30) 	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:148) 	... 73 more Caused by: org.springframework.cglib.core.CodeGenerationException: java.lang.reflect.InaccessibleObjectException-->Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @2c3e2a2a 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:534) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:585) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572) 	at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:57) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2.CGLIB$createProxyClassAndInstance$0() 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2$$FastClassByCGLIB$$2511f502.invoke() 	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) 	at foo.FooProxyFactory.lambda$createAopProxy$0(FooProxyFactory.java:41) 	at org.springframework.aop.framework.ObjenesisCglibAopProxy$$EnhancerByCGLIB$$ec0eb3b2.createProxyClassAndInstance() 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:206) 	... 86 more Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @2c3e2a2a 	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354) 	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) 	at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) 	at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:493) 	... 105 more ```  I have created a small project to reproduce the problem that shows that the exception is thrown if and only if the interface does not reside in the same package: https://github.com/janeisklar/spring6-jdk17-cglib-bug-reproducer/blob/main/src/test/java/foo/BugTest.java","open","status: waiting-for-triage,","janeisklar","2022-07-22T20:12:15Z","2022-07-31T15:07:15Z"
"","27943","Add a devcontainer for VSCode and Github Codespaces","With this change user can start a container locally with VSCode remote, or open an IDE from Github in the browser.  VSCode doesn't support .aj sources yet, so it's not a completely smooth experience, but you can make changes and build from the command line.","closed","status: declined,","dsyer","2022-01-17T16:25:02Z","2022-07-29T16:15:31Z"
"","28840","R2DBC  Postgresql: Creating new Transactions org.springframework.transaction.reactive.AbstractReactiveTransactionManager Struck","With the recent upgrade of sprint boot version 2.7.1, we are unable to obtain the database connection from the r2dbc pool. The code strucks at the below line until we restart. Once restarted, the issues occurrence takes 2 to 3 days. No detailed logs printed  ** DEBUG o.s.t.r.AbstractReactiveTransactionManager [reactor-http-nio-4]   Creating new transaction with name [com.authenticate.service.UserService.fetchUserWithRoles]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly **  #application.properties ====================== Below is the db connection pool configuration  spring.r2dbc.pool.enabled=true spring.r2dbc.pool.initial-size=5 spring.r2dbc.pool.max-size=10 spring.r2dbc.pool.max-idle-time=10m spring.r2dbc.pool.max-acquire-time=30s spring.r2dbc.pool.max-create-connection-time=30s spring.r2dbc.pool.validation-query=SELECT 1  #application.yml ======================= spring:   config:     activate:       on-profile: local   r2dbc:     url: r2dbc:postgresql://localhost:5432/mydb     username: postgres","closed","","madhav1306","2022-07-19T04:17:01Z","2022-08-02T07:55:52Z"
"","28120","Support for compiling and running generated code in tests","With the AOT engine now generating an optimized view of the bean factory, there is a need to be able to compile and run the generated code in a test to assert that it has the intended effect.   Such general purpose utility could land in a new `spring-core-test` module for a start (with, potentially, a dependency on `spring-core`).","closed","type: enhancement,","snicoll","2022-03-01T14:47:44Z","2022-03-09T10:19:03Z"
"","27967","Fix CaffeineCacheManager configuration in the documentation","With Spring Framework 6.0.0-M2, the `caches` property is not valid and may be replaced by `cacheNames`","closed","type: documentation,","arey","2022-01-21T18:53:43Z","2022-01-22T09:43:07Z"
"","28140","Not able to Refer to different xml using Spring 5.2.x","With Spring 4.3.5, we have been using an application architecture where we initialize some of the beans at a go and then use the beans as ""Reference"" for other beans.  Something like this  ```xml             ```  But once we upgraded our library to Spring 5.2.x, we started getting the below exception at Jboss 7.3.1 startup:  ``` Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'handleUncheckedEndpointExceptionAdvice' defined in ServletContext resource [/WEB-INF/context-web.xml]: Cannot resolve reference to bean 'exceptionSenderService' while setting bean property 'exceptionSenderService'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'exceptionSenderService' available ```  What all I did: Enabled TRACE logging and found this -  ``` 2022-03-05 13:09:39,927 TRACE [org.springframework.beans.factory.annotation.InjectionMetadata] (ServerService Thread Pool -- 65) Processing injected element of bean 'exceptionSenderService': AutowiredFieldElement for private com.gehcit.cp.serviceability.service.ExceptionSenderService com.gehcit.cp.cem.aplix.jms.service.Impl.AplixPublisherQueueServiceImpl.exceptionSender 2022-03-05 13:09:39,927 TRACE [org.springframework.beans.factory.support.DefaultListableBeanFactory] (ServerService Thread Pool -- 65) Returning cached instance of singleton bean 'exceptionSenderServiceImpl' 2022-03-05 13:09:39,927 TRACE [org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor] (ServerService Thread Pool -- 65) Autowiring by type from bean name 'exceptionSenderService' to bean named 'exceptionSenderServiceImpl' ```  Now the bean is getting initialized but when the reference is being searched, being searched from the Spring cache, we get nothing.  But then we tried shifting the bean initialization from a different xml to the same xml where the bean is being referred and that worked. So we concluded that somehow the cross XML configurations are not working.  **Bean being referred from context-web.xml**  ```xml                                                         /WEB-INF/web.properties                 classpath:application.properties                                                                                                                                                                                                                                                                                                                                                                                                                          ```  **The bean is being initialized in context-applix.xml**  ```xml                                                                                                                                                                                                                                                                                                                                                                                                        ```  **Can someone help me find a way to refer beans from other xml files in Spring 5.2.x**. Note: We have changed the classloading part with Spring 5.2.  Added this to the web.xml ```xml    com.gehcit.cp.ws.infrastructure.security.BeanFactoryContextLoaderListener       locatorFactorySelector     /beanRefFactory.xml   --> ```  [Attachments.zip](https://github.com/spring-projects/spring-framework/files/8191350/Attachments.zip)  Have attached the logs and required files.","open","in: core,","Staticsubh","2022-03-05T19:49:58Z","2022-04-25T09:39:25Z"
"","27976","Align with R2DBC 0.9 API changes","With R2DBC 0.9, a couple of changes were introduced that would make sense to be used by applications. Specifically:  * Usage of extensible transaction definitions * Introduction of `io.r2dbc.Parameter` * Deprecation of `RowMetadata.getColumnNames()` in favor of `RowMetadata.getColumnMetadatas()`  ## Usage of extensible transaction definitions  `Connection.begin(TransactionDefinition)` was introduced to allow drivers to consider a full transaction definition instead of requiring calling code to set individual options requiring individual server-roundtrips in the worst case. `R2dbcTransactionManager.doBegin` sets the isolation level and then calls `begin()` without providing hooks for customization (in fact, beginning a transaction with an isolation level is one of the driving use-cases).   It would be good to extract calls to `prepareTransactionalConnection` and `Connection.begin` into a template method for customization purposes.  ## Relationship of `o.s.r.core.Parameter` to `io.r2dbc.Parameter`  The `Parameter` type was introduced with R2DBC 0.9 so a future revision of Spring Framework (Framework 6) could deprecate `o.s.r.core.Parameter`. Drivers accept `io.r2dbc.Parameter` via `bind(…)` and that type doesn't interfere with `DatabaseClient` when using R2DBC 0.9.  The use of `io.r2dbc.Parameter` also allows specifying parameter directions (IN/OUT/IN-OUT) which is useful in stored procedures arrangements, however consumption of out parameters isn't possible as the newly introduced API isn't available in R2DBC 0.8.  ## `ColumnMapRowMapper`  We should switch to `RowMetadata.getColumnMetadatas()` to obtain column names. The return type of `getColumnMetadatas` was changed in R2DBC 0.9 to `List` as it was `Collection` in 0.8. So reflection is required here to address binary compatibility issues.","closed","type: dependency-upgrade,","mp911de","2022-01-25T14:29:07Z","2022-03-16T18:24:55Z"
"","27941","Fix regression in BeanPropertyRowMapper regarding underscore name","With 6316a35 I introduced a regression for properties starting with an uppercase letter.  This commit fixes that regression including an additional test to cover this case.  Fixes: gh-27929","closed","type: regression,","mdeinum","2022-01-17T06:56:23Z","2022-01-17T16:00:00Z"
"","28693","Why Spring is to old","Why Spring? Spring makes programming Java quicker, easier, and safer for everybody. Spring’s focus on speed, simplicity, and productivity has made it the [world's most popular](https://snyk.io/blog/jvm-ecosystem-report-2018-platform-application/) Java framework.  Link is 2018 now 2022 Link is 2018 now 2022  https://snyk.io/blog/jvm-ecosystem-report-2018-platform-application/","closed","status: invalid,","jsl1992","2022-06-24T02:58:19Z","2022-06-24T06:25:11Z"
"","28481","spring5.1.x error","who can help me？ When I compile Spring5.1.x use idea,always this error. Error:Groovyc: While compiling spring.spring-beans.main: D:\spring\spring-framework-5.1.x\spring-beans\src\main\groovy\org\springframework\beans\factory\groovy\GroovyDynamicElementReader.groovy (系统找不到指定的路径。)  in spring project ,create a new module ,in module used spring-beans ,information above operation prompt","closed","status: invalid,","zhouhui99","2022-05-19T06:04:35Z","2022-05-19T07:01:20Z"
"","27979","Use SpringProperties in native image detection","While writing tests for `@EnabledOnNative` and `@DisabledOnNative` in Spring Native (https://github.com/spring-projects-experimental/spring-native/pull/1460), I encountered it is very difficult to mock the native detection result - `NativeDetector.inNativeImage()`.    This is because it performs a system property check at the class initialization and keeps the result in a static final variable.  In this PR, I changed the detection logic to lookup `SpringProperties`, similar to `AotModeDetector` does in Spring Native.  This way, tests that need to modify the native-detection-result can interact with `SpringProperties` to dynamically change the value.","closed","type: enhancement,","ttddyy","2022-01-26T02:13:05Z","2022-01-29T08:09:22Z"
"","28597","Fix `ResourceHintsWriter` for leading/trailing wildcards","While working on spring-projects/spring-boot#31278 with @snicoll we found that specifying `static/*` resource pattern was not working as expected for example.","closed","type: bug,","sdeleuze","2022-06-09T12:30:19Z","2022-06-09T12:51:41Z"
"","28773","AnnotationTypeMapping tracks @AliasFor mappings as convention-based","While working on #28760, I noticed that `AnnotationTypeMapping.addConventionMappings()` actually adds convention-based mappings that it should not.  For example, in certain circumstances an explicit annotation attribute override configured via `@AliasFor` can be mapped as convention-based.  Although this does not _appear_ to cause negative side effects (other than unnecessary processing), this is technically a bug that should be addressed.  However, since there may be unknown use cases that somehow rely on the behavior of this bug, I currently only intend to apply to the fix to 6.0.","closed","in: core,","sbrannen","2022-07-07T15:31:46Z","2022-07-12T13:54:09Z"
"","28798","DefaultSerializer doesn't work with non-serializable records","While upgrading some code for the upcoming Spring 6 Recipes I noticed an error when migrating a class to a record.   ``` Exception in thread ""main"" org.springframework.data.redis.serializer.SerializationException: Cannot serialize 	at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.serialize(JdkSerializationRedisSerializer.java:96) 	at org.springframework.data.redis.core.AbstractOperations.rawValue(AbstractOperations.java:128) 	at org.springframework.data.redis.core.DefaultValueOperations.set(DefaultValueOperations.java:236) 	at com.apress.spring6recipes.nosql.Main.main(Main.java:16) Caused by: org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer 	at org.springframework.core.serializer.support.SerializingConverter.convert(SerializingConverter.java:64) 	at org.springframework.core.serializer.support.SerializingConverter.convert(SerializingConverter.java:33) 	at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.serialize(JdkSerializationRedisSerializer.java:94) 	... 3 more Caused by: java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.apress.spring6recipes.nosql.Vehicle] 	at org.springframework.core.serializer.DefaultSerializer.serialize(DefaultSerializer.java:43) 	at org.springframework.core.serializer.Serializer.serializeToByteArray(Serializer.java:56) 	at org.springframework.core.serializer.support.SerializingConverter.convert(SerializingConverter.java:60) 	... 5 more ```  Apparently the `DefaultSerializer` doesn't work with records, whereas calling `SerializationUtils.serialize` does work (and it uses the same mechanism of writing but doesn't check for `Serializable`). The check probably needs to be extended to include records as well (or converted to a try/catch instead).   This probably affects Spring 5.3 as well as that is compatible with JDK17 and thus records.","closed","in: core,","mdeinum","2022-07-12T12:52:33Z","2022-07-12T13:39:53Z"
"","28681","RepositoryRestMvcConfiguration sub classing attempt is failing because class DelegatingHandlerMapping made package private.","While updating org.springframework.boot to 2.5.12, org.springframework.data:spring-data-rest-webmvc is updated to 3.5.10 as transitive dependency. In this version we found the problem. During bean creation we get the following exception: ""java.lang.IllegalAccessError: failed to access class org.springframework.data.rest.webmvc.config.DelegatingHandlerMapping....""  Digging into that we found class DelegatingHandlerMapping made package private (public access specifier removed form the class). We are subclassing configuration class RepositoryRestMvcConfiguration (package org.springframework.data.rest.webmvc.config) to customize the configuration. Within that configuration class, one bean method restHandlerMapping() is returning DelegatingHandlerMapping object. When we are subclassing RepositoryRestMvcConfiguration then the bean method restHandlerMapping() becomes part of that subclass. And the package of the subclass is our local package which is different from the package org.springframework.data.rest.webmvc.config. Since DelegatingHandlerMapping is now package private, while creating bean restHandlerMapping() the IllegalAccessError is showing. Despite the class documentation states that ""To customize how the exporter works, subclass this and override..."" (https://docs.spring.io/spring-data/rest/docs/current/api/org/springframework/data/rest/webmvc/config/RepositoryRestMvcConfiguration.html), that is no longer possible after DelegatingHandlerMapping has been made package private in commit d7f36b1 (https://github.com/spring-projects/spring-data-rest/commit/d7f36b118060157e208aa044eb5c1c038b2c1dc2).","closed","for: external-project,","nayakanis","2022-06-23T05:22:27Z","2022-06-23T06:19:55Z"
"","28423","@ModelAttribute name attribute is not supported in WebFlux","While reviewing #28422, I noticed that the `name` attribute in `@ModelAttribute` is not supported in WebFlux.  This is because `MethodParameter` is used instead of `SynthesizingMethodParameter` when retrieving the `@ModelAttribute` annotation. In other words, `@AliasFor` is not honored because the annotation is not _synthesized_. Consequently, only the `value` attribute is supported in WebFlux when specifying a custom name via `@ModelAttribute`.","closed","type: bug,","sbrannen","2022-05-07T15:11:47Z","2022-05-07T15:25:11Z"
"","28704","Meta-annotations are unnecessarily synthesized in MergedAnotations","While analyzing the claim in #28702, I discovered that meta-annotations are unnecessarily synthesized when attempting to synthesize a `MergedAnnotation` retrieved via the `MergedAnnotations.from(AnnotatedElement, ...).get()` API.  This is a regression in our merged annotation support introduced when the `MergedAnnotations` API replaced our previous support, and the source of the bug is the logic in `TypeMappedAnnotation#createSynthesized()`.  In theory, I could have detected this regression earlier when I had to change a test in `BootstrapUtilsTests` (see commit ce87285be5d4be7ab9d981273acac8a8624883dc), since `@BootstrapWith` should never have been synthesized; however, I overlooked that detail at the time.","closed","theme: aot,","sbrannen","2022-06-25T15:06:41Z","2022-06-26T08:11:59Z"
"","28596","Kotlin examples for setter injection incorrectly use field injection","While analyzing #28590, I noticed that many of the examples involving setter injection and Kotlin incorrectly use field injection.  Searching for `lateinit var movieFinder: MovieFinder` will reveal several of those -- for example, those using `@Resource`, `@Autowired`, `@Inject`.  There may well be other cases in the reference manual.  ----  Regarding the ""fix"", #28590 proposed the `@Required set` shorthand syntax for annotating a setter method in Kotlin. I'm not a Kotlin expert and therefore assume that works, but I'm wondering if it wouldn't be better to demonstrate annotated setter methods with a complete `setXyz(...)` method.","closed","in: kotlin,","sbrannen","2022-06-09T12:26:54Z","2022-07-13T08:14:51Z"
"","28271","Add application/graphql+json Media type and MIME type constants","While `MimeTypeUtils` and `MediaType` are not meant to thoroughly list all types, or even commonly used types - those classes should list types that are supported by Spring Framework or central to projects in the Spring portfolio.  Given spring-projects/spring-graphql#108, this issue is about adding the `""application/graphql+json""` type.","closed","type: enhancement,","bclozel","2022-04-01T16:56:50Z","2022-04-01T17:25:36Z"
"","27972","Inconsistent behaviour in spring-orm between EntityManagerFactoryUtils.closeEntityManager() and SessionFactoryUtils.closeSession()","Whereas `EntityManagerFactoryUtils.closeEntityManager()` will check if EntityManager is open before trying to close it, `SessionFactoryUtils.closeSession()` doesn't check if session is open.  As a consequence, if EntityManager is closed when entering `closeEntityManager()`, nothing will happen, whereas if Session is closed when entering `closeSession()`, a log ERROR will be generated (because of ""org.hibernate.SessionException: Session was already closed"") (tested with Spring 5.2 + Hibernate 5.1).  Maybe we could have a common behaviour between both classes ?  See related commit for EntityManagerFactoryUtils : https://github.com/spring-projects/spring-framework/commit/928f5423af2f64ca9578801adaa8c9612500b952  ---  Context :  - module spring-orm   - class `org.springframework.orm.jpa.EntityManagerFactoryUtils`   - class `org.springframework.orm.hibernate5.SessionFactoryUtils`","closed","type: enhancement,","ghusta","2022-01-24T16:46:25Z","2022-01-26T08:20:29Z"
"","28519","Testing transaction rollbacks without polluting other tests using Propagation.NESTED","When writing tests, developers often use: ```     @Test     @Transactional ``` to make sure that the database is cleared after each test, this is great but has a major drawback. Sometimes you want to test a transactional function that might rollback in some service:  ```     @Test     @Transactional     void checkRollbackIfFails() throws Exception {         Mockito.doThrow(Exception.class).when(myService).sendInvoiceRequest(any(Document.class));          int databaseSizeBeforeTest = documentReminderRepository.findAll().size();          em.merge(documentReminder.getDocument().type(DocumentType.MEDIDATA));         DocumentReminderDTO documentReminderDTO = documentReminderMapper.toDto(documentReminder);           .perform(                 post(ENTITY_API_URL).content(documentReminderDTO)             ).andExpect(status().is5xxServerError());          List documentReminderList = documentReminderRepository.findAll();         assertThat(documentReminderList).hasSize(databaseSizeBeforeTest);     } ```   Being in the same transaction prevents from knowing if the transaction will rollback correctly, so a fix to this would be to send the request in a nested transaction and check that the nested one did rollback correctly.  ```     @Test     @Transactional     void checkRollbackIfFails() throws Exception {         Mockito.doThrow(Exception.class).when(myService).sendInvoiceRequest(any(Document.class));          int databaseSizeBeforeTest = documentReminderRepository.findAll().size();          em.merge(documentReminder.getDocument().type(DocumentType.MEDIDATA));         DocumentReminderDTO documentReminderDTO = documentReminderMapper.toDto(documentReminder);          this.sendCreateRequestInNewTransaction(documentReminderDTO).andExpect(status().is5xxServerError());          List documentReminderList = documentReminderRepository.findAll();         assertThat(documentReminderList).hasSize(databaseSizeBeforeTest);     }            @Transactional(propagation = Propagation.NESTED)     protected ResultActions sendRequestInNewTransaction(DocumentReminderDTO documentReminderDTO) throws Exception {         return restDocumentReminderMockMvc             .perform(                 post(ENTITY_API_URL).content(documentReminderDTO)             );     } ```  For some reason this doesn't work either we can see the reminder created by sending the request event after the nested transaction is supposed to rolled back.  Better context for understanding the logic of the code: When calling the ENTITY_API_URL a reminder is saved to the db and its new id is used to send a request to a remote server, if sending the requesting to the remote server fails, the reminder should be deleted like nothing ever happened. I would like to test that the rollback if anything bad happens. repository.delete can be used to delete instead of rollingback but I should be forced to change a good logic to make my tests work.","open","status: waiting-for-triage,","yelhouti","2022-05-24T14:09:04Z","2022-05-24T14:10:25Z"
"","28645","Introduce supports() method in BeanPostProcessor","When writing an implementation class for the `BeanPostProcessor` interface, you usually have the following code:  ```java @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {     if (bean instanceof People) {         // do something     }     return bean; } ```  The `BeanPostProcessor` interface implementation class needs to enter this code each time it passes through each if block, and some of these entries don't do anything to the bean object, but return it directly.  Maybe the `BeanPostProcessor` interface can have a `supports()` method to judge whether to support processing in the `postProcessBeforeInitialization` method.  The improved code is as follows.  ```java public interface BeanPostProcessor  {     @Nullable     default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {         return bean;     }      @Nullable     default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {         return bean;     }      default boolean supports(Object bean, String beanName) {         return true;     } } ```","open","type: enhancement,","huifer","2022-06-17T07:47:33Z","2022-06-17T13:04:17Z"
"","28392","FormHttpMessageConverter should not have a dependency on the Jakarta Mail API","When working with `multipartCharset` the `FormHttpMessageConverter` uses the `MimeUtility.encodeText` method. This forces a dependency for sending email inside a HTTP converter.  In our case, we now need to import `org.springframework.boot:spring-boot-starter-mail` to fix this dependency.  Could an alternative import be used here to avoid such dependencies in the case of `Content-Type` `multipart`?  We found this issue when using a simple REST API.","closed","type: enhancement,","jomastel","2022-04-28T07:55:58Z","2022-05-02T12:48:33Z"
"","28639","suggestion for Aop","When we use aop to catch one function, offering a paramsMap for the method is very useful ! because we can not find any evidence for   proceedingJoinPoint.getSignature().getParameterNames()  and   proceedingJoinPoint.getArgs()  has the same order or determined pair of key and value.","closed","in: core,","dayAndnight2018","2022-06-16T12:00:41Z","2022-06-30T13:20:27Z"
"","28309","header() method in webflux WebClient need to add another method.","When using WebClient, I found that when using WebClient I need headerName and headerValue as parameters in header method. I think that users can only put text in parameters.","closed","status: invalid,","SonYoonSeok","2022-04-09T14:56:09Z","2022-04-09T15:48:15Z"
"","28201","@Async aspect fix change bean factory","When using AspectJ and multi-context (ex: testing), the bean factory needs to be changed on the singleton aspect. This fix clears cached method executors when changing bean factory. If the first context was previously closed with the executors, then an error will be thrown when trying to reuse the closed executor.","open","status: feedback-provided,","cdalexndr","2022-03-19T20:46:15Z","2022-03-20T17:27:45Z"
"","28879","Add native-image support for RestTemplateBuilder","When using `RestTemplateBuilder` in a native-image, for example in this code:  ```java private final RestTemplateBuilder restTemplateBuilder;  // ...  RestTemplate restTemplate = this.restTemplateBuilder   .setConnectTimeout(Duration.ofSeconds(5))   .setReadTimeout(Duration.ofSeconds(5))   .build(); ```  then this fails in a native image with this stacktrace:  ``` java.lang.IllegalStateException: Request factory class org.springframework.http.client.SimpleClientHttpRequestFactory does not have a suitable setConnectTimeout method 	at org.springframework.boot.web.client.RestTemplateBuilder$RequestFactoryCustomizer.findMethod(RestTemplateBuilder.java:782) 	at org.springframework.boot.web.client.RestTemplateBuilder$RequestFactoryCustomizer.setConnectTimeout(RestTemplateBuilder.java:761) 	at org.springframework.boot.web.client.RestTemplateBuilder$RequestFactoryCustomizer.accept(RestTemplateBuilder.java:736) 	at org.springframework.boot.web.client.RestTemplateBuilder.buildRequestFactory(RestTemplateBuilder.java:656) 	at org.springframework.boot.web.client.RestTemplateBuilder.configure(RestTemplateBuilder.java:614) 	at org.springframework.boot.web.client.RestTemplateBuilder.build(RestTemplateBuilder.java:589) 	at com.example.resttemplate.CLR.http(CLR.java:33) 	at com.example.resttemplate.CLR.run(CLR.java:26) 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:768) 	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:752) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:320) 	at com.example.resttemplate.RestTemplateApplication.main(RestTemplateApplication.java:13) ```  This can be observed in https://ci.spring.io/teams/spring-aot-smoke-tests/pipelines/spring-aot-smoke-tests-1.0.x/jobs/rest-template/builds/1","closed","for: external-project,","mhalbritter","2022-07-27T14:02:39Z","2022-07-27T18:38:06Z"
"","28725","Add support for SchedulerFactoryBean in native-image","When trying to use the `SchedulerFactoryBean` in a native image (for example with Spring Boot and including the `spring-boot-starter-quartz` starter), it fails at runtime with:  ``` org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'quartzEndpoint': Unsatisfied dependency expressed through method 'quartzEndpoint' parameter 0: Error creating bean with name 'quartzScheduler': Failed to instantiate [org.quartz.impl.StdSchedulerFactory]: No default constructor found         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArgument(AutowiredInstantiationArgumentsResolver.java:319) ~[na:na]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArguments(AutowiredInstantiationArgumentsResolver.java:232) ~[na:na]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:154) ~[na:na]         at org.springframework.boot.actuate.autoconfigure.quartz.QuartzEndpointAutoConfiguration__BeanDefinitions.getQuartzEndpointInstance(QuartzEndpointAutoConfiguration__BeanDefinitions.java:43) ~[na:na]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1141) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.lambda$createEndpointBean$1(EndpointDiscoverer.java:145) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer$EndpointBean.getBean(EndpointDiscoverer.java:447) ~[na:na]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.getFilterEndpoint(EndpointDiscoverer.java:307) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.isFilterMatch(EndpointDiscoverer.java:285) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.isExtensionExposed(EndpointDiscoverer.java:239) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.addExtensionBean(EndpointDiscoverer.java:170) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.addExtensionBeans(EndpointDiscoverer.java:159) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.discoverEndpoints(EndpointDiscoverer.java:124) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.getEndpoints(EndpointDiscoverer.java:117) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.actuate.autoconfigure.health.HealthEndpointWebExtensionConfiguration.getHealthEndpoint(HealthEndpointWebExtensionConfiguration.java:62) ~[actuator-aot:0.0.1-SNAPSHOT]         at org.springframework.boot.actuate.autoconfigure.health.HealthEndpointWebExtensionConfiguration$MvcAdditionalHealthEndpointPathsConfiguration.healthEndpointWebMvcHandlerMapping(HealthEndpointWebExtensionConfiguration.java:74) ~[actuator-aot:0.0.1-SNAPSHOT]         at org.springframework.boot.actuate.autoconfigure.health.HealthEndpointWebExtensionConfiguration_MvcAdditionalHealthEndpointPathsConfiguration__BeanDefinitions.lambda$getHealthEndpointWebMvcHandlerMappingInstance$0(HealthEndpointWebExtensionConfiguration_MvcAdditionalHealthEndpointPathsConfiguration__BeanDefinitions.java:44) ~[na:na]         at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:63) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:51) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:156) ~[na:na]         at org.springframework.boot.actuate.autoconfigure.health.HealthEndpointWebExtensionConfiguration_MvcAdditionalHealthEndpointPathsConfiguration__BeanDefinitions.getHealthEndpointWebMvcHandlerMappingInstance(HealthEndpointWebExtensionConfiguration_MvcAdditionalHealthEndpointPathsConfiguration__BeanDefinitions.java:44) ~[na:na]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:729) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:428) ~[actuator-aot:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[actuator-aot:3.0.0-SNAPSHOT]         at com.example.actuator_aot.ActuatorAotApplication.main(ActuatorAotApplication.java:29) ~[actuator-aot:0.0.1-SNAPSHOT] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'quartzScheduler': Failed to instantiate [org.quartz.impl.StdSchedulerFactory]: No default constructor found         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1752) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:604) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1374) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1294) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArgument(AutowiredInstantiationArgumentsResolver.java:302) ~[na:na]         ... 46 common frames omitted Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.quartz.impl.StdSchedulerFactory]: No default constructor found         at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:146) ~[na:na]         at org.springframework.scheduling.quartz.SchedulerFactoryBean.prepareSchedulerFactory(SchedulerFactoryBean.java:529) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.scheduling.quartz.SchedulerFactoryBean.afterPropertiesSet(SchedulerFactoryBean.java:504) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1798) ~[actuator-aot:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1748) ~[actuator-aot:6.0.0-SNAPSHOT]         ... 56 common frames omitted Caused by: java.lang.NoSuchMethodException: org.quartz.impl.StdSchedulerFactory.()         at java.lang.Class.getConstructor0(DynamicHub.java:3585) ~[actuator-aot:na]         at java.lang.Class.getDeclaredConstructor(DynamicHub.java:2754) ~[actuator-aot:na]         at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:141) ~[na:na]         ... 60 common frames omitted ```  The factory bean tries to instantiate the `SchedulerFactory` via `BeanUtils.instantiateClass` which fails, because there are no reflection hints for the constructor of that class.","open","theme: aot,","mhalbritter","2022-06-29T08:46:16Z","2022-07-21T14:15:43Z"
"","27983","Improve log message when searching for default executor for async processing","When there are more than 1 TaskExecutors bean defined in the application, the whole stack trace will be printed.  And with statement `""Could not find unique TaskExecutor bean""` only.  The statement can be improved such that, `""Could not find unique TaskExecutor bean, continue to find the bean using name {DEFAULT_TASK_EXECUTOR_BEAN_NAME}""`,   This statement can also be shown after the targeted bean is resolved successfully.  https://github.com/spring-projects/spring-framework/blob/786d80c0bbae28aa703df94065992e9377086617/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.java#L236","closed","type: enhancement,","tombyong","2022-01-28T03:45:49Z","2022-02-09T06:47:33Z"
"","28034","spring MVC params issues","When spring MVC receives a string type parameter in the controller's method, the requested URL and form data have this parameter at the same time, and the back-end will merge the parameters received  ![image](https://user-images.githubusercontent.com/39784893/153531581-b41e9425-ce10-4ce0-9c78-3d8c11d7bb47.png) ![image](https://user-images.githubusercontent.com/39784893/153531608-c92d5e40-a4d9-41ca-8cb2-9755ffa00d5c.png)","closed","for: stackoverflow,","shootday","2022-02-11T03:04:00Z","2022-02-11T07:10:54Z"
"","28724","TestExecutionListener does not get applied for a new context for @Nested test class","When setting up `@SpringBootTest` as follows:  ```kotlin @SpringBootTest(classes = [MyTestComponent::class]) @TestExecutionListeners(value = [MyTestExecutionListener::class], mergeMode = MERGE_WITH_DEFAULTS) @TestConstructor(autowireMode = ALL) class TestExecutionListenersNestedApplicationTests(private val testComponent: MyTestComponent) {   // ...   @TestComponent   class MyTestComponent(var enabled: Boolean = false)    class MyTestExecutionListener : TestExecutionListener {      override fun beforeTestMethod(testContext: TestContext) {       testContext.applicationContext.getBean(MyTestComponent::class.java).enabled = true     }      override fun afterTestMethod(testContext: TestContext) {       testContext.applicationContext.getBean(MyTestComponent::class.java).enabled = false     }   }   // ... }   ```  I would expect both of these `@Nested` test classes to behave the same way:  ```kotlin   @Nested   inner class ClassWithSameContext {      @Test     fun noProblemo() {       assertThat(testComponent.enabled).isTrue     }   }    @Nested   @TestPropertySource(properties = [""test=true""])   inner class ClassWithDifferentContext {      @Test     fun problemo() {       assertThat(testComponent.enabled).isTrue     }   } ```  However, the test in the first one passes and the test in the second one fails.   This looks like a bug to me, or am I missing something?  Stepping through the test with a debugger shows that a context gets processed in the `beforeTestMethod()` method, but that context does not seem to be used in the test.   See  [here](https://github.com/vootelerotov/test-execution-listener-with-nested-class/) for a runnable sample project.","closed","status: invalid,","vootelerotov","2022-06-28T19:36:36Z","2022-07-04T15:52:02Z"
"","28185","Reflective illegal access to java.lang.SecurityManager.getClassContext()","When running the spring-boot application i have this warning.  Running with `--illegal-access=debug` i found this:  ``` WARNING: Illegal reflective access by nonapi.io.github.classgraph.classpath.CallStackReader (file:.../.m2/repository/io/github/classgraph/classgraph/4.8.138/classgraph-4.8.138.jar) to method java.lang.SecurityManager.getClassContext() 	at nonapi.io.github.classgraph.classpath.CallStackReader.getCallStackViaSecurityManager(CallStackReader.java:119) 	at nonapi.io.github.classgraph.classpath.CallStackReader.access$100(CallStackReader.java:44) 	at nonapi.io.github.classgraph.classpath.CallStackReader$3.call(CallStackReader.java:178) 	at nonapi.io.github.classgraph.classpath.CallStackReader$3.call(CallStackReader.java:175) 	at nonapi.io.github.classgraph.reflection.ReflectionUtils$PrivilegedActionInvocationHandler.invoke(ReflectionUtils.java:383) 	at com.sun.proxy.$Proxy139.run(Unknown Source) 	at java.base/java.security.AccessController.doPrivileged(Native Method) 	at nonapi.io.github.classgraph.reflection.ReflectionUtils.doPrivileged(ReflectionUtils.java:396) 	at nonapi.io.github.classgraph.classpath.CallStackReader.getClassContext(CallStackReader.java:175) 	at nonapi.io.github.classgraph.classpath.ClasspathFinder.(ClasspathFinder.java:163) 	at io.github.classgraph.Scanner.(Scanner.java:169) 	at io.github.classgraph.ClassGraph.scanAsync(ClassGraph.java:1531) 	at io.github.classgraph.ClassGraph.scanAsync(ClassGraph.java:1559) 	at io.github.classgraph.ClassGraph.scan(ClassGraph.java:1584) 	at io.github.classgraph.ClassGraph.scan(ClassGraph.java:1623) 	at io.github.classgraph.ClassGraph.scan(ClassGraph.java:1636) 	at org.webjars.WebJarAssetLocator.scanForWebJars(WebJarAssetLocator.java:144) 	at org.webjars.WebJarAssetLocator.(WebJarAssetLocator.java:150) 	at org.springframework.web.servlet.resource.WebJarsResourceResolver.(WebJarsResourceResolver.java:61) 	at org.springframework.web.servlet.config.annotation.ResourceChainRegistration.getResourceResolvers(ResourceChainRegistration.java:114) 	at org.springframework.web.servlet.config.annotation.ResourceHandlerRegistration.getRequestHandler(ResourceHandlerRegistration.java:215) 	at org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry.getRequestHandler(ResourceHandlerRegistry.java:178) 	at org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry.getHandlerMapping(ResourceHandlerRegistry.java:168) 	at org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport.resourceHandlerMapping(WebMvcConfigurationSupport.java:599) 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:638) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ```  Do i have to worry about that?   **Affects:**  2.6.4","closed","for: external-project,","MR6996","2022-03-15T15:27:36Z","2022-03-15T15:35:10Z"
"","28697","Add runtime hints for `AbstractHandshakeHandler`","When running the native-image from the spring-native sample `websocket` on the `sb-3.0.x` branch, i get the following exception:  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'stompWebSocketHandlerMapping': Instantiation of supplied bean failed 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1234) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[websocket:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:735) ~[websocket:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:431) ~[websocket:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[websocket:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1307) ~[websocket:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1296) ~[websocket:3.0.0-SNAPSHOT] 	at com.example.websocket.WebsocketApplication.main(WebsocketApplication.java:20) ~[websocket:0.0.1-SNAPSHOT] Caused by: java.lang.IllegalStateException: Failed to instantiate RequestUpgradeStrategy: org.springframework.web.socket.server.standard.TomcatRequestUpgradeStrategy 	at org.springframework.web.socket.server.support.AbstractHandshakeHandler.initRequestUpgradeStrategy(AbstractHandshakeHandler.java:160) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.web.socket.server.support.AbstractHandshakeHandler.(AbstractHandshakeHandler.java:118) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.web.socket.server.support.DefaultHandshakeHandler.(DefaultHandshakeHandler.java:35) ~[na:na] 	at org.springframework.web.socket.server.support.WebSocketHttpRequestHandler.(WebSocketHttpRequestHandler.java:73) ~[na:na] 	at org.springframework.web.socket.config.annotation.WebMvcStompWebSocketEndpointRegistration.getMappings(WebMvcStompWebSocketEndpointRegistration.java:160) ~[na:na] 	at org.springframework.web.socket.config.annotation.WebMvcStompEndpointRegistry.getHandlerMapping(WebMvcStompEndpointRegistry.java:155) ~[na:na] 	at org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport.stompWebSocketHandlerMapping(WebSocketMessageBrokerConfigurationSupport.java:92) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport__BeanDefinitions.lambda$getStompWebSocketHandlerMappingInstance$0(WebSocketMessageBrokerConfigurationSupport__BeanDefinitions.java:38) ~[na:na] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:63) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:51) ~[websocket:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:156) ~[na:na] 	at org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurationSupport__BeanDefinitions.getStompWebSocketHandlerMappingInstance(WebSocketMessageBrokerConfigurationSupport__BeanDefinitions.java:38) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[websocket:6.0.0-SNAPSHOT] 	... 18 common frames omitted Caused by: java.lang.ClassNotFoundException: org.springframework.web.socket.server.standard.TomcatRequestUpgradeStrategy 	at java.lang.Class.forName(DynamicHub.java:1121) ~[websocket:na] 	at org.springframework.util.ClassUtils.forName(ClassUtils.java:284) ~[na:na] 	at org.springframework.web.socket.server.support.AbstractHandshakeHandler.initRequestUpgradeStrategy(AbstractHandshakeHandler.java:156) ~[websocket:6.0.0-SNAPSHOT] 	... 30 common frames omitted ```","closed","theme: aot,","mhalbritter","2022-06-24T08:51:35Z","2022-06-30T14:52:04Z"
"","28696","native-image: Problem with Scheduled annotation","When running the native-image from the spring-native sample `scheduling-tasks` on the `sb-3.0.x` branch, i get the following exception:  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'schedulingTasksApplication': Invalid declaration of container type [org.springframework.scheduling.annotation.Schedules] for repeatable annotation [org.springframework.scheduling.annotation.Scheduled] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:611) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:735) ~[scheduling-tasks:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:431) ~[scheduling-tasks:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[scheduling-tasks:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1307) ~[scheduling-tasks:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1296) ~[scheduling-tasks:3.0.0-SNAPSHOT] 	at com.example.schedulingtasks.SchedulingTasksApplication.main(SchedulingTasksApplication.java:13) ~[scheduling-tasks:0.0.1-SNAPSHOT] Caused by: org.springframework.core.annotation.AnnotationConfigurationException: Invalid declaration of container type [org.springframework.scheduling.annotation.Schedules] for repeatable annotation [org.springframework.scheduling.annotation.Scheduled] 	at org.springframework.core.annotation.RepeatableContainers$ExplicitRepeatableContainer.(RepeatableContainers.java:219) ~[na:na] 	at org.springframework.core.annotation.RepeatableContainers.of(RepeatableContainers.java:117) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.core.annotation.AnnotatedElementUtils.getRepeatableAnnotations(AnnotatedElementUtils.java:759) ~[na:na] 	at org.springframework.core.annotation.AnnotatedElementUtils.getMergedRepeatableAnnotations(AnnotatedElementUtils.java:455) ~[na:na] 	at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.lambda$postProcessAfterInitialization$0(ScheduledAnnotationBeanPostProcessor.java:366) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.core.MethodIntrospector.lambda$selectMethods$0(MethodIntrospector.java:74) ~[na:na] 	at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:366) ~[na:na] 	at org.springframework.core.MethodIntrospector.selectMethods(MethodIntrospector.java:72) ~[na:na] 	at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.postProcessAfterInitialization(ScheduledAnnotationBeanPostProcessor.java:364) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:440) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1755) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:604) ~[scheduling-tasks:6.0.0-SNAPSHOT] 	... 14 common frames omitted Caused by: java.lang.NoSuchMethodException: No value method found 	at org.springframework.core.annotation.RepeatableContainers$ExplicitRepeatableContainer.(RepeatableContainers.java:203) ~[na:na] 	... 25 common frames omitted ```","closed","theme: aot,","mhalbritter","2022-06-24T08:48:03Z","2022-07-04T15:10:10Z"
"","28689","native-image: Support for MethodValidationPostProcessor","When running the native-image from the spring-native sample `cloud-config/configserver` on the `sb-3.0.x` branch, i get the following exception:  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'methodValidationPostProcessor': Instantiation of supplied bean failed 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1234) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:205) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:261) ~[na:na] 	at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:771) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:576) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[configserver:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:735) ~[configserver:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:431) ~[configserver:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[configserver:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1307) ~[configserver:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1296) ~[configserver:3.0.0-SNAPSHOT] 	at org.demo.configserver.ConfigServerApplication.main(ConfigServerApplication.java:19) ~[configserver:0.0.1-SNAPSHOT] Caused by: com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces [interface jakarta.validation.Validator, interface org.springframework.aop.SpringProxy, interface org.springframework.aop.framework.Advised, interface org.springframework.core.DecoratingProxy] not found. Generating proxy classes at runtime is not supported. Proxy classes need to be defined at image build time by specifying the list of interfaces that they implement. To define proxy classes use -H:DynamicProxyConfigurationFiles= and -H:DynamicProxyConfigurationResources= options. 	at com.oracle.svm.core.util.VMError.unsupportedFeature(VMError.java:89) ~[na:na] 	at com.oracle.svm.reflect.proxy.DynamicProxySupport.getProxyClass(DynamicProxySupport.java:158) ~[na:na] 	at java.lang.reflect.Proxy.getProxyConstructor(Proxy.java:48) ~[configserver:na] 	at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:1037) ~[configserver:na] 	at org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:126) ~[na:na] 	at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110) ~[na:na] 	at org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver.buildLazyResolutionProxy(ContextAnnotationAutowireCandidateResolver.java:130) ~[na:na] 	at org.springframework.context.annotation.ContextAnnotationAutowireCandidateResolver.getLazyResolutionProxyIfNecessary(ContextAnnotationAutowireCandidateResolver.java:54) ~[na:na] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1291) ~[configserver:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArgument(AutowiredInstantiationArgumentsResolver.java:302) ~[na:na] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArguments(AutowiredInstantiationArgumentsResolver.java:232) ~[na:na] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:154) ~[na:na] 	at org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration__BeanDefinitions.getMethodValidationPostProcessorInstance(ValidationAutoConfiguration__BeanDefinitions.java:68) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[configserver:6.0.0-SNAPSHOT] 	... 18 common frames omitted ```  Looks like there are some proxy hints missing.","closed","theme: aot,","mhalbritter","2022-06-23T14:49:33Z","2022-07-01T08:20:36Z"
"","28709","Jackson well-known module support in native image","When running the binary from the `webflux-kotlin` sample from spring-native, I get the following exception:  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jacksonObjectMapper': Instantiation of supplied bean failed         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1234) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[webflux-kotlin:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:729) ~[webflux-kotlin:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:428) ~[webflux-kotlin:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[webflux-kotlin:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[webflux-kotlin:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1290) ~[webflux-kotlin:3.0.0-SNAPSHOT]         at com.example.webflux.WebfluxApplicationKt.main(WebfluxApplication.kt:16) ~[webflux-kotlin:0.0.1-SNAPSHOT] Caused by: kotlin.jvm.KotlinReflectionNotSupportedError: Kotlin reflection implementation is not found at runtime. Make sure you have kotlin-reflect.jar in the classpath         at kotlin.jvm.internal.ClassReference.error(ClassReference.kt:88) ~[na:na]         at kotlin.jvm.internal.ClassReference.getConstructors(ClassReference.kt:21) ~[na:na]         at kotlin.reflect.jvm.ReflectJvmMapping.getKotlinFunction(ReflectJvmMapping.kt:146) ~[na:na]         at org.springframework.beans.BeanUtils$KotlinDelegate.instantiateClass(BeanUtils.java:869) ~[na:na]         at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:191) ~[na:na]         at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:152) ~[na:na]         at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.registerWellKnownModulesIfAvailable(Jackson2ObjectMapperBuilder.java:842) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.configure(Jackson2ObjectMapperBuilder.java:689) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.build(Jackson2ObjectMapperBuilder.java:672) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration$JacksonObjectMapperConfiguration.jacksonObjectMapper(JacksonAutoConfiguration.java:113) ~[webflux-kotlin:3.0.0-SNAPSHOT]         at org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration_JacksonObjectMapperConfiguration__BeanDefinitions.lambda$getJacksonObjectMapperInstance$0(JacksonAutoConfiguration_JacksonObjectMapperConfiguration__BeanDefinitions.java:43) ~[na:na]         at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:63) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:51) ~[webflux-kotlin:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:156) ~[na:na]         at org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration_JacksonObjectMapperConfiguration__BeanDefinitions.getJacksonObjectMapperInstance(JacksonAutoConfiguration_JacksonObjectMapperConfiguration__BeanDefinitions.java:43) ~[na:na]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[webflux-kotlin:6.0.0-SNAPSHOT]         ... 18 common frames omitted ```  There is  ``` 		 			org.jetbrains.kotlin 			kotlin-reflect 		 ```  in the `pom.xml`, the sample runs with `mvn spring-boot:run`","closed","in: kotlin,","mhalbritter","2022-06-27T09:42:42Z","2022-06-30T13:28:59Z"
"","28717","Add support for `@Transactional` in native images","When running the `jdbc-tx` sample in `sb-3.0.x` branch from spring-native, it fails with:  ``` java.lang.IllegalStateException: Failed to execute CommandLineRunner         at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:769) ~[jdbc-tx:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:750) ~[jdbc-tx:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:318) ~[jdbc-tx:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[jdbc-tx:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1290) ~[jdbc-tx:3.0.0-SNAPSHOT]         at app.main.SampleApplication.main(SampleApplication.java:23) ~[jdbc-tx:0.0.1.BUILD-SNAPSHOT] Caused by: java.lang.IllegalArgumentException: Expected transaction         at org.springframework.util.Assert.isTrue(Assert.java:121) ~[na:na]         at app.main.Runner.run(Runner.java:53) ~[jdbc-tx:0.0.1.BUILD-SNAPSHOT]         at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:766) ~[jdbc-tx:3.0.0-SNAPSHOT]         ... 5 common frames omitted ```  This is the run method:  ```java 	@Override 	@Transactional 	public void run(String... args) throws Exception { 		Assert.isTrue(TransactionSynchronizationManager.isActualTransactionActive(), ""Expected transaction""); 		try { 			find(1L); 		} 		catch (EmptyResultDataAccessException e) { 			entities.update(ADD_FOO, 1L, ""Hello""); 		} 	} ```  I guess that `@Transactional` doesn't work in native-image.","closed","theme: aot,","mhalbritter","2022-06-28T08:34:19Z","2022-07-08T14:50:55Z"
"","28710","EnableAsync doesn't work in native-image","When running the `async` sample from spring-native in `sb-3.0.x` branch in a native image, it fails. There's no exception, but the method annotated with `@Async` isn't executed on some worker thread but on the calling thread.","open","theme: aot,","mhalbritter","2022-06-27T11:59:04Z","2022-06-28T13:31:47Z"
"","28304","Add @DirtiesContext parameter to dirty only after whole main test class when it contains @Nested classes","When running Tests using @DirtiesContext and test class includes multiple @Nested classes, context is dirtied and refreshed after each nested class, even using the coarsest possible level (ClassMode.AFTER_CLASS).   There is currently no parameter to specify @DirtiesContext to only dirty after the main class but no after each nested class. A ClassMode.AFTER_MAIN_CLASS is suggested to specify desired functionality.","open","status: waiting-for-triage,","jmarchionatto","2022-04-07T19:50:02Z","2022-04-27T20:19:01Z"
"","27929","BeanPropertyRowMapper underscoreName prepends redundant underscore when field descriptor begins in uppercase","When pojo contains eMail field and Lombok generates setEMail accessor, then BeanPropertyRowMappers underscoreName is _e_mail, which breaks database integration. Symptom appeared with Spring 5.3 from commit https://github.com/spring-projects/spring-framework/commit/6316a353bb074b118ab71ad89fe60553c4d073c9","closed","status: superseded,","patrickabner","2022-01-13T12:48:35Z","2022-01-17T14:52:56Z"
"","27970","ReflectionUtils.USER_DECLARED_METHODS does not filter methods declared in java.lang.Object","When I saw the AOP source code, I found that the `getAdvisorMethods` method in `ReflectiveAspectJAdvisorFactory` introspects the methods of `Object`, and I am confused about this.  The sample as follow,  ```java @Aspect @EnableAspectJAutoProxy @Slf4j public class AopConfig {      @Around(""execution(* cn.hiboot.framework.research.spring.research.SimpleStart.*(..))"")     public Object around(ProceedingJoinPoint p) throws Throwable {         log.info(""proceed before"");         Object obj = p.proceed();         log.info(""proceed after);         return obj;     }  } ```  ```java @Slf4j @Import(AopConfig.class) public class SimpleStart {      public SimpleStart() {         log.info(""execute constructor"");     }      public String test(){         return ""test method return value"";     }  } ```  ```java   @Test   public void research(){       AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SimpleStart.class);       SimpleStart bean = context.getBean(SimpleStart.class);       bean.test();   } ```  When a superclass is `Object`, it continues recursively, because in `ReflectiveAspectJAdvisorFactory.adviceMethodFilter` the `mf = ReflectionUtils.USER_DECLARED_METHODS.and(method -> (AnnotationUtils.getAnnotation(method, Pointcut.class) == null))`.  The source code position:  https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java#L369","closed","in: core,","kse-music","2022-01-23T08:13:29Z","2022-01-24T19:40:38Z"
"","27964","In AbstractApplicationContext prepareRefresh() ""this.earlyApplicationListeners is not null""","when i debug i always find this.earlyApplicationListeners is null","closed","for: stackoverflow,","huanghe1993","2022-01-21T08:13:43Z","2022-01-21T10:43:43Z"
"","28873","A @Component is skipped during scanning when a @Configuration class with the same name has already been registered","When a Spring Bean is named exactly like the spring boot application class a `NoSuchBeanDefinitionException` is thrown. The error message is quite confusing because a bean of the specific type exists on source-code level. Just because the application class is equally named it cannot be found.  I think it should be possible to detect this and throw a more appropriate exception or a textual hint.  I also think that this issue is quite likely to appear in microservice-environments with a bounded context and is not just an edge-case.  Steps to reproduce: 1. Create a spring boot application ```java @SpringBootApplication public class FooService {  	public static void main(String[] args) { 		SpringApplication.run(FooService.class, args); 	} } ``` 2. In another package create a bean with the same name as the application class ```java @Service public class FooService { } ``` 3. Create a service which injects the previously created bean ```java @Service public class BarService { 	private final FooService fooService;  	public BarService(FooService fooService) { 		this.fooService = fooService; 	} } ``` 4. Start the application  It will produce the following output: ``` 2022-07-23 15:49:38.770  INFO 27400 --- [           main] com.example.demo.FooService              : Starting FooService using Java 17.0.3 on DESKTOP-3FIUVON with PID 27400 (P:\tmp\spring-boot-naming-error\target\classes started by tobi in P:\tmp\spring-boot-naming-error) 2022-07-23 15:49:38.776  INFO 27400 --- [           main] com.example.demo.FooService              : No active profile set, falling back to 1 default profile: ""default"" 2022-07-23 15:49:39.340  WARN 27400 --- [           main] s.c.a.AnnotationConfigApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'barService' defined in file [P:\tmp\spring-boot-naming-error\target\classes\com\example\demo\deeper\BarService.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.example.demo.deeper.FooService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {} 2022-07-23 15:49:39.354  INFO 27400 --- [           main] ConditionEvaluationReportLoggingListener :   Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-07-23 15:49:39.398 ERROR 27400 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   :   *************************** APPLICATION FAILED TO START ***************************  Description:  Parameter 0 of constructor in com.example.demo.deeper.BarService required a bean of type 'com.example.demo.deeper.FooService' that could not be found.   Action:  Consider defining a bean of type 'com.example.demo.deeper.FooService' in your configuration.   Process finished with exit code 1 ```","open","in: core,","twobiers","2022-07-23T14:00:46Z","2022-07-27T12:09:03Z"
"","28111","Support for ImportAware in AOT-processed contexts","When a context is pre-processed by the AOT engine, there's no configuration class parsing at runtime anymore and the link between an `ImportAware` configuration class and the class that imported it should be preserved.  This can be done by computing the mapping and then providing a post procesor that honors the callback.","closed","theme: aot,","snicoll","2022-02-28T10:35:18Z","2022-03-09T10:23:48Z"
"","28088","Add API to contribute to the setup of an ApplicationContext","When a context is pre-processed at build-time and we generate optimized code for it, bean definition registration is one obvious part but not the only one. The core container should have an abstraction and an API that other components can implement to contribute to the setup of the context.  One example is the thing that scans for `@EventListener`-annotated methods and register an event-listener if necessary. As these components are actually replacing something else, they could opt-in for excluding bean definitions that they are replacing.","closed","theme: aot,","snicoll","2022-02-21T13:34:32Z","2022-03-09T12:21:45Z"
"","28154","Ambiguous check only applied to constructors","When a constructor should be invoked to create a bean instance, there is the danger that several flavors exist with different parameter types so that the call to `new MyBean(attributes.get(0)` is ambiguous as the type is not declared.  There is an explicit check for this case where an explicit type-based method on `InjectedElementAttributes` is used. Unfortunately, it hasn't been applied to factory methods that suffer from the same problem if several methods have a similar signature.","closed","theme: aot,","snicoll","2022-03-10T13:10:11Z","2022-03-10T14:37:49Z"
"","28241","AbstractListenerReadPublisher does not call `ServletOutputStream::isReady()` when reading chunked data across network packets","When a client POSTs data using chunked encoding, and a network packet ends immediately after the chunk header, but before the chunk body, the `AbstractListenerReadPublisher` hangs under Tomcat, especially in constrained environments.   When the packet that ends with the chunk header is received, Tomcat calls `ReadListener::onDataAvailable()`.  The `ServletServerHttpRequest.RequestBodyPublisher` calls `ServletOutputStream::isReady()`, which returns `true`. The `RequestBodyPublisher` tries to read data, and Tomcat processes the chunk header (so data has been read from the network). However, there is no actual content available (yet), so Tomcat returns 0 bytes. The `RequestBodyPublisher` sees no data has been read, and switches state to DEMAND. The `RequestBodyPublisher` doesn't call `isReady()` because it assumes the read terminated, as `isReady()` returned `false`. No call to `isReady()` means the socket is not registered for read and everything hangs.  Special thanks to @markt-asf for investigating the issue, and providing the description above.","closed","type: bug,","poutsma","2022-03-28T10:23:22Z","2022-04-01T16:58:17Z"
"","28181","Fix ReloadableResourceBundleMessageSource stale cache","When `ReloadableResourceBundleMessageSource.getMessage()` is called, cache is initiated with basenames values present  at the moment of invocation (in method `getMergedProperties()`). When new basenames are added (method `addBasenames()`) or changed (method `setBasenames()`), cache is not invalidated, although it is stale given the new basenames. The proposed fix addresses this problem by invalidating cache at those two points.","open","in: core,","ahmadshahwan","2022-03-15T10:15:32Z","2022-04-25T09:44:03Z"
"","28832","Make MethodName AOT class package-private","When #28831 we can take a look at `MethodName` to see if we can make it package private.","closed","theme: aot,","philwebb","2022-07-18T07:39:00Z","2022-07-25T11:39:23Z"
"","28568","webrtc call gets disconnected on unintentionally closing the browser without warning","WebRTC session disconnections are quite common, but can it be fixed using:-  - warning - popups","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-06-05T12:22:06Z","2022-06-06T12:06:49Z"
"","28583","Expose ThreadPoolTaskExecutor queue size and capacity for metrics","We're using grafana to monitor our app through java jmx exporter. We planned to configure some alerts based on those metrics, and we think it could be interesting to have at least the currentQueueCapacity for this purpose  since the queue size directly affects the app memory load. (Having the queueCapacity seems also interesting to set up triggers whose trigger value are calculated based on the maximum capacity of the queue.)","closed","type: enhancement,","rguihard","2022-06-08T09:49:42Z","2022-06-08T14:47:01Z"
"","28469","Introduce a meta-annotation that indicates the annotated element requires reflection hints","We're now at a stage where we need to port a number of hints in a sustainable way and avoid having to write dedicated code for common patterns we have in the portfolio.   On such simple pattern is the following:  ```java @EventListener public void onContextRefresh(ContextRefreshedEvent event) { ... } ```  The internal implementation processing `@EventListener` is creating a wrapper that invokes the method via reflection so that needs an invocation hint to work in restricted environment (native image).  A more complex pattern could be  ```java @GetMapping(""/dtos/{id}"") public MyDto findById(String id) { ... } ```  In this case, not only the `findById` method is invoked by reflection but the chances are high that `MyDto` is going to be serialized using some sort of converter and therefore require additional hints.  Rather than having dedicated `BeanRegistrationAotProcessor` or `BeanFactoryInitializationAotProcessor` we could build a generic one that checks for the presence of a certain annotation. We could then annotate the annotations that we know require reflection so that they are processed semi-automatically.  ```java @Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Reflective public @interface EventListener { ... } ```    `@Reflective` could take the strategy to use (a bit like `@Conditional` does). This would help us implement a more fine-grained algorithm like the MVC use case.","closed","theme: aot,","snicoll","2022-05-17T07:17:03Z","2022-05-20T13:23:06Z"
"","28801","Name RuntimeHintsRegistrar implementations consistently","We'd like to use `RuntimeHints` as suffix for `RuntimeHintsRegistrar` implementations (to follow the naming of `@ImportRuntimeHints`), and because it reads better than a `RuntimeHintsRegistrar` suffix.   This issue is about harmonizing the names we have at the moment.","closed","theme: aot,","snicoll","2022-07-12T14:14:56Z","2022-07-12T16:33:50Z"
"","28414","Refactor AOT code to reduce coupling and improve generated code","We'd like to refactor some of our current AOT code to reduce coupling and to improve the generated code.","closed","type: task,","philwebb","2022-05-05T06:13:02Z","2022-05-05T20:35:49Z"
"","28625","Set Kotlin language version to 1.7","We should change the Kotlin language version to 1.7, see [here](https://github.com/spring-projects/spring-framework/blob/933965b7b4b608b7fb6214d25e5c71bbe674cecb/build.gradle#L280-L281). Doing this allows us to upgrade to Kotlin 1.9 within the 6.0.x timeline.","closed","in: kotlin,","poutsma","2022-06-14T15:14:05Z","2022-06-15T08:56:43Z"
"","28850","MVC returns 404 for empty files in static resources in jars","We noticed a strange behavior in WebMVC when working with empty files:  We had some empty files in a classpath location configured in `org.springframework.web.servlet.config.annotation.WebMvcConfigurer#addResourceHandlers`  When running the application locally using the IDE, the files could be _""successfully""_ accessed by the browser (it got a HTTP 200 response with content-length 0)  After packaging the application, the browser suddenly got 404 responses for the empty files.  The difference seems to be in `org.springframework.core.io.AbstractFileResolvingResource#checkReadable`. As long as the empty files are actual files on the file system (`ResourceUtils.isFileURL(url) == true`), the corresponding ClasspathResource is considered both existent and readable. After packaging into a jar file, the ClasspathResource is still existent, but no longer considered readable.  I know that serving empty files as static resources is not a typical use case, but I think it should still be (a) possible and (b) consistent, regardless of whether the ClasspathResource in question is an actual File or a JarFileEntry","open","status: waiting-for-triage,","larsgrefer","2022-07-21T19:33:54Z","2022-07-31T05:09:57Z"
"","28474","Introduce AotDetector mode","We need a way to opt-in for the use of AOT on the JVM. Right now, we rely on the system property that is set when building a native image (or running with the native image agent with Native Build Tools), but this should be restricted to things that should really behave differently there.  Spring Native has [an `AotModeDetector`](https://github.com/spring-projects-experimental/spring-native/blob/d176e2d360350c5f91d0a44f9b7fefddd3f6d2db/spring-native/src/main/java/org/springframework/nativex/AotModeDetector.java#L29) we could use as an inspiration. This will also be relevant for #28205.","closed","theme: aot,","snicoll","2022-05-18T13:20:36Z","2022-06-02T12:58:25Z"
"","28030","Add code contribution infrastructure","We need a contract where individual components can provide some code, the related `RuntimeHints` that could be necessary in a constrained environment as well as whether the code is using protected access (i.e. non public types or methods).   This is required by #27921","closed","theme: aot,","snicoll","2022-02-10T14:21:30Z","2022-02-10T15:02:32Z"
"","28740","WebFlux multipart temporary file not deleted when the client disconnects early","We have a Spring WebFlux `5.3.21` application doing multipart file upload. We noticed that sometimes the `Part` temporary files would not be deleted despite doing part cleanup with `FilePart.delete()` in our controller. Further investigation revealed that the temporary files are left behind when the clients disconnect before sending the whole file. In that case, the error occurs before the controller is called.  This happens surprisingly often as the clients are mobile devices with spotty cell network connectivity.  Attached is a reproducer for the issue.  [early-disconnect-reproducer.zip](https://github.com/spring-projects/spring-framework/files/9028152/early-disconnect-reproducer.zip)","closed","type: bug,","bgK","2022-07-01T10:35:00Z","2022-07-08T14:44:29Z"
"","28027","Improve Logging for Sockettimeouts on Outgoing Flux","We had a big fight finding a problem of Connection Prematurely Closed. We had a Producer which provided a Flux and the consumer was quite slow. After 60s the Flux showed a cancel event, because internally it got a SocketTimeout Exception which was not shown in info/warn log.  Fix for us in this case was to increase the connection-timeout. To find that our producer had an internal timeout issue was quite hard, so I would propose to be more verbose on SocketTimeouts on supplied Flux streams.","open","status: feedback-provided,","Richie94","2022-02-10T12:42:24Z","2022-04-25T13:17:41Z"
"","28364","AOT contribution for @PersistenceContext and @PersistenceUnit","We don't process those at the moment.","closed","theme: aot,","snicoll","2022-04-21T13:26:50Z","2022-04-25T09:03:42Z"
"","27920","Expose a bean instance creator resolver API","We currently resolve the constructor or factory method to use to instantiate a bean using the package private `ConstructorResolver` class. When processing a `BeanFactory` at build-time, we need to retain that information (without instantiating the bean) so that we lower reflection and processing at runtime.  Right now, `ConstructorResolver`:  * Detect and instantiate the `Constructor` to use. * Detect the factory method to use and set some additional metadata in the bean definition * Instantiate the bean using the state of the bean definition  Rather than returning `BeanWrapper` we could return an object that provides the metadata that we need and wrap the instantiation call for the regular runtime behavior. However, the difference between constructor and factory method is annoying as I'd rather have a consistent API for both.   It is also unknown how we'd store the resolved arguments or if we'd need to.","open","theme: aot,","snicoll","2022-01-11T15:06:19Z","2022-07-08T15:10:08Z"
"","28074","Support escaping default value separator in property placeholders","We are using a JNDI name as a property placeholder, for example:  ```properties property1=${jndi:comp/env/smtpuser} ```  When `property1` is injected via a `@Value` annotation, Spring will assign `comp/env/smtpuser` as the value for `property1`, since there is no `jndi` property defined, resulting in the default value being used.  I know we can tweak with `JndiLocatorDelegate` etc, but if it would be nice to be able to escape `:` as a literal character so that it is not interpreted as the separator for the default value.","open","type: enhancement,","af6140","2022-02-14T20:41:41Z","2022-02-18T09:40:18Z"
"","27989","top of spring boot","we are suffering from doing repeated code in spring boot and application designing  the standard of rest should be autogenerated for a entity with ability to edit","closed","status: declined,","loveyandex","2022-01-30T12:27:55Z","2022-01-30T13:31:50Z"
"","27968","CGLIB: duplicate class definition when testing proxy classes in a dedicated servlet on Java 17","We are in the process of making our application run on Java 17 using Spring Boot 2.6 and Spring Framework 5.3.   We have a test setup where we register our web endpoints in different servlets. We do this by using the `ServletRegistrationBean` from Spring Boot and create a `DispatcherServlet` using an `AnnotationConfigWebApplicationContext`.  A linkage error occurs when we try to have different tests with different configuration, i.e. each test will create its own application context.  I have created a small project showcasing this problem (https://github.com/filiphr/spring-java-17-duplicate-class-definition).  The main error is  ``` Caused by: java.lang.LinkageError: loader 'app' attempted duplicate class definition for com.example.rest.DemoService$$EnhancerBySpringCGLIB$$8972e13d. (com.example.rest.DemoService$$EnhancerBySpringCGLIB$$8972e13d is in unnamed module of loader 'app')         at java.base/java.lang.ClassLoader.defineClass0(Native Method) ~[na:na]         at java.base/java.lang.System$2.defineClass(System.java:2307) ~[na:na]         at java.base/java.lang.invoke.MethodHandles$Lookup$ClassDefiner.defineClass(MethodHandles.java:2439) ~[na:na]         at java.base/java.lang.invoke.MethodHandles$Lookup$ClassDefiner.defineClass(MethodHandles.java:2416) ~[na:na]         at java.base/java.lang.invoke.MethodHandles$Lookup.defineClass(MethodHandles.java:1843) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]         at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:577) ~[spring-core-5.3.15.jar:5.3.15]         ... 135 common frames omitted ```  I have also found #25940 which looks like it has the same cause for the problem. However, I believe that my example is slightly less complicated.  Is it possible for Spring to do something and not create duplicate class definitions and create unique class names per application context as commented by @iherasymenko in https://github.com/spring-projects/spring-framework/issues/25940#issuecomment-712658780?","closed","status: feedback-provided,","filiphr","2022-01-22T09:03:54Z","2022-02-16T12:51:47Z"
"","28401","Customization for ObjectReader and ObjectWriter","We are finding some needs to customize the ObjectReader and ObjectWriter for Jackson serialization and deserialization, while leveraging as much default behavior as possible for both our web services running in webflux and webmvc.  After doing some investigation, it looks like AbstractJackson2Encoder already provided a customize method: https://github.com/paychex/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Encoder.java#L315  There was however no consistency to be able to do this with the ObjectReader in the AbstractJackson2Decoder or on the webmvc side, as neither the ObjectWriter or ObjectReader had customization methods in AbstractJackson2HttpMessageConverter.  This PR is for bringing the consistency so that we can now customize both for both webflux and webmvc.  This PR goes one step further as well on AbstractJackson2Decoder and AbstractJackson2Encoder to allow the customization as well from the reactive flow that will allow the ability to get contextual information from the current reactive flow for the customization which is another need we have.","open","type: enhancement,","jlaber","2022-04-30T01:18:09Z","2022-07-31T05:06:41Z"
"","28286","Difference in context initialization between 5.2.8 and 5.2.9","We are experiencing a difference in behaviour when setting up a spring context in junit tests.  Here is a simple project that shows the difference: https://github.com/mpiela/spring-ctx-bug. Usage: ``` mvn test ```  There are two tests in there:  * [SpringJavaConfigTest.java](https://github.com/mpiela/spring-ctx-bug/blob/main/src/test/java/com/example/SpringJavaConfigTest.java) - uses `@ContextConfiguration` annotation and gives it a java `@Configuration` class * [SpringXmlComponentScanTest.java](https://github.com/mpiela/spring-ctx-bug/blob/main/src/test/java/com/example/SpringXmlComponentScanTest.java) - also uses a `@ContextConfiguration` but gives it a xml configuration file which in turn just does a `component-scan`.  The issue seems to be with an overriden `@Bean` method in a `@Configuration` class and omitting the bean name in the subclass.  Both of these tests pass on Spring 5.2.8. When we switched to Spring 5.2.9 the one with the xml configuration file starts failing.   I am not really sure if this is a bug that's been fixed in 5.2.8 and 5.2.9 is the expected behaviour or if it is the other way around.","open","in: core,","mpiela","2022-04-05T07:14:52Z","2022-04-05T09:18:16Z"
"","28813","`HibernateTransactionManager` compatibility with Hibernate 6.0/6.1","We [already fixed](https://github.com/spring-projects/spring-framework/issues/28007) references to API removed in Hibernate 6 for `HibernateJpaVendorAdapter` but apparently `HibernateTransactionManager` also refers to the [very same API](https://github.com/spring-projects/spring-framework/blob/0b5c5dbc313fcd61abdf8e0f3b68a6a8fbbc0f98/spring-orm/src/main/java/org/springframework/orm/hibernate5/HibernateTransactionManager.java#L565).","closed","type: enhancement,","odrotbohm","2022-07-13T14:13:11Z","2022-07-13T16:11:17Z"
"","28500","CachingConnectionFactory with WebLogic JMS not caching producers nor consumers","Versions affected for caching consumers: 3.1.1 (2012) to last 5.x and 6.x Versions affected for caching producers: 4.3.14 and above for 4.x, 5.0.3 and above for 5.x, 6.x  ---  I just discovered a few days ago, while trying to use some advanced features of WebLogic JMS broker like ""Control Flow"", that it was not working, because producers were actually not reused, despite the fact I was correctly using a CachingConnectionFactory with JmsTemplate. The same thing occurs for consumers, for the same reason, even though it seems to me it is probably a less used feature of CachingConnectionFactory, as Spring recommends to not use it for consuming messages with DefaultMessageListenerContainer, and that's probably why this issue was unnoticed or at least not reported for the last 12 years.  **Why it doesn't work** (and will probably never work) :  Spring 3.1.1 introduced a change in CachingConnectionFactory / CachedSessionInvocationHandler to avoid caching consumers for temporary destinations.  Spring 5.0.3 introduced a very similar change (backported in 4.3.14) to avoid caching producers for temporary destinations in response to issue #20900.  Despite the fact that back in 2006, issue #7440 already reported an issue due to the fact that WebLogic had an awkward implementation of javax.jms.Detination, implementing both javax.jms.Queue and javax.jms.Topic, this was true but not the whole truth: WebLogic weblogic.jms.common.DestinationImpl (and it is still true in the very last release of WebLogic 14c), does actually implement the 4 interfaces Queue, Topic AND TemporaryQueue and TemporaryTopic. https://docs.oracle.com/cd/E92951_01/wls/WLAPI/weblogic/jms/common/DestinationImpl.html  The consequence is that it is impossible to distinguish an actual Temporary destination from a Permanent one, using code like the one used in CachingConnectionFactory :  https://github.com/spring-projects/spring-framework/blob/59c7bb1f86723e3f70f47f4556ab90cc616288a7/spring-jms/src/main/java/org/springframework/jms/connection/CachingConnectionFactory.java#L351  This behavior cannot be avoided, and is not a bug per se, not a Spring one at least, as it's only due to weird WebLogic Destination implementation.  Nevertheless, I think it would be useful to clearly signal in the chapter dedicated to CachingConnectionFactory in the reference documentation, and probably in the Javadoc as well, that caching producers and consumers features do not work with WebLogic destinations due to some WebLogic limitations, and that one has to code his own ""WebLogicCachingConnectionFactory"" if he wants to properly cache consumers and or consumers. This is what I'm doing now.  Best regards,","closed","type: documentation,","rod2j","2022-05-22T16:18:58Z","2022-06-14T13:30:59Z"
"","28656","Webclient seems to miss response on high spikes","Using Webclient we are doing the following ![image](https://user-images.githubusercontent.com/42731841/174477635-2e018787-8e0a-41e2-9963-58bc5540a650.png)   where timeout is set to 1 second.  Usually this code is doing great, handling our peak times easily, and there are no problems.  In some cases we are having pre-planned high spikes of traffic (10k requests at 2-5 seconds), and after those spikes it seems that this method never recovers (the load is back to minimal, around 1 request per sec).  It sends the request, on the other end we see the request is made and there is an answer, but here we wait 30 seconds (even though the timeout is 1 second) and after those 30 seconds there is the timeout.  Restarting the service fixed the issue.  Is there some known issues with high spikes? any way to investigate since onError is not emitted?  Thanks for your time and help!  springBootVersion = '2.4.13' spring-webflux: 5.3.13","closed","in: web,","NitzanShifrin","2022-06-19T11:02:31Z","2022-07-03T14:05:21Z"
"","28371","Unable to disable decoding Path Parameter in RestController","Using Spring-Boot 2.3.12, we followed the solution on https://github.com/spring-projects/spring-framework/issues/20211 and add   `server.undertow.decode-url: false`  to disable request decoding. The request mapping is:  `/foo/{id}/bar/{value}`  After the following GET request, the request reach to REST controller.  `GET /foo/83115320/bar/test+%2B-%2F%3A%3D_`  We would expect the value inside the controller is kept as-is due to disabled decoding: `test+%2B-%2F%3A%3D_`  However, we actually get something like the following which has been decoded: `test++-/:=_`  I debugged into the code and the decoding happens around org.springframework.web.method.annotation: `	Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);`  the request URI inside webRequest has not changed.","open","status: waiting-for-triage,","taoj-action","2022-04-23T17:38:48Z","2022-04-26T01:43:42Z"
"","28211","Extra directory added when retrieving assets","Using Spring 2.6.4, I have this method which returns a page:  ```     @GetMapping(""/items/{id}"")     public String itemPage(Model model, @PathVariable long id) {         model.addAttribute(""item"",items.getItem(id));         return ""itemPage""; //""itemPage"" is a template     } ``` Given a template (itemPage.html) which loads resources from /assets, located at ../static: ``` (...)                (...) ``` When invoking this method, the browser 'thinks' assets are located at /items/assets, where 'items' is just part of the mapping but not a real directory, making that: ![image](https://user-images.githubusercontent.com/52781415/159376815-b12b0f72-b365-42d2-ac1e-11f39ad46c58.png)  Instead of requesting just for the resources located at '/assets'. Hence, the browser is not loading properly the assets.","closed","for: stackoverflow,","Carel3DS","2022-03-21T23:02:49Z","2022-03-22T07:05:59Z"
"","28721","Add support for records in BindingReflectionHintsRegistrar","Using `BindingReflectionHintsRegistrar` with records lead to this Jackson exception on native image runtime:  ``` Exception in thread ""main"" com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Failed to access RecordComponents of type `nativeplayground.R`         at com.fasterxml.jackson.databind.SerializerProvider.reportBadDefinition(SerializerProvider.java:1300)         at com.fasterxml.jackson.databind.SerializerProvider._createAndCacheUntypedSerializer(SerializerProvider.java:1447)         at com.fasterxml.jackson.databind.SerializerProvider.findValueSerializer(SerializerProvider.java:544)         at com.fasterxml.jackson.databind.SerializerProvider.findTypedValueSerializer(SerializerProvider.java:822)         at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:308)         at com.fasterxml.jackson.databind.ObjectMapper._writeValueAndClose(ObjectMapper.java:4568)         at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3821)         at nativeplayground.SerializeMain.main(SerializeMain.java:14) ```  For records, there has to be this in the reflect-config.json:  ```   {     ""name"": ""nativeplayground.R"",     ""allDeclaredMethods"": true   } ```  It would be nice if `BindingReflectionHintsRegistrar` would support records.","closed","theme: aot,","mhalbritter","2022-06-28T13:43:04Z","2022-06-30T10:10:26Z"
"","28157","Improve documentation for @EnabledIf and @DisabledIf test support","Users often confuse the `@EnabledIf` and `@DisabledIf` annotations from Spring and those with the same names from JUnit Jupiter 5.7.  We should therefore update the documentation for these annotations to help avoid confusion.","closed","type: documentation,","sbrannen","2022-03-10T18:21:37Z","2022-03-10T18:29:19Z"
"","28503","Support coroutines suspending in @HttpExchange interface","Usage example:  ```kotlin interface SuspendService {  	@GetExchange 	suspend fun execute()  } ```","open","in: web,","wonwoo","2022-05-23T04:31:39Z","2022-07-31T05:07:26Z"
"","28112","java.lang.* no longer imported by default in SpEL contexts","Upgraded from Spring Framework 5.3.15 to 5.3.16 (via Boot) and this expression  ```groovy T(Character).isUpperCase(c) ? 'uppercase' : 'lowercase' ```  now throws the exception  ``` org.springframework.expression.spel.SpelEvaluationException: EL1005E: Type cannot be found 'Character' 	at org.springframework.expression.spel.support.StandardTypeLocator.findType(StandardTypeLocator.java:117) 	at org.thymeleaf.spring5.expression.ThymeleafEvaluationContext$ThymeleafEvaluationContextACLTypeLocator.findType(ThymeleafEvaluationContext.java:193) 	at org.springframework.expression.spel.ExpressionState.findType(ExpressionState.java:155) 	at org.springframework.expression.spel.ast.TypeReference.getValueInternal(TypeReference.java:69) 	at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:55) 	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:91) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:188) 	at org.springframework.expression.spel.ast.Ternary.getValueInternal(Ternary.java:53) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) 	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:265) 	... 164 more ```  Changing it to `java.lang.Character` works again.  Possibly it's a Thymeleaf (3.0.14 -> 3.0.15) issue instead?","closed","for: external-project,","OrangeDog","2022-02-28T10:49:55Z","2022-02-28T13:21:29Z"
"","27910","`MissingServletRequestPartException` should extend `ServletRequestBindingException` directly","Unlike similar exceptions, [`MissingServletRequestPartException`](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/multipart/support/MissingServletRequestPartException.java) directly extends `ServletException`; whereas, the following extend `MissingRequestValueException` which extends `ServletRequestBindingException` which indirectly extends `ServletException`.  - `MissingServletRequestParameterException` - `MissingRequestHeaderException` - ...  How about changing it if there is no good reason? 🤔","closed","status: superseded,","heowc","2022-01-10T08:40:27Z","2022-02-07T08:56:10Z"
"","28496","Break package tangle between o.s.aot and o.s.core","Two hints registrar have been recently added that creates a cycle between those two packages. We should consider moving those, perhaps all the way up to `spring-context` as they aren't really useful without it.","closed","theme: aot,","snicoll","2022-05-20T12:07:00Z","2022-06-08T09:54:08Z"
"","28057","Improve SpringFactories to customize how arguments and instantiation failures are handled","Two commits that lay the groundwork for deprecating `loadFactoryNames`.  See #27954","closed","type: enhancement,","philwebb","2022-02-16T00:07:08Z","2022-03-15T19:53:09Z"
"","28818","ApiDiff task fails as it tries to download `spring-core-graalvm`","Trying to generate the API diff for M5 (against M4) leads to the following.  ``` ./gradlew apiDiff -PbaselineVersion=6.0.0-M4   > Task :spring-core-graalvm:apiDiff FAILED  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':spring-core-graalvm:apiDiff'. > Could not resolve all files for configuration ':detachedConfiguration8'.    > Could not find org.springframework:spring-core-graalvm:6.0.0-M4.      Searched in the following locations:        - https://repo.maven.apache.org/maven2/org/springframework/spring-core-graalvm/6.0.0-M4/spring-core-graalvm-6.0.0-M4.pom        - https://repo.spring.io/libs-spring-framework-build/org/springframework/spring-core-graalvm/6.0.0-M4/spring-core-graalvm-6.0.0-M4.pom        - https://repo.spring.io/milestone/org/springframework/spring-core-graalvm/6.0.0-M4/spring-core-graalvm-6.0.0-M4.pom      Required by:          project : ```","closed","type: task,","snicoll","2022-07-14T08:15:44Z","2022-07-28T09:03:14Z"
"","28056","Add braces to @Target declaration in @Component","To match format of `Repository`/`Service`/`Controller`.","closed","in: core,","NWuensche","2022-02-15T20:27:37Z","2022-02-25T18:24:23Z"
"","28265","add properties for allow/deny on ConfigurableWebBindingInitializer","to eventually implement them as configurable properties in WebProperties and into WebMvcAutoConfiguration and it's flux sibling if i can find it  https://github.com/spring-projects/spring-boot/issues/30490","closed","status: declined,","tubbynl","2022-03-31T12:25:38Z","2022-04-28T08:43:56Z"
"","28560","Lazily initialize DataSize.PATTERN","To avoid unnecessary eager initialization of `org.springframework.util.unit.DataSize.PATTERN`, we should initialize it lazily in the first invocation of `DataSize.parse(CharSequence, DataUnit)`.  This can be achieved by moving `PATTERN` to a `private static` nested class.  See https://github.com/oracle/graal/issues/4489 for details.","closed","type: enhancement,","sbrannen","2022-06-03T08:44:35Z","2022-06-03T13:21:43Z"
"","28164","Support for Spring WebSession lifecycle tracking","TL; DR; Add support for callbacks for tracking the lifecycle of a WebSession in WebSessionStore.   Foreword We had a use case to track journey of a WebSession. We wanted to track various aspects of it like when it was created, retrieved, saved, invalidated etc.  Problem  The session expires based on -   1. maxIdleTime limit reached, default is 30mins 2. maxSessions limit reached, default is 10000 3. invalidate was called  We wanted to distinguish the sessions which were removed due to inactivity for 30mins or maxSessions limit reached. Currently there as no such hooks for any of the methods defined in WebSession interface to track the same.","open","type: enhancement,","jakshay21","2022-03-11T14:26:56Z","2022-04-25T09:09:00Z"
"","28269","NotWritablePropertyException when attempting to declaratively configure ClassLoader properties","Till now my application is running fine with 5.2.19.RELEASE version but as soon as I update spring framework to 5.2.20.RELEASE I get error NotWritablePropertyException : Bean property 'classLoader' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?  Could you please look into this.","closed","in: core,","szwlhd","2022-04-01T09:58:23Z","2022-04-08T11:26:58Z"
"","28439","Add WebFlux equivalent of ResponseEntityExceptionHandler","This would be helpful to facilitate customization of error messages for all framework exceptions especially for RFC 7807 problem details, under #27052.","closed","type: enhancement,","rstoyanchev","2022-05-10T11:39:32Z","2022-07-13T10:00:21Z"
"","28897","Better error reporting for @Bean of factoryMethod from factoryBean that went through BeanPostProcessor","This would be even tougher to spot the error if the `BeanPostProcessor` instance is from other libraries.  12:43:19.439 [main] WARN `org.springframework.context.annotation.AnnotationConfigApplicationContext` - Exception encountered during context initialization - cancelling refresh attempt: `org.springframework.beans.factory.BeanCreationException`: Error creating bean with name 'taskExecutor' defined in `com.welcome.samples.junit.BeanPostProcessorComponentTest$CustomAsyncConfigurer`: Bean instantiation via factory method failed; nested exception is `org.springframework.beans.BeanInstantiationException`: Failed to instantiate [`java.util.concurrent.Executor`]: Illegal arguments to factory method 'getAsyncExecutor'; args: ; nested exception is `java.lang.IllegalArgumentException`: **object is not an instance of declaring class**   ```java class BeanPostProcessorComponentTest {      @Test     void endToEnd() {         AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();         ctx.register(CustomAsyncConfigurer.class, ProcessingAsyncConfigurerPostProcessor.class);         ctx.refresh();         ctx.close();     }               @Configuration     public static class CustomAsyncConfigurer implements AsyncConfigurer {                  @Bean(""taskExecutor"")         public Executor getAsyncExecutor() {             return new ConcurrentTaskExecutor();         }     }      public static class ProcessingAsyncConfigurerPostProcessor implements BeanPostProcessor {         public Object postProcessBeforeInitialization(Object bean, String beanName)                 throws BeansException {             if (bean instanceof AsyncConfigurer && !(bean instanceof FullyCustomAsyncConfigurer)) {                 return new FullyCustomAsyncConfigurer((AsyncConfigurer) bean);             }                          return bean;         }     }          public static class FullyCustomAsyncConfigurer extends AsyncConfigurerSupport {                  private AsyncConfigurer delegate;                  public FullyCustomAsyncConfigurer(AsyncConfigurer delegate) {             this.delegate = delegate;         }                  @Override         public Executor getAsyncExecutor() {             return new Executor() {                                  @Override                 public void execute(Runnable command) {                     FullyCustomAsyncConfigurer.this.delegate.getAsyncExecutor().execute(command);                 }             };         }                  @Override         public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {             return this.delegate.getAsyncUncaughtExceptionHandler();         }     }  }  ```","open","status: waiting-for-triage,","tombyong","2022-08-01T04:58:59Z","2022-08-01T05:00:45Z"
"","28619","Upgrade to Kotlin 1.7.0","This will means dropping (support for) cyclic annotation type parameters, see #28618.","closed","type: dependency-upgrade,","poutsma","2022-06-14T10:42:28Z","2022-06-14T15:22:03Z"
"","28403","Remove ""The"" in ""The BeanFactory"" title in Core AsciiDoc documentation","This title is cross-referenced in ""1.1. Introduction to the Spring IoC Container and Beans"". In this chapter, it would look cleaner if ""The BeanFactory"" was called ""BeanFactory"". Also, this title is the only one with the article ""The"" in the Core Technologies documentation.","closed","status: declined,","rossnico","2022-05-01T08:16:44Z","2022-05-11T15:21:18Z"
"","28344","Technology hints in exception messages","This question seems inappropriate for SO. The nested exceptions message utility exposes Java type information:  ``` I/O error on POST request for ""http://localhost:8080/api/blahblah"": Connection refused; nested exception is java.net.ConnectException: Connection refused ```  from, e.g.:  ``` org.springframework.web.client.ResourceAccessException: I/O error on POST request for ""http://localhost:8080/api/blahblah"": Connection refused; nested exception is java.net.ConnectException: Connection refused 	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:785) 	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:711) 	at org.springframework.web.client.RestTemplate.postForObject(RestTemplate.java:437) ```  If the message was just:  ``` I/O error on POST request for ""http://localhost:8080/api/blahblah"": Connection refused ``` this could be exposed to users without providing technology hints. The cause is captured with the stack-trace, so why expose the type information (""`java.net.ConnectException`"") in the `getMessage` content?   The work-around is easy enough it just means duplicating the messaging which is probably okay; it certainly is in my case. But this seems like general issue that should be fixed in the framework but before I submit a PR with the broad test changes, is there any interest in this type of PR?","open","status: waiting-for-triage,","JanStureNielsen","2022-04-14T19:11:58Z","2022-06-05T17:39:18Z"
"","27996","Modified SockJS close frame to prevent infinite loop for xhr-polling transport","This pull request is regarding the issue of infinite loop in SockJS library for xhr-polling transport.  When Spring sends close frame like **c[1000, ""Go Away!""]** then SockJS library is unable to parse it correctly and to recognise it as native close frame. Instead of that SockJS treats it as just plain text.  xhr.js file has next method to parse inbound text message:  ``` XhrReceiver.prototype._chunkHandler = function(status, text) {   debug('_chunkHandler', status);   if (status !== 200 || !text) {     return;   }    for (var idx = -1; ; this.bufferPosition += idx + 1) {     var buf = text.slice(this.bufferPosition);     idx = buf.indexOf('\n');     if (idx === -1) {       break;     }     var msg = buf.slice(0, idx);     if (msg) {       debug('message', msg);       this.emit('message', msg);     }   } }; ``` That method expects **\n** at the end of the SockJS text frame to parse it correctly.  But Spring Framework sends frame without that ending **\n** which causes infinite loop of opened xhr requests as response on plain text frame **c[1000, ""Go Away!""]**.  After this fix all works as expected and **c[1000, ""Go Away!""]** successfully routes to the **'c'** section of next switch ``` SockJS.prototype._transportMessage = function(msg) {   ...   switch (type) {     case 'a':       if (Array.isArray(payload)) {         payload.forEach(function(p) {           debug('message', self.transport, p);           self.dispatchEvent(new TransportMessageEvent(p));         });       }       break;     case 'm':       debug('message', this.transport, payload);       this.dispatchEvent(new TransportMessageEvent(payload));       break;     case 'c':       if (Array.isArray(payload) && payload.length === 2) {         this._close(payload[0], payload[1], true);       }       break;   } }; ```","closed","","zbykovskyi","2022-02-02T15:23:23Z","2022-02-15T09:03:24Z"
"","28000","Add formatting for SockJS close GoAway frame to prevent infinite loop for xhr-polling and xhr-streaming transport","This pull request is regarding the issue of infinite loop in SockJS library for xhr-polling and xhr-streaming transport.  When Spring sends unformatted frame **SockJsFrame.closeFrameGoAway()** without ending **\n**  like **c[1000, ""Go Away!""]** then SockJS library is unable to parse it correctly and to recognise it as native close frame. Instead of that SockJS treats it as just plain text.  **xhr.js** file has next method to parse inbound text message:  ```JavaScript XhrReceiver.prototype._chunkHandler = function(status, text) {   debug('_chunkHandler', status);   if (status !== 200 || !text) {     return;   }    for (var idx = -1; ; this.bufferPosition += idx + 1) {     var buf = text.slice(this.bufferPosition);     idx = buf.indexOf('\n');     if (idx === -1) {       break;     }     var msg = buf.slice(0, idx);     if (msg) {       debug('message', msg);       this.emit('message', msg);     }   } };  ```  That method expects **\n** at the end of the SockJS text frame.  But in case of **""Connection already closed (but not removed yet) for sessionId""** Spring Framework sends unformatted SockJsFrame.closeFrameGoAway() without ending **\n**. That leads to infinite loop at SockJS library because it is unable to parse that frame.  This fix is about to add formatting for **SockJsFrame.closeFrameGoAway()** before sending to the client.  Some reported issues: [https://github.com/sockjs/sockjs-client/issues/418](https://github.com/sockjs/sockjs-client/issues/418) [https://github.com/sockjs/sockjs-client/issues/308](https://github.com/sockjs/sockjs-client/issues/308) [https://stackoverflow.com/questions/37030416/sockjs-infinite-xhr-streaming-calls-after-reconnect/70957300#70957300](https://stackoverflow.com/questions/37030416/sockjs-infinite-xhr-streaming-calls-after-reconnect/70957300#70957300)","closed","type: bug,","zbykovskyi","2022-02-03T11:48:37Z","2022-02-14T20:52:36Z"
"","27992","Improve SimpleJdbcCall for Oracle database","This pull request improves SimpleJdbcCall when targeting the Oracle  database as follows:  - Improve support of Oracle PL/SQL packages for Spring JDBC: Oracle   database stored procedures or functions can be overloaded. Hence,   the possibility to find several matching signatures by just using   the schema name, catalog name and procedure/function name is real.   This PR adds columns data type checking to properly find the desired   stored procedure or function.  - Ease debugging for DBMS_ packages if SYS not specified: explicitly   checks the catalog name being used and if starting with DBMS_% and no   matching signature was found then report in the log it could be    useful to use SYS as the schema name","closed","","loiclefevre","2022-01-31T11:12:55Z","2022-02-01T10:04:38Z"
"","28019","Enhance conditional bean creation when using method overloading","This pull request closes the issue mentioned here: https://github.com/spring-projects/spring-framework/issues/22609  Short summary: A bean won't be created when it is being skipped by a condition for example when using `@ConditionalOnProperty` or `@ConditionalOnExpression` because the condition is evaluated to false. However a second bean with exactly the same name with different parameters may evaluate to true because the condition has met, so this bean should be created but that does not happen.  An example code snippet: ```java class Config {      @Bean     @ConditionalOnExpression(""${some-property-enabled} == true and ${some-different-property} == false"")     public ExampleBean baz() {         return new ExampleBean();     }      @Bean     @ConditionalOnExpression(""${some-property-enabled} == false and ${some-different-property} == true"")     public ExampleBean baz(Object foo) {         return new ExampleBean();     }  } ```  When `some-property-enabled` is false and some-different-property is true the second method should be called and the bean should be created, however this does not happen. The bean name is already in the to be skipped beans list.  The pull request contains the changes to reconsider a skipped bean when it encounters a new bean definition having a different condition. If it should not be skipped it will be created. The PR also takes into inheritance into consideration (for backwards compatibility, see https://github.com/spring-projects/spring-framework/blob/c263cbfbe486d7712b9e46b80ed151c1eda98c74/spring-context/src/test/java/org/springframework/context/annotation/ConfigurationClassWithConditionTests.java#L139)  In that specific use case the parent class defines a bean which should be created, however it is getting overridden by a subclass which defines a condition on the bean, so it will be created conditionally and may not even be created when it evaluates to false.  This PR uses a wrapper for the MethodMetadata as a helper class for resolving the inheritance with the condition on a subclass when it still needs to be skipped.  ### My use case In my use case I wanted to refactor my code base. I have the bean configuration below:  [github/mutual-tls-ssl/SSLConfig.java](https://github.com/Hakky54/mutual-tls-ssl/blob/ca34a84fc4d6cd62fc675ec148e52d1fedd800ff/client/src/main/java/nl/altindag/client/SSLConfig.java#L24)  ```java @Component public class SSLConfig {      @Bean     @Scope(""prototype"")     public SSLFactory sslFactory(             @Value(""${client.ssl.one-way-authentication-enabled:false}"") boolean oneWayAuthenticationEnabled,             @Value(""${client.ssl.two-way-authentication-enabled:false}"") boolean twoWayAuthenticationEnabled,             @Value(""${client.ssl.key-store:}"") String keyStorePath,             @Value(""${client.ssl.key-store-password:}"") char[] keyStorePassword,             @Value(""${client.ssl.trust-store:}"") String trustStorePath,             @Value(""${client.ssl.trust-store-password:}"") char[] trustStorePassword) {         SSLFactory sslFactory = null;          if (oneWayAuthenticationEnabled) {             sslFactory = SSLFactory.builder()                     .withTrustMaterial(trustStorePath, trustStorePassword)                     .withProtocols(""TLSv1.3"")                     .build();         }          if (twoWayAuthenticationEnabled) {             sslFactory = SSLFactory.builder()                     .withIdentityMaterial(keyStorePath, keyStorePassword)                     .withTrustMaterial(trustStorePath, trustStorePassword)                     .withProtocols(""TLSv1.3"")                     .build();         }          return sslFactory;     }  } ```  And I wanted to refactor it to the following snippet: ```java @Component public class SSLConfig {      @Bean     @Scope(""prototype"")     @ConditionalOnExpression(""${client.ssl.one-way-authentication-enabled} == true and ${client.ssl.two-way-authentication-enabled} == false"")     public SSLFactory sslFactory(@Value(""${client.ssl.trust-store:}"") String trustStorePath,                                  @Value(""${client.ssl.trust-store-password:}"") char[] trustStorePassword) {          return SSLFactory.builder()                 .withTrustMaterial(trustStorePath, trustStorePassword)                 .withProtocols(""TLSv1.3"")                 .build();     }       @Bean     @Scope(""prototype"")     @ConditionalOnExpression(""${client.ssl.two-way-authentication-enabled} == true and ${client.ssl.one-way-authentication-enabled} == false"")     public SSLFactory sslFactory(@Value(""${client.ssl.key-store:}"") String keyStorePath,                                  @Value(""${client.ssl.key-store-password:}"") char[] keyStorePassword,                                  @Value(""${client.ssl.trust-store:}"") String trustStorePath,                                  @Value(""${client.ssl.trust-store-password:}"") char[] trustStorePassword) {          return SSLFactory.builder()                 .withIdentityMaterial(keyStorePath, keyStorePassword)                 .withTrustMaterial(trustStorePath, trustStorePassword)                 .withProtocols(""TLSv1.3"")                 .build();     }  } ```  However it fails. But with the code changes of the Pull request it will create one of the beans when the conditions is true.","closed","in: core,","Hakky54","2022-02-08T11:55:17Z","2022-02-15T14:50:23Z"
"","28731","Upgrade to Gradle Enterprise Conventions 0.0.10","This PR upgrades to Gradle Enterprise Conventions 0.0.10.","closed","type: task,","izeye","2022-06-30T04:28:51Z","2022-06-30T13:08:07Z"
"","28912","Upgrade to Dokka Gradle plugin 1.7.10","This PR upgrades to Dokka Gradle plugin 1.7.10.","open","status: waiting-for-triage,","izeye","2022-08-02T12:27:19Z","2022-08-02T12:30:49Z"
"","28691","Upgrade to Dokka Gradle plugin 1.7.0","This PR upgrades to Dokka Gradle plugin 1.7.0.","closed","status: declined,","izeye","2022-06-23T15:24:36Z","2022-06-24T11:27:14Z"
"","28097","Update Javadoc since for BeanDefinitionValueResolver","This PR updates the Javadoc `@since` tag for the `BeanDefinitionValueResolver`.  See gh-28029","closed","status: invalid,","izeye","2022-02-23T03:37:30Z","2022-07-29T16:12:43Z"
"","28349","Switch to Yaml 1.2 with snakeyaml-engine","This PR replace snakeyaml with snakeyaml-engine in order to support YAML 1.2 Version 1.2 solves among others Norway problem https://hitchdev.com/strictyaml/why/implicit-typing-removed, mentioned in https://github.com/spring-projects/spring-boot/issues/17113  Please note that to mitigate the Norway problem, Spring Boot team decided to use apostrophe in every documentation snippet: https://github.com/spring-projects/spring-boot/issues/28709/. That decreases documenation readability.  The following page compares versions 1.1 and 1.2: https://yaml.readthedocs.io/en/latest/pyyaml.html  I drop off 'supportedTypes' support. The feature was added in https://github.com/spring-projects/spring-framework/issues/25152. I asked question for purpose, but I didn't get answer.  I decide to drop because: 1. Supported types are not directly provided by snakeyaml-engine 2. Clients - for example Spring Boot OriginTrackedYamlLoader - still may modify yaml setup and implement supported types 3. Supported types are not documented 4. I think that supported types is wrong idea. Parsing YAML should be simple, conversion should be implemented in application code.","open","status: waiting-for-triage,","michaldo","2022-04-15T19:34:42Z","2022-06-09T01:43:22Z"
"","28779","Improve `CookieLocaleResolver`","This PR provides two commits that improve `CookieLocaleResolver`, as a follow-up on #27609:  1. **Simplify creation of `CookieLocaleResolver` with custom cookie name**  At present, creating `CookieLocaleResolver` with custom cookie name requires creating an instance using the default constructor and then using setter to configure the desired cookie name.  This commit introduces `CookieLocaleResolver` constructor that accepts cookie name thus allowing for a simpler creation of an instance with the desired cookie name.  2. **Refactor `CookieLocaleResolver`**  At present, `CookieLocaleResolver` extends `CookieGenerator` instead of `AbstractLocale(Context)Resolver` like other `LocaleResolver` implementations. This means it duplicates some common aspects of `LocaleResolver` hierarchy while also exposing some `CookieGenerator` operations, such as `#addCookie` and `#removeCookie`.  Additionally, `CookieGenerator`'s support for writing cookies is based on Servlet support which at current baseline doesn't support SameSite directive.  This commit refactors `CookieLocaleResolver` to make it extend `AbstractLocaleContextResolver` and also replaces `CookieGenerator`'s cookie writing support with newer and more capable `ResponseCookie`.","open","status: waiting-for-triage,","vpavic","2022-07-08T18:59:34Z","2022-07-08T19:11:37Z"
"","27958","Polish tests in spring-web","This PR polishes trivial things in tests in spring-web.  Signed-off-by: shirohoo","closed","type: task,","shirohoo","2022-01-20T05:08:14Z","2022-01-21T01:14:05Z"
"","27997","Polish codes in spring-webmvc","This PR polishes trivial things in `DispatcherServlet` in spring-webmvc.","closed","status: declined,","shirohoo","2022-02-03T06:47:35Z","2022-02-07T12:27:38Z"
"","28744","Polish","This PR polishes a bit.","closed","type: task,","izeye","2022-07-02T05:42:15Z","2022-07-02T07:51:34Z"
"","28224","Fix property binding issue for spring beans when default value is null","This PR introduced a bug an does not allow us to upgrade passed 5.3.0: https://github.com/spring-projects/spring-framework/issues/25986 . Before, `AbstractNestablePropertyAccessor#processLocalProperty` threw `createNotWritablePropertyException`  when our class being deserialized did not have a setter on a property. This was then swallowed by `AbstractPropertyAccessor#setPropertyValues(org.springframework.beans.PropertyValues, boolean, boolean, boolean)` and binding of the next property was attempted. This is the wanted outcome. Now if this exception is not thrown (caught by the guard clause), we don't have default values on these fields so AbstractNestablePropertyAccessor#setDefaultValue throws an assertion which is not swallowed. Setting `ignoreInvalid` to false does cause `createNotWritablePropertyException` to be thrown, but it does not swallow the exception as before. This PR keeps the exact same functionality as now, but allows not having a default value for a property to be swallowed, in the same way it is in the other cases if desired. It also is a better way to handle the error and then throwing an assertion.","open","in: core,","dillonm79","2022-03-23T19:21:51Z","2022-04-05T15:35:43Z"
"","28238","Update copyright year of EvaluationTests","This PR fixes license year for `EvaluationTests`.  See beab8ab","closed","type: task,","izeye","2022-03-27T04:37:02Z","2022-03-27T08:12:05Z"
"","28100","Fix library name for JavaPoet in src/docs/dist/license.txt","This PR fixes library name for JavaPoet in `src/docs/dist/license.txt`.  This PR also updates Objenesis version in the file to align with [the version that Spring Framework is using](https://github.com/spring-projects/spring-framework/blob/main/spring-core/spring-core.gradle#L13).","closed","type: task,","izeye","2022-02-23T11:53:55Z","2022-02-24T10:38:25Z"
"","28914","Fix Javadoc since for new modules() and modulesToInstall()","This PR fixes Javadoc `@since` tags for the new `modules(Consumer)` and `modulesToInstall(Consumer)`.  See gh-28633","closed","type: task,","izeye","2022-08-02T13:48:33Z","2022-08-02T14:18:12Z"
"","28010","Fix Javadoc since for AopProxyUtils.isLambda()","This PR fixes Javadoc `@since` tag for `AopProxyUtils.isLambda()`.  See gh-27971","closed","type: task,","izeye","2022-02-05T12:51:34Z","2022-02-05T14:01:06Z"
"","28370","Fix typo in reference docs regarding RequestMappingHandlerAdapter","This PR fix a typo in referece docs.  A list of `HttpMessageConverter`'s are registered as `this.messageConverters` in the constructor of `RequestMappingHandlerAdapter` (not `RequestMethodHandlerAdapter`). https://github.com/spring-projects/spring-framework/blob/be7fa3aaa879cfb44fc976be7331caf5479a943f/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L203-L216","closed","type: task,","gorisanson","2022-04-23T08:04:26Z","2022-05-05T14:33:11Z"
"","28365","Upgrade to Reactor 2022.0.0-M2","This PR ensures that Spring Framework uses newly released M2 milestone of Reactor `2022.0.0`:  - Reactor-Core `3.5.0-M2`  - Reactor-Netty `1.1.0-M2`  This should be the version that the upcoming 6.0.0-M4 release should depend on.","closed","type: dependency-upgrade,","simonbasle","2022-04-21T13:36:34Z","2022-05-09T15:43:16Z"
"","28648","Improve `LoggingCacheErrorHandler`","This PR contains 2 commits with some improvements to `LoggingCacheErrorHandler`:  1. Simplify creation of `LoggingCacheErrorHandler` with logged stacktrace: At present, creating `LoggingCacheErrorHandler` that logs stacktrace also requires supplying the logger to be used. This might be inconvenient for some users, as it requires usage of Commons Logging API. This commit simplifies creation of such as `LoggingCacheErrorHandler` instance by adding a constructor that only accepts a boolean flag indicating whether to log stacktrace.  2. Defer log message creation in `LoggingCacheErrorHandler`: At present, `LoggingCacheErrorHandler` creates log message eagerly and does not verify whether warn level is enabled at all for the used logger. This commit ensures that log message creation is deferred until it is about to be logged.  The first commit could maybe be update to deprecate the existing constructor that takes `org.apache.commons.logging.Log` and replace it with the one that takes `String` representing logger name as that way Commons Logging dependency wouldn't leak out at all. But I'd leave that decision to whoever reviews this PR.","closed","status: superseded,","vpavic","2022-06-17T14:57:35Z","2022-06-21T12:51:33Z"
"","28771","Use MediaType.APPLICATION_FORM_URLENCODED_VALUE constant","This PR changes to use `MediaType.APPLICATION_FORM_URLENCODED_VALUE` where possible.","closed","type: task,","izeye","2022-07-07T12:59:11Z","2022-07-29T13:45:33Z"
"","28658","Add log level guards in RuntimeHintsBeanFactoryInitializationAotProcessor","This PR adds log level guards in `RuntimeHintsBeanFactoryInitializationAotProcessor`.","closed","type: task,","izeye","2022-06-19T23:31:10Z","2022-06-20T06:43:25Z"
"","28465","Add level guards for trace logging in `SpringFactoriesLoaderRuntimeHintsRegistrar`","This PR adds level guards for trace logging in `SpringFactoriesLoaderRuntimeHintsRegistrar`.","closed","type: enhancement,","izeye","2022-05-15T23:42:42Z","2022-05-16T07:22:09Z"
"","28369","Add Javadoc since tags for GraphQL constants","This PR adds Javadoc `@since` tag for GraphQL constants.  See gh-28271","closed","type: documentation,","izeye","2022-04-23T05:59:03Z","2022-05-11T07:39:21Z"
"","28171","Add Javadoc since for GenericApplicationContext.refreshForAotProcessing()","This PR adds Javadoc `@since` tag for `GenericApplicationContext.refreshForAotProcessing()`.","closed","type: task,","izeye","2022-03-12T08:00:27Z","2022-03-12T11:17:40Z"
"","28738","Add Javadoc `@since` tag for `CannotGetJdbcConnectionException(String, IllegalStateException)`","This PR adds Javadoc `@since` tag for `CannotGetJdbcConnectionException(String, IllegalStateException)`.  See gh-28669","closed","type: task,","izeye","2022-06-30T15:37:56Z","2022-07-01T08:59:02Z"
"","28217","Add Javadoc since for BeanDefinitionValueResolver.resolveInnerBean()","This PR adds Javadoc `@since` tag for `BeanDefinitionValueResolver.resolveInnerBean()`.","closed","type: documentation,","izeye","2022-03-22T14:17:14Z","2022-03-22T23:37:03Z"
"","28449","Add Javadoc since tag for RootBeanDefinition(ResolvableType) constructor","This PR adds a Javadoc `@since` tag for the `RootBeanDefinition(ResolvableType)` constructor.  This PR also removes redundant `super()` invocations.  See gh-28418","closed","in: core,","izeye","2022-05-11T13:42:11Z","2022-05-11T14:48:58Z"
"","28631","Add `MockMvcRequestBuilders.multipart(HttpMethod, String, Object...)`","This PR adds `MockMvcRequestBuilders.multipart(HttpMethod, String, Object...)` that is similar to `MockMvcRequestBuilders.multipart(HttpMethod, URI)` that has been added in #28545.","closed","type: enhancement,","izeye","2022-06-15T11:32:45Z","2022-06-15T14:01:01Z"
"","28634","Add `MockMvc.multipart()` Kotlin extensions with `HttpMethod`","This PR adds `MockMvc.multipart()` Kotlin extensions with `HttpMethod` for methods added in #28545 and #28631.","open","in: kotlin,","izeye","2022-06-15T14:10:22Z","2022-07-31T05:11:31Z"
"","28865","Revisit BeanRegistrationAotContribution#ofBeanRegistrationCodeFragmentsCustomizer","This method is used to customize some code fragments and is a bit mouthful. It would be nice to revisit the API and provide something more straightforward.","open","theme: aot,","snicoll","2022-07-25T08:10:06Z","2022-07-25T08:10:06Z"
"","28049","AsyncRestTemplate logging too verbose","This log is really too verbose, not all 4xx are error conditions, many REST apis will return perfectly expected 4xx (eg: checking if a given resource exists) and yielding a warning is too much:  ```java         private void handleResponseError(HttpMethod method, URI url, ClientHttpResponse response) throws IOException {                 if (logger.isWarnEnabled()) {                         try {                                 logger.warn(""Async "" + method.name() + "" request for \"""" + url + ""\"" resulted in "" +                                                 response.getRawStatusCode() + "" ("" + response.getStatusText() + ""); invoking error handler"");                         }                         catch (IOException ex) {                                 // ignore                         }                 }                 getErrorHandler().handleError(url, method, response);         } ```  I'm aware AsyncRestTemplate is deprecated and gone from 6.0, so this only affects 5.3.x and older... and I'm also on the way to remove it from my code, but we still have a significant amount of code using it and this issue has bothered us forever. As it's trivial to fix, I decided to log it here just in case you want to consider it.","closed","type: enhancement,","flozano","2022-02-14T22:30:12Z","2022-02-28T17:06:08Z"
"","28024","MediaType parameters in the ""consumes"" condition of `@RequestMapping` are not considered for matching","This issue was opened based on the discussion in #27999.  Given the following controller: ```kotlin @RestController @RequestMapping(""/hal-documents"") class MyController {     @PostMapping(         consumes = [""""""application/hal+json;profile=""my-resource-v1""""""""],         produces = [""""""application/hal+json;profile=""my-resource-v1""""""""]     )     fun postVersion1(@RequestBody request : String) = ""version-1""      @PostMapping(         consumes = [""""""application/hal+json;profile=""my-resource-v2""""""""],         produces = [""""""application/hal+json;profile=""my-resource-v2""""""""]     )     fun postVersion2(@RequestBody request : String) = ""version-2""; } ``` A request that provides a request body with the content type `application/hal+json;profile=""my-resource-v2""` is being routed to `postVersion1` but should be routed to `postVersion2`.  Even worse, if the `consumes` media type only differs in media type parameters and the handler methods can't be ranked by `produces` an `Ambiguous handler methods mapped for ...` error will be thrown leading to a 500er.   Example  Controller:  ```kotlin @RestController @RequestMapping(""/hal-documents"") class MyController {     @PostMapping(         consumes = [""""""application/hal+json;profile=""my-resource-v1""""""""]     )     fun postVersion1(@RequestBody request : String) = ""version-1""      @PostMapping(         consumes = [""""""application/hal+json;profile=""my-resource-v2""""""""]     )     fun postVersion2(@RequestBody request : String) = ""version-2""; } ``` Request: ```http POST http://localhost:8080/hal-documents Content-Type: application/hal+json;profile=""my-resource-v2""  {   ""my content"" : ""blub"" } ``` Response: ```http HTTP/1.1 500  Content-Type: application/json Transfer-Encoding: chunked Date: Thu, 10 Feb 2022 06:51:58 GMT Connection: close  {   ""timestamp"": ""2022-02-10T06:51:58.921+00:00"",   ""status"": 500,   ""error"": ""Internal Server Error"",   ""trace"": ""java.lang.IllegalStateException: Ambiguous handler methods mapped for '/hal-documents': {...}"",   ""path"": ""/hal-documents"" } ```    Looking into the code, it seems like `consumes` and `produces` are treated differently in `ProducesRequestCondition` and `ConsumesRequestCondition` when it comes to media type parameters.  **Affects:** 5.3.15","closed","type: enhancement,","thake","2022-02-10T07:13:18Z","2022-05-11T16:56:15Z"
"","28732","Open GraalVM internals to the ConstantFieldFeature","This is needed as GraalVM 22.2 enabled the module system when building native-images and all plugins have to participate in it.  Fixes this exception:  ``` Fatal error: java.lang.IllegalAccessError: class org.springframework.aot.graalvm.ConstantFieldFeature (in unnamed module @0x60f2e150) cannot access class com.oracle.svm.hosted.FeatureImpl$DuringSetupAccessImpl (in module org.graalvm.nativeimage.builder) because module org.graalvm.nativeimage.builder does not export com.oracle.svm.hosted to unnamed module @0x60f2e150         at org.springframework.aot.graalvm.ConstantFieldFeature.duringSetup(ConstantFieldFeature.java:37)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.lambda$setupNativeImage$16(NativeImageGenerator.java:899)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.FeatureHandler.forEachFeature(FeatureHandler.java:78)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.setupNativeImage(NativeImageGenerator.java:899)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.doRun(NativeImageGenerator.java:561)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGenerator.run(NativeImageGenerator.java:521)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGeneratorRunner.buildImage(NativeImageGeneratorRunner.java:407)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGeneratorRunner.build(NativeImageGeneratorRunner.java:585)         at org.graalvm.nativeimage.builder/com.oracle.svm.hosted.NativeImageGeneratorRunner.main(NativeImageGeneratorRunner.java:128) ```","closed","theme: aot,","mhalbritter","2022-06-30T07:41:44Z","2022-06-30T08:10:36Z"
"","28018","@Value annotation should be able to inject List from YAML properties [SPR-11759]","This is basically a duplicate of https://github.com/spring-projects/spring-framework/issues/16381, but the original issue was bulk closed.  Yaml file   ```yaml foobar:     ignoredUserIds:     - 57016311     - 22588218 ```  Class     ```java public class Foobar {     @Value(""${foobar.ignoredUserIds}"")     List ignoredUserIds; } ```   Error   ```java Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: java.util.List foobar.Foobar.ignoredUserIds; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'foobar.ignoredUserIds' in string value ""${foobar.ignoredUserIds}"" ```","closed","status: duplicate,","sergeykad","2022-02-08T09:33:25Z","2022-02-08T10:01:35Z"
"","28301","Fix expectations in MockMvc Kotlin documentation","This is a test against a generic PUT endpoint. The `.andExpect { status().isOk }` assertion always passes, regardless of the actual result status, while `.andExpect( status().isOk )` works as expected. I suspect this is a bug?  We're using spring-boot-starter-parent:2.6.6 on Kotlin 1.6.10 on a JDK 11.  ``` import org.junit.jupiter.api.Test import org.junit.jupiter.api.TestInstance import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc import org.springframework.boot.test.context.SpringBootTest import org.springframework.http.MediaType.APPLICATION_JSON import org.springframework.test.context.ActiveProfiles import org.springframework.test.web.servlet.MockMvc import org.springframework.test.web.servlet.request.MockMvcRequestBuilders import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status  @SpringBootTest @AutoConfigureMockMvc @TestInstance(TestInstance.Lifecycle.PER_CLASS) class Test {      @Autowired     lateinit var mockMvc: MockMvc      @Test     fun `should reject invalid payload`() {          mockMvc.perform( MockMvcRequestBuilders.put(""/analyses/297e2c6c6a26a2ba016a27bd5f977f74"")             .contentType(APPLICATION_JSON)             .content(""invalid"")         )             .andExpect { status().isOk } // does not work             .andExpect( status().isOk ) // works     } } ```","closed","in: kotlin,","MrBuddyCasino","2022-04-07T14:00:47Z","2022-07-13T08:14:52Z"
"","27925","NamedParameterUtils has broken square brackets handling","This is a simple unit test which passes with the `5.3.x` but fails with the current `6.0` milestones:  ```java 	@Test 	void namedParamMapReference() { 		String insert = ""insert into foos (id) values (:headers[id])""; 		class Foo {  			final Map headers = new HashMap<>();  			public Foo() { 				this.headers.put(""id"", UUID.randomUUID()); 			}  			public Map getHeaders() { 				return this.headers; 			}  		}  		Foo foo = new Foo();  		Object[] params = 				NamedParameterUtils.buildValueArray(NamedParameterUtils.parseSqlStatement(insert), 						new BeanPropertySqlParameterSource(foo), null);  		assertThat(params[0]).isEqualTo(foo.getHeaders().get(""id"")); 	} ```  The point is that we may have a reference for the value from nested `Map` property.  The typical use case is messaging, for example with Spring Integration, where a `Message` in the request is used as a source for parameter values.  We even advertise this in the docs: https://docs.spring.io/spring-integration/docs/current/reference/html/jdbc.html#jdbc-outbound-channel-adapter.  I suspect that the cause for breaking change is this fix: https://github.com/spring-projects/spring-framework/commit/64b6beed5b135344b6f0d15bc50bf4c08c2ab9bb. Or the previous one: https://github.com/spring-projects/spring-framework/commit/86eda279c82b79c7888558e7a2524db44c7ee108.  Thanks","open","type: regression,","artembilan","2022-01-12T15:49:11Z","2022-07-08T15:10:08Z"
"","28142","Ability to differentiate different causes for WebInputException","This is a request for the ability to generate a message stating that a WebFlux controller request body (or other request component) is missing, without exposing potentially sensitive implementation details in the error message. By doing this, it would remove the need for implementing a custom handler for validation where Spring provides messages that may fail organisational governance.  If we write a controller such as the following:  ```java @RestController @Validated public class TestController {   @PostMapping(""/foo/{bar}"")   @ResponseStatus(ACCEPTED)   public Mono fooBar(@PathVariable String bar, @RequestBody Body body) {     ...   } } ```  ...the implementation for a missing request body appears to be currently defined in [AbstractMessageReaderArgumentResolver](https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/AbstractMessageReaderArgumentResolver.java#L229):  ```java 	private ServerWebInputException handleMissingBody(MethodParameter parameter) { 		String paramInfo = parameter.getExecutable().toGenericString(); 		return new ServerWebInputException(""Request body is missing: "" + paramInfo, parameter); 	} ```  The error message here cannot be presented to the consumer of the API on systems where governance prevents the exposure of the underlying implementation technology (this would fail penetration testing, for example). The reason for this is that the error message with the concatenated parameter info will render to something like:  ``` Request body is missing: public reactor.core.publisher.Mono com.mycompany.TestController.fooBar(java.lang.String, com.mycompany.Body) ```  This can potentially expose information allowing the inference of the underlying JDK or Spring Boot version by observing the names of the parameters and method in the underlying error, which may enable malicious actors to ""comb"" an API and determine if certain exploits may exist.  The issue arises that while we can override this exception with a custom exception handler, this then involves writing a significant amount of boilerplate to cater for parsing every potential binding annotation, and then extracting information such as the name of the parameter (in the case of headers), or the request body. The current API does not provide a simple way of determining that the request body is the part that is missing in this case.  If we instead use Spring Validation, and use `@RequestBody(required = false) @Valid @NotNull`, the issue will instead arise that a ConstraintViolationException is raised instead of a WebExchangeBindingException, which then requires two almost identical sets of exception handlers to achieve the same consistent validation error handling. This appears to be due to `validate()` not being called on the body in `AbstractMessageReaderArgumentResolver.java` when the body is determined to be missing.  If we omit the message altogether, it leaves a response to the consumer that is not helpful for diagnosing the issue with the request. For example:  ```java {   ""status"": 400,   ""message"": ""null"" } ```  Is there a workaround for this, or is this something that could be potentially tweaked? Providing consistent validation using the Spring Validation API with WebFlux is somewhat painful at the moment because of this, and it leads to code that can be somewhat difficult to maintain when it caters for multiple edge cases.  An ideal scenario would be where we could obtain a string ""type"" of the parameter in question that failed validation (e.g. `""header""`, `""body""`, `""pathVariable""`, etc, and then a simplified message such as `""Request body is required""` that can be presented back to the consumer of the API.  Any help or suggestions would be greatly appreciated!  Thanks","closed","type: enhancement,","ascopes","2022-03-07T11:38:23Z","2022-07-13T15:38:06Z"
"","28002","Add inverse of the @DependsOn annotation","This is a new feature request to add a new annotation (and capability) to the core Spring Framework that has the opposite effect of the `@DependsOn` annotation ([Javadoc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html)).  With Spring's `@DependsOn` annotation users can say bean B depends on bean A, like so:  ````java @Configuration class MyApplicationConfiguration {    @Bean(""B"")   @DependsOn(""A"")   B bBean() {     return new B();   }    @Bean(""A"")   A aBean(..) {     return new A();   } } ````  The new, inverse annotation, which I have dubbed `@DependencyOf`, exists in the _**Spring Test for Apache Geode**_ (STDG) project; see [here](https://github.com/spring-projects/spring-test-data-geode/blob/0.0.28/spring-data-geode-test/src/main/java/org/springframework/data/gemfire/tests/extensions/spring/context/annotation/DependencyOf.java).  The equivalent effect using `@DependencyOf` is the following configuration:  ````java @Configuration class MyApplicationConfiguration {    @Bean(""A"")   @DependencyOf(""B"")   A aBean(..) {     return new A();   }    @Bean(""B"")   B bBean() {     return new B();   } } ````  While this is not very useful in this particular configuration arrangement, it is merely to demonstrate the effect.  So, when would `@DependencyOf` be useful?  The need for this new `@DependencyOf` annotation came about in testing.  I use the STDG project to consistently and reliably test across _Spring Data for Apache Geode_ (SDG), _Spring Session for Apache Geode_ (SSDG) and _Spring Boot for Apache Geode_ (SBDG).  In certain [test] cases, I need beans / components from SDG, SSDG or SBDG to depend on STDG components for testing purposes. Clearly SDG, SSDG and SBDG production components cannot be made to ""depend on"" STDG test components only used during test runtime.  You can see an example of the `@DependencyOf` annotation in action in this STDG [test class](https://github.com/spring-projects/spring-test-data-geode/blob/0.0.28/spring-data-geode-test/src/test/java/org/springframework/data/gemfire/tests/CacheLifecycleListenerIntegrationTests.java).  In a nutshell, a `TestCacheLifecycleListener` [component](https://github.com/spring-projects/spring-test-data-geode/blob/0.0.28/spring-data-geode-test/src/test/java/org/springframework/data/gemfire/tests/CacheLifecycleListenerIntegrationTests.java#L120-L134) and [bean](https://github.com/spring-projects/spring-test-data-geode/blob/0.0.28/spring-data-geode-test/src/test/java/org/springframework/data/gemfire/tests/CacheLifecycleListenerIntegrationTests.java#L114-L117) is a [""_dependency of_](https://github.com/spring-projects/spring-test-data-geode/blob/0.0.28/spring-data-geode-test/src/test/java/org/springframework/data/gemfire/tests/CacheLifecycleListenerIntegrationTests.java#L121)"" the ""_gemfireCache_"" bean which is created in SDG by the declaration of the `ClientCacheApplication` annotation in the configuration ([here](https://github.com/spring-projects/spring-test-data-geode/blob/0.0.28/spring-data-geode-test/src/test/java/org/springframework/data/gemfire/tests/CacheLifecycleListenerIntegrationTests.java#L111)).   > NOTE: The SDG `@ClientCacheApplication` annotation responsible for creating a `GemFireCache` bean is also meta-annotated with Spring's `@Configuration` annotation making the `TestConfiguration` class a proper Spring JavaConfig class.  Of course, 1 way this might be accomplished is by having STDG components implement the `[Smart]Lifecycle` interface.  However, this is problematic for 2 reasons 1) SDG, SSDG or SBDG also has `SmartLifecycle` implementations with a potentially higher precedence and 2) the precedence of `SmartLifecycle` components in SDG, SSDG and SBDG could change in the future and become higher.  There are other situations to consider.  There are of course hooks in the _Spring_ `TestContext` framework where it might be possible to perform certain initialization in `TestExecutionListeners` and what not.  I have considered multiple angles here.  Yet another implementation would be to use a `BeanFactoryPostProcessor` to change the dependencies of the SDG, SSDG and SBDG bean definitions.  And, in fact, this is exactly how the `@DependencyOf` annotation configuration is implemented, by using a `BeanFactoryPostProcessor` to modify the (would be) dependent beans / components from upstream frameworks.  See [here](https://github.com/spring-projects/spring-test-data-geode/blob/0.0.28/spring-data-geode-test/src/main/java/org/springframework/data/gemfire/tests/extensions/spring/context/annotation/DependencyOfBeanFactoryPostProcessor.java).  The `@DependencyOf` annotation is flexible and easy to add to any (downstream) project that might require beans to get initialized before the upstream framework initializes certain beans.  I am proposing this additional, complimentary annotation as an addition to the core Spring Framework if the team feels this would have value (merit) beyond the use cases I identified. I would be happy to work with interested parties on its integration as needed.","closed","type: enhancement,","jxblum","2022-02-03T19:37:44Z","2022-04-15T18:36:37Z"
"","28001","Introduce a RefreshableAnnotationConfigApplicationContext","This is a new feature request in the core Spring Framework to consider adding a ""_**refreshable**_"" `AnnotationConfigApplicationContext`.  To my knowledge, the only `ApplicationContext` implementations that allow refresh capabilities are XML configuration based `ApplicationContexts` and Web-based `ApplicationContexts`, as indicated in the [_Javadoc_](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/AbstractRefreshableConfigApplicationContext.html) for `AbstractRefreshableConfigApplicationContext`.  The idea and motivation originated from a user of _**Spring Boot for Apache Geode**_ (SBDG) to be able to refresh an `AnnotationConfigApplicationContext` in his use case. As such, I took it upon myself to create such an `ApplicationContext` implementation (prototype), and can be seen [here](https://github.com/spring-projects/spring-boot-data-geode/blob/1.6.3/spring-geode/src/main/java/org/springframework/geode/context/annotation/RefreshableAnnotationConfigApplicationContext.java).  I have written a [single test case](https://github.com/spring-projects/spring-boot-data-geode/blob/1.6.3/spring-geode/src/test/java/org/springframework/geode/context/annotation/RefreshableAnnotationConfigApplicationContextIntegrationTests.java) to prove it works, or rather that it is at least possible.  Certainly, much more thought and testing would be required to make this a full fledged feature of the core Spring Framework.  But, I thought it was an interesting idea and perhaps a useful feature for the core Spring Framework overall.  In fact, I was bit surprised that this capability didn't already exist or that another user had not requested it, already. Perhaps someone has and I missed it, or even this has been considered before, but I did not find anything.  Anyway, happy to work with interested parties to integrate this new `RefreshableAnnotationConfigApplicationContext` into the core Spring Framework if the team feels this would be a nice add and would benefit our users.","closed","in: core,","jxblum","2022-02-03T18:58:17Z","2022-02-15T15:04:11Z"
"","28875","Try to remove generic on BeanInstanceSupplier","This is a follow-up of what we've discovered as part of #28748  If a `BeanDefinition` has a `ResolvableType` that contains a generic we'll generate code for the raw class. Getting generics right is going to be quite hard so we're wondering if we shouldn't attempt to make it less constrained. Removing the generic and creating the `BeanInstanceSupplier` in the main method would be a first good step.   The instance-specific method (if any) could then take care of the bean instantiation and any post processing that should apply, if necessary.","open","theme: aot,","snicoll","2022-07-26T12:59:51Z","2022-07-26T12:59:51Z"
"","28761","Remove convention-based annotation attribute override support","This is a follow up to #28760.","open","type: enhancement,","sbrannen","2022-07-05T13:51:36Z","2022-07-05T13:51:36Z"
"","28672","Revise internals of LoggingCacheErrorHandler","This is a follow up to #28670 and supersedes #28648.  Since `LoggingCacheErrorHandler` was only recently introduced in `5.3.16`, we have decided to completely revise its internals (`protected` API) in `5.3.x` while retaining the current `public` API. See comments in #28648 for details.","closed","type: enhancement,","sbrannen","2022-06-21T12:49:45Z","2022-06-21T14:22:35Z"
"","28756","Trim string input in Converters where whitespace is irrelevant","This is a follow up to #28643.","closed","type: enhancement,","sbrannen","2022-07-04T17:17:13Z","2022-07-05T12:00:32Z"
"","28755","Trim string input in PropertyEditors where whitespace is irrelevant","This is a follow up to #28643.","closed","type: enhancement,","sbrannen","2022-07-04T17:16:14Z","2022-07-04T17:37:15Z"
"","28787","Upgrade client support to R2DBC 1.0","This is a follow up to #28059.  Since R2DBC 1.0 has been released, we should upgrade and ensure compatibility with 1.0 for Spring Framework 6.0.  For example, `io.r2dbc.spi.Result.getRowsUpdated()` returned `Publisher` in 0.9 and apparently returns `Publisher` in 1.0.","closed","type: dependency-upgrade,","sbrannen","2022-07-11T16:37:46Z","2022-07-13T08:33:04Z"
"","27902","Upgrade spring-r2dbc's test dependency on the H2 database to 2.0.x","This is a follow up to #27870, since we cannot upgrade `spring-r2dbc`'s test dependency to H2 2.0 until https://github.com/r2dbc/r2dbc-h2/pull/204 is released.","closed","status: superseded,","sbrannen","2022-01-07T13:45:02Z","2022-02-05T14:07:54Z"
"","28386","Support to Create a Proxy From an Annotated HTTP Service Interface","This has been raised before, see #16747 and related (duplicate) issues, but was done under Spring Cloud instead, first as an [OpenFeign integration](https://github.com/spring-cloud/spring-cloud-openfeign) and more recently as a [Retrofit integration](https://github.com/spring-projects-experimental/spring-cloud-square).  The goal for this issue is first class support in the Spring Framework to create a client proxy from an annotated, HTTP service interface, since it is more generally applicable. Spring Cloud can then provide additional features around that. The same is also planned for RSocket with #24456.   Methods on such an HTTP service interface will support many of the same [method arguments](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments) as for server side handling with `@RequestMapping` methods, but narrowing the choice down to those arguments that apply to both client and server side use. On the client side, argument values are used to populate the request, while on the server side, argument values are extracted from the request.  Methods of the HTTP service interface will require a new annotation, similar in purpose to `@RequestMapping`, but to declare an HTTP exchange in a way that is neutral to client or server perspective.","closed","type: enhancement,","rstoyanchev","2022-04-26T17:03:42Z","2022-05-09T08:53:13Z"
"","28026","Add convenience factory method for ManagedList, ManagedSet and ManagedMap","This could be useful to create and initialize a collection in a single statement.  See https://github.com/spring-projects-experimental/spring-native/issues/1483","closed","type: enhancement,","snicoll","2022-02-10T11:36:30Z","2022-02-10T12:21:43Z"
"","28540","Undeprecate PathMatchConfigurer::isUseTrailingSlashMatch","This commit removes deprecation from `PathMatchConfigurer::isUseTrailingSlashMatch` that was accidentally introduced in 5225a574.","open","in: web,","vpavic","2022-05-30T10:08:52Z","2022-06-10T14:39:41Z"
"","28515","Support Kotlin suspending functions with @Scheduled","This commit provides a scheduled task to support coroutines, but I'm not sure how to do a full unit test","open","in: kotlin,","1004789224","2022-05-24T09:09:54Z","2022-05-30T12:23:38Z"
"","28870","Deprecate CookieGenerator","This commit deprecates `CookieGenerator` in favor of a more modern alternative in `ResponseCookie`.  ---  Ideally, all Framework generated cookies should be consistent is sense they use the same infrastructure for creating response cookies. `CookieGenerator` has only two usages that either have PRs to replace them with `ResponseCookie` (`CookieLocaleResolver`) or are about to be deprecated (`CookieThemeResolver`).  Related:  - https://github.com/spring-projects/spring-framework/pull/28779 - https://github.com/spring-projects/spring-framework/issues/28868","open","status: waiting-for-triage,","vpavic","2022-07-25T20:01:42Z","2022-07-25T20:05:47Z"
"","28531","WS: SimpMessagingTemplate.convertAndSend*(...) should allow for null payloads","This code will cause an exception to be thrown:  ```java SimpMessagingTemplate template = ...;  template.convertAndSendToUser(dest, currentUserId, null); // ,,-- payload param is null ```  There are many cases when you might want to send a WS message without a payload. E.g. ""account activated"" is received only by the same user who's account was just activated, so having a null/empty payload is completely reasonable since the client only cares that a message was sent to the `/user//activated` endpoint.  But passing `payload` as `null` causes the following exception:  ``` Cannot invoke ""Object.getClass()"" because ""payload"" is null     at org.springframework.messaging.converter.AbstractMessageConverter.canConvertTo(AbstractMessageConverter.java:233) ~[spring-messaging-5.3.6.jar:5.3.6]     at org.springframework.messaging.converter.AbstractMessageConverter.toMessage(AbstractMessageConverter.java:197) ~[spring-messaging-5.3.6.jar:5.3.6]     at org.springframework.messaging.converter.CompositeMessageConverter.toMessage(CompositeMessageConverter.java:96) ~[spring-messaging-5.3.6.jar:5.3.6]     at org.springframework.messaging.core.AbstractMessageSendingTemplate.doConvert(AbstractMessageSendingTemplate.java:181) ~[spring-messaging-5.3.6.jar:5.3.6]     at org.springframework.messaging.core.AbstractMessageSendingTemplate.convertAndSend(AbstractMessageSendingTemplate.java:150) ~[spring-messaging-5.3.6.jar:5.3.6]     at org.springframework.messaging.simp.SimpMessagingTemplate.convertAndSendToUser(SimpMessagingTemplate.java:230) ~[spring-messaging-5.3.6.jar:5.3.6]     at org.springframework.messaging.simp.SimpMessagingTemplate.convertAndSendToUser(SimpMessagingTemplate.java:218) ~[spring-messaging-5.3.6.jar:5.3.6]     at org.springframework.messaging.simp.SimpMessagingTemplate.convertAndSendToUser(SimpMessagingTemplate.java:204) ~[spring-messaging-5.3.6.jar:5.3.6]     at com.teslagov.clarakm.net.ws.WebsocketMessageSender.lambda$sendToUsers$0(WebsocketMessageSender.java:67) ~[net-ws-1.0.4.jar:na]     at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183) ~[na:na]     at java.base/java.util.AbstractList$RandomAccessSpliterator.forEachRemaining(AbstractList.java:720) ~[na:na]     at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509) ~[na:na]     at java.base/java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:290) ~[na:na]     at java.base/java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:754) ~[na:na]     at java.base/java.util.concurrent.ForkJoinTask.doExec$$$capture(ForkJoinTask.java:373) ~[na:na]     at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java) ~[na:na]     at java.base/java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:686) ~[na:na]     at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateParallel(ForEachOps.java:159) ~[na:na]     at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateParallel(ForEachOps.java:173) ~[na:na]     at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:233) ~[na:na]     at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596) ~[na:na]     at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:765) ~[na:na] ```  I can get around this by sending an arbitrary object as the payload (e.g. `""""`), but this produces a ""code smell"".","open","status: waiting-for-triage,","JoshMcCullough","2022-05-27T01:49:26Z","2022-05-27T08:37:04Z"
"","28620","Introduce ResourcePatternHint#toRegex","This change is done for several reasons:  - Move the logic where it is documented.  - Test it with `ResourcePatternHintTests`.  - Allow `RuntimeHintsPredicates` to leverage this logic.","closed","theme: aot,","sdeleuze","2022-06-14T12:55:47Z","2022-06-14T13:08:17Z"
"","28458","Add resolver for request attributes for `@HttpExchange` methods","This can be used to provide hints to the `WebExchangeFilter` chain which is useful for security and other reasons.","closed","type: enhancement,","rstoyanchev","2022-05-13T14:11:19Z","2022-05-23T10:25:50Z"
"","28868","Deprecate support for themes","These days, theme switching is purely CSS based and does not really benefit from some special support on the server side. See [this guide](https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/) as an example.  With that in mind, Framework's [support for themes](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-themeresolver) is quite obsolete and 6.0 might be a good opportunity to deprecate it.","open","type: enhancement,","vpavic","2022-07-25T11:08:04Z","2022-07-25T13:24:29Z"
"","28649","Consider using `LoggingCacheErrorHandler` as the default cache error handler","These days, the cache backends used with Spring's caching abstraction are very frequently remote services (such as Redis, Memcached, Hazelcast in client-server topology...) which implies dealing with concerns such as networking, (de)serialization. These concerns mean there's far bigger chance of various (most often transient) errors occurring while interacting with the cache backend, unlike in-JVM cache solutions that dominated over a decade ago when caching abstraction was added to Spring.  With that in mind, I personally don't think `SimpleCacheErrorHandler` is a sensible default for the cache error handler as it breaks the application flow that's otherwise perfectly functional, just because the optimization (cache) was unavailable at that particular moment. Instead, the better option is to have `LoggingCacheErrorHandler` (with enabled stacktrace logging) as the default.  This is something that could be considered for 6.0.","closed","in: core,","vpavic","2022-06-17T15:50:03Z","2022-06-22T16:55:36Z"
"","28183","Improve documentation of Caching annotations","There was missing basic information for `conditional` attribute of `Cacheable` annotation. Perhaps something similar should be added also to `unless` attribute.","closed","type: documentation,","luvarqpp","2022-03-15T15:17:52Z","2022-07-29T16:08:18Z"
"","28910","Add Converter for DataSize","There is one in Spring Boot that can move into the Spring Framework. `DataSize` even has a parse method so it should be just a matter of adapting to `Converter`.","open","type: enhancement,","rstoyanchev","2022-08-02T08:42:51Z","2022-08-02T08:42:52Z"
"","28081","There is a redundant judgment before resolve argument","There is no need to judge whether the ``HandlerMethodArgumentResolver`` supports it before getting the parameters  https://github.com/spring-projects/spring-framework/blob/v5.3.16/spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java#L175-L177  Because method ``HandlerMethodArgumentResolverComposite#resolveArgument`` already has the same logic ``HandlerMethodArgumentResolverComposite#supportsParameter`` also calls ``#getArgumentResolver`` to determine whether the parameter is supported.   https://github.com/spring-projects/spring-framework/blob/v5.3.16/spring-web/src/main/java/org/springframework/web/method/support/HandlerMethodArgumentResolverComposite.java#L118-L121","closed","status: declined,","brucelwl","2022-02-20T07:46:14Z","2022-02-25T13:50:59Z"
"","28533","Improve options for exception handling in HTTP interface client","There is no good way to handle exceptions from a single place.   An application may want to turn `WebClientException` into another exception, or handle a specific exception. `WebClient` provides status handlers, but those are configured per request, and not exposed through the builder.","closed","type: enhancement,","rstoyanchev","2022-05-27T15:48:06Z","2022-06-24T14:55:55Z"
"","28578","BeanRegistrationCodeFragments sets a non-nullable field to null","There is a strange arrangement in `BeanRegistrationCodeFragments` where a package private constructor sets a non-null field to `null`. Making the field nullable doesn't help as it's used in all methods implemented by that class.","closed","theme: aot,","snicoll","2022-06-07T09:36:17Z","2022-06-07T17:11:14Z"
"","28339","Allow to register reflection hints for multiple types at once","There is a recurrent pattern that some classes share the same hints and the API does not offer a shortcut to register those on multiple types at once..  cc @christophstrobl","closed","theme: aot,","snicoll","2022-04-14T08:08:25Z","2022-04-14T08:23:16Z"
"","28665","Allow dynamic properties in ProblemDetail","There is a need for a generic map of properties in `ProblemDetail` for properties that are not known ahead of time, and cannot be exposed as setters from a subclass. Based on feedback on https://github.com/spring-projects/spring-framework/issues/27052#issuecomment-1140294702 and https://github.com/spring-projects/spring-framework/issues/27052#issuecomment-1141907448,","closed","type: enhancement,","rstoyanchev","2022-06-20T17:29:42Z","2022-07-12T12:05:40Z"
"","27914","ConcurrentTaskScheduler and ConcurrentTaskExecutor can create an executor with no way to shut it down","There is a default constructor of both on these that creates a default executor. When the application shuts down, there's no way to shut down the executor as it isn't exposed.  We probably may want to enforce the  wrapping feature instead and deprecate both constructors.","open","type: enhancement,","snicoll","2022-01-11T08:25:12Z","2022-06-14T20:46:39Z"
"","28736","Ensure channelExecutors and taskScheduler in STOMP WebSocket config are qualified","There are several beans require TaskExecutor or TaskScheduler without `@Qualifier`, which means inject wrong executors if we declare some executor bean `@Primary`.  As previously discussed at #28719, I use `@Qualifier` instead to avoid cglib proxies.","closed","type: regression,","CodeInDreams","2022-06-30T10:45:06Z","2022-07-04T15:55:15Z"
"","28719","Fix issue autowiring channelExecutors and taskScheduler in spring messaging & websocket","There are several beans require `TaskExecutor` or `TaskScheduler` without `@Qualifier`, which means inject wrong executors if we declare some executor bean `@Primary`. I found the problem by changing taskExecutor in `WebSocketMessageBrokerConfigurer#configureClientInboundChannel` ```java @Override public void configureClientInboundChannel(@NonNull ChannelRegistration registration) {     registration.interceptors(authInterceptor);     registration.taskExecutor(myExecutor()); } ```","closed","status: declined,","CodeInDreams","2022-06-28T13:08:18Z","2022-06-29T02:03:11Z"
"","28093","Rationalise merged BeanDefinition resolution for inner beans","There are more places where we need to create a `beanName` for an inner bean definition so rather than copy/pasting those, it would be better to have that logic in a single place.","closed","theme: aot,","snicoll","2022-02-22T10:45:31Z","2022-03-09T10:19:02Z"
"","28463","Circular bean reference error in Spring Boot v2.6.0 and above","The same project running in Spring Boot v2.5.13 runs without any errors, but when upgrading to Spring Boot v2.6.0 or above it fails with error message: ``` *************************** APPLICATION FAILED TO START ***************************  Description:  The dependencies of some of the beans in the application context form a cycle: ```  How to reproduce: Check working code from https://github.com/fteran/spring-security-oauth-demo.git Update pom.xml line 8 to `2.6.0` Run project by executing command: .\mvnw spring-boot:run","closed","for: external-project,","fteran","2022-05-15T12:44:25Z","2022-05-15T13:00:26Z"
"","28099","spring.main.allow-circular-references property does not effect in case of reading from Spring Cloud Config Server","The property **spring.main.allow-circular-references** work correctly when it's located directly to local application files as bootstrap.yaml or application.yaml(+profiles etc.) but don't work if it's obtained from **Spring Cloud Config Server**. Affected versions:  - Spring Boot: **2.6.3**  - Spring Cloud: **2021.0.1**   Test Spring Cloud Config client application: https://github.com/vaclav-doubek/spring-config-client-test Setup of Spring Cloud Config Server is needed.  The value is correctly readed regardless of Spring Cloud Config Server version.  When I check the value of spring.main.allow-circular-references property I got the expected value i.e. value from local files as well as Spring Cloud Config Server. But in case of Spring Cloud Config Server the application fail to start due to circular reference.  Expected behaviour is the Spring use the value of property spring.main.allow-circular-references for setup application context independently on the way of getting it.","closed","for: external-project,","vaclav-doubek","2022-02-23T11:47:31Z","2022-02-25T14:15:24Z"
"","28846","Inconsistent application of BeanPostProcessors to proxied self-referential beans","The problem arose when I used shedlock-spring's @SchedulerLock annotation in a bean that autowires a reference to itself. The code (roughly) looked like this:  ``` @Service public class Service {   @Autowired   private Service self;      @Scheduled // Shedlock is not applied when executed by the scheduler   @SchedulerLock   public void process() {}    public void action() {     this.process(); // Shedlock is not applied, as expected     self.process(); // Shedlock is properly applied, as expected   } } ```  What I discovered was that when Spring's scheduler runs this method, locking is not applied at all. Upon closed inspection it seems that the `@Scheduled` annotation processor, which is defined as a BeanPostProcessor, applies itself to the unproxied instance of the service. This is not the case when I remove the self reference, as the BeanPostProcessor then properly operates on a proxy and locking works as expected. Similar behavior can be seen with the `@Transactional` annotation.  I understand that circular references should be resolved by other means than delaying dependency injection, but I cannot quite grasp the reason behind ""falling back"" to applying BeanPostProcessors on the raw bean in case of an early proxy creation. Am I missing something?","open","status: waiting-for-triage,","riimeik","2022-07-21T09:54:28Z","2022-07-22T10:35:13Z"
"","28799","Move RuntimeHints predicates to a dedicated package","The predicates support deserves to be in its own package. This will also avoid `.hint` to be too flat.","closed","type: task,","snicoll","2022-07-12T13:07:33Z","2022-07-12T14:20:47Z"
"","28451","Reference PDF containing full docs not available","The PDF document linked in the documentation home does not contain full docs, but rather what is displayed on this very web page.  ![Untitled](https://user-images.githubusercontent.com/1357927/168010708-50a14e31-aec8-4827-bc83-fe46a03ecc77.png)  https://docs.spring.io/spring-framework/docs/5.3.20/reference/pdf/index.pdf  Looks like it is related to #26722. Single page HTML documentation is not available, similar with PDF file.  Each chapter is exported to a separate PDF:  https://docs.spring.io/spring-framework/docs/current/reference/pdf/  Either PDF containing complete documentation should be generated and linked on the documentation home page, or the link should be removed.","open","status: waiting-for-triage,","maciejwalkowiak","2022-05-12T07:01:45Z","2022-05-12T07:05:19Z"
"","28450","jdbc related new features and test cases","The original issue can be refer as: https://github.com/spring-projects/spring-framework/issues/28371 Since there is no way to keep any of the path variable values passing through As-Is without decoding at all, just create a new function to return the original path variable values.","open","status: waiting-for-triage,","yinpeng0528","2022-05-12T06:22:19Z","2022-06-01T04:07:57Z"
"","28453","Improve collectionFactory which allows single statement collection","The original issue can be refer as: [#28025](https://github.com/spring-projects/spring-framework/issues/28025) I improve CollectionFactory to allow for single statement collection creation by adding a new function with collection and collectionType.","closed","status: declined,","BinGuo0717","2022-05-12T07:32:10Z","2022-05-12T07:39:25Z"
"","28535","The OkHttp3ClientHttpRequestFactory caches the request body. When the request body is too large, an OOM occurs.","The OkHttp3ClientHttpRequestFactory caches the request body. When the request body is too large, an OOM occurs. The RestTemplate   is:  ```java    OkHttp3ClientHttpRequestFactory factory =                 new OkHttp3ClientHttpRequestFactory(new OkHttpClient());             RestTemplate   restTemplate = new RestTemplate(factory); ``` But when i user OkHttp3Clientto upload this file, it is successful.  My question  is why the SimpleClientHttpRequestFactory can set bufferRequestBody? ```java  	@Override 	public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException { 		HttpURLConnection connection = openConnection(uri.toURL(), this.proxy); 		prepareConnection(connection, httpMethod.name());  		if (this.bufferRequestBody) { 			return new SimpleBufferingClientHttpRequest(connection, this.outputStreaming); 		} 		else { 			return new SimpleStreamingClientHttpRequest(connection, this.chunkSize, this.outputStreaming); 		} 	} ``` but OkHttp3ClientHttpRequestFactory  without this switch?  I want to use the OkHttp3ClientHttpRequestFactory object without caching the request body,How can I do it?","open","status: waiting-for-triage,","DInTheName","2022-05-28T07:32:53Z","2022-05-28T07:35:14Z"
"","28555","Introduce RuntimeHints predicates utilities","The new `RuntimeHints` API allows to describe hints for the reflection/proxies/resources needs at runtime. The problem is, a single invocation at runtime can be covered by multiple, different hints.  For example, reflection introspection on the `myMethod` method for the class `MyClass` can be covered by any of:  * `MemberCategory.INTROSPECT_PUBLIC_METHODS` if `myMethod` is public * `MemberCategory.INVOKE_PUBLIC_METHODS` if `myMethod` is public * `MemberCategory.INTROSPECT_DECLARED_METHODS` in all cases * `MemberCategory.INVOKE_DECLARED_METHODS` in all cases * a specific introspection or invokation reflection entry for `MyClass::myMethod`  Because of the knowledge required for checking if registered hints are enough for a particular use case, we should introduce `Predicate` static utilities to be used in tests and in #27981","closed","theme: aot,","bclozel","2022-06-02T12:37:34Z","2022-06-10T17:38:18Z"
"","28754","Add native image support for WebSocket STOMP messaging","The native sample `websocket-stomp` works with AOT mode, but not in native image.  I identified at least two problems:  * The return and parameter values from `GreetingController` are not registered in `reflect-config.json` * Even if I manually add runtime hints, the handler methods are not called when a STOMP message arrives at the server","closed","theme: aot,","mhalbritter","2022-07-04T13:07:04Z","2022-07-11T17:43:38Z"
"","28476","Adding isNotEmpty methods for collections and maps","The motivation for this changes are  1. Majority of time the intention is to check that the collection is not empty instead of empty, as we cannot do much for null collections. 2. `CollectionUtils.isNotEmpty(collection)` is more readable than `!CollectionUtils.isEmpty(collection)` and there is no chance os missing the `!`. 3. `CollectionUtils::isNotEmpty` can be used as method reference.","closed","status: declined,","SaifAliKhan1","2022-05-18T17:36:43Z","2022-05-18T18:23:31Z"
"","28901","CompileWithTargetClassAccessExtension fails to select overloaded test methods","The method lookup algorithm in `CompileWithTargetClassAccessExtension` is based solely on the class name and method name. In other words, it omits the parameter list of the method declaration. This results in `CompileWithTargetClassAccessExtension` _selecting_ the wrong test method if the test class hierarchy declares multiple methods with the same name but different parameter lists.","closed","theme: aot,","sbrannen","2022-08-01T09:41:15Z","2022-08-01T10:12:05Z"
"","28326","spring bean invoke protected method  occur error : NoSuchMethodException","the method is executed  but has error log  code sample ：  	``` @Autowired 	private InsChecker insChecker;          public void test(Object ins ){ 	  DataMessage tmpMsg = insChecker.isAllowSend(ins);         }   @Component public class InsChecker extends BaseInsService { 	protected DataMessage isAllowSend(Object ins) {                 // method detail	 		return CommonUtils.createSucccessMsg(); 	} } ```","closed","for: stackoverflow,","liweiye-2021","2022-04-12T02:21:26Z","2022-04-12T06:08:18Z"
"","28464","CookieWebSessionIdResolver will never expire since maxAge is set in initSessionCookie()","the method `initSessionCookie` should not be called in `expireSession`!!!  as this will reset the expire state:  ``` if (this.cookieInitializer != null) { 			this.cookieInitializer.accept(cookieBuilder); 		} ```","closed","status: invalid,","izerui","2022-05-15T17:59:30Z","2022-05-16T09:14:02Z"
"","28270","BOM is missing for 5.3.18","The Maven artifact for spring-framework-bom 5.3.18 is missing from Maven Central. This prevents a quick update for projects that rely on the BOM.  See https://search.maven.org/search?q=g:org.springframework%20AND%20a:spring-framework-bom","closed","status: invalid,","koraktor","2022-04-01T11:58:54Z","2022-04-01T12:25:33Z"
"","28351","Make `BeanThatListens`, `TestApplicationListener`, `ResourceUrlProvider` threadsafe","The listener could be invoked concurrently by multiple thread, we should make them threadsafe.  https://github.com/spring-projects/spring-framework/blob/f40a391916ed6c1f9e1130638a0bf19479e514dd/spring-context/src/main/java/org/springframework/context/event/SimpleApplicationEventMulticaster.java#L40 >By default, all listeners are invoked in the calling thread.","open","status: waiting-for-triage,","dugenkui03","2022-04-16T13:41:00Z","2022-04-16T13:42:28Z"
"","28347","Reflection configuration for primitives have wrong name","The json writer does not handle reflection target name properly for primitives. `java.lang.double` is generated instead of `double` for instance. This leads to warning when building a native image and those hints are obviously not taken into account.","closed","theme: aot,","snicoll","2022-04-15T09:45:05Z","2022-04-15T09:48:22Z"
"","28050","Spring AspectJ support does not honor annotations on interfaces","The issue can be illustrated as follows:  ```java @Aspect @Component @Slf4j public class OldApiAspect {     @Around(""@within(com.top.plutus.common.OldApiService)"")     public Object doSomething1(ProceedingJoinPoint pjp) throws Throwable {         return pjp.proceed();     }      @Around(""@annotation(com.top.plutus.common.OldApiService)"")     public Object doSomething2(ProceedingJoinPoint pjp) throws Throwable {         return pjp.proceed();     } }  @OldApiService public interface TestService {     @OldApi     String test1();      @OldApi     String test2(); } ```  If we add annotation only on the interface, aop would not work. Actually, by scanning the code, it has accounted for this situation. Version: Spring Framework 5.2.9.RELEASE  org.springframework.aop.support.AopUtils:  ```java public static boolean canApply(Pointcut pc, Class targetClass, boolean hasIntroductions) { 		...... 		Set> classes = new LinkedHashSet<>(); 		if (!Proxy.isProxyClass(targetClass)) { 			classes.add(ClassUtils.getUserClass(targetClass)); 		}                 //here interfaces have been added to search range 		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); }  org.springframework.aop.aspectj.AspectJExpressionPointcut: private ShadowMatch getShadowMatch(Method targetMethod, Method originalMethod) { 		// Avoid lock contention for known Methods through concurrent access... 		ShadowMatch shadowMatch = this.shadowMatchCache.get(targetMethod);                 .... } ```  As the spring codes tells, when the implemented class's method could not meet the condition, it would be directly into the cache. When the method of the interface(After being processed by getMostSpecificMethod would return the method located in the implemented class) arrives here, the match result comes from the cache instead of checking the interface. But the interface might be configured differently from the implemented class.   My question:  If not supported interface, why put interfaces to search range?  `(classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));)`  If support,  the current logic is getMostSpecificMethod return the implemented  method instead of the method located in interface. This might not work?","open","in: core,","QuantumXiecao","2022-02-15T03:04:06Z","2022-03-19T04:37:55Z"
"","28858","Rationalize RootBeanDefinition post processing","The invocation of `MergedBeanDefinitionPostProcessor` instances is currently happening has part of bean instantiation https://github.com/spring-projects/spring-framework/blob/ae6a464a80507c63a84cc86c4e711107b097e168/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractAutowireCapableBeanFactory.java#L574-L586:  For AOT, we need to invoke these upfront so that the bean definition has all the information that we need. We're now in a situation where we need to be able to instantiate certain beans at build-time. This actually requires to register certain core `BeanPostProcessors`, see https://github.com/spring-projects/spring-framework/issues/28777. With the current arrangement, `MergedBeanDefinitionPostProcessor` instances registered in the context would be called twice. Once during AOT refresh phase, and once again for the bean that should be instantiated at build-time.  This issue is about finding an API arrangement where this can be streamlined so that it only happen once.","open","type: enhancement,","snicoll","2022-07-22T16:01:26Z","2022-07-26T07:32:14Z"
"","28889","Document compatibility with Servlet and Jakarta EE versions","The intro of reference manual section [_1. Spring Web MVC_](https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/web.html#mvc) states that:  > For baseline information and compatibility with Servlet container and Jakarta EE version ranges, see the Spring Framework [Wiki](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions).  However, the linked wiki page contains no information on compatibility with Servlet and Jakarta EE versions.","open","type: documentation,","vpavic","2022-07-29T20:37:21Z","2022-08-01T07:25:18Z"
"","28187","Add types to represent RFC 7807 problem details and exceptions","The goal for this issue is to add a representation for an RFC 7807 problem detail, and integrate it into Spring MVC and Spring WebFlux error response handling.  On the WebFlux side we have the `ResponseStatusException` hierarchy which contains HTTP status, a reason, and headers. We can now add a `ProblemDetail` as the body. This provides full encapsulation of all error response details within the exception.  On the Spring MVC side, we have the `DefaultHandlerExceptionResolver` which maps exceptions to HTTP status and headers, so exceptions do not themselves contain that information. Furthermore the exception hierarchy does not have a single base class where this can be added. We can add an interface to represent an error response, e.g. `ErrorResponse`, similar to the information exposed from `ResponseStatusException` on the WebFlux side, and then have all Spring MVC exceptions implement it in order to expose it in which case `DefaultHandlerExceptionResolver` no longer needs mapping logic.  `ResponseEntityExceptionHandler` is a base class for a controller advice that uses an `@ExceptionHandler` method to render error details. It has been around for some time, but so far application have had to extend it to decide on the error body format. We can now fill in the blank and use `ProblemDetail` for `ResponseError` exceptions that expose such information. A similar class does not exist for WebFlux but can be added.  `ResponseEntity` handling for both Spring MVC and WebFlux should support `ProblemDetail` and `ErrorResponse` as return types, automatically setting the response status, headers, and body accordingly. This is also an opportunity to set the `instance` field of `ProblemDetail` to the request path as a fallback if `instance` hasn't been set.","closed","type: enhancement,","rstoyanchev","2022-03-16T15:16:19Z","2022-05-20T20:56:13Z"
"","28547","DependencyDescriptor#resolveCandidate does not use the given class without any good reason","The following code comes from the `DependencyDescriptor`  ```java   	/** 	 * Resolve the specified bean name, as a candidate result of the matching 	 * algorithm for this dependency, to a bean instance from the given factory. 	 * The default implementation calls {@link BeanFactory#getBean(String)}. 	 * Subclasses may provide additional arguments or other customizations. 	 * @param beanName the bean name, as a candidate result for this dependency 	 * @param requiredType the expected type of the bean (as an assertion) 	 * @param beanFactory the associated factory 	 * @return the bean instance (never {@code null}) 	 * @throws BeansException if the bean could not be obtained 	 * @since 4.3.2 	 * @see BeanFactory#getBean(String) 	 */ 	public Object resolveCandidate(String beanName, Class requiredType, BeanFactory beanFactory) 			throws BeansException {  		return beanFactory.getBean(beanName); 	} ```  Is there any good reason why `beanFactory.getBean` does not use the `requiredType`? Especially as there is an overload which accepts a `Class`.  I think one should fix this or explain why we don't want to use it","closed","for: stackoverflow,","NWuensche","2022-05-31T18:33:11Z","2022-06-01T12:31:29Z"
"","28561","ScopedProxyBeanRegistrationAotProcessor is never called","The entry in `aot.factories` is pointing to a non existing factory class. This means that the processor is never called and scoped proxy handling does not work.","closed","theme: aot,","snicoll","2022-06-03T12:12:18Z","2022-06-03T12:36:39Z"
"","27998","Support custom resolution of empty strings in ResourceWebHandler","The empty string can be resolved as `index.html` in a custom `ResourceResolver`. It is useful when deploying front-end services.    Here is an example:  ```java String fallBack = ""/index.html""; new ResourceResolver() {     @Override @NonNull     public Mono resolveResource(ServerWebExchange exchange, @NonNull String requestPath, @NonNull List locations, @NonNull ResourceResolverChain chain) {         return chain                 .resolveResource(exchange, requestPath, locations)                 .switchIfEmpty(Mono.defer(()->chain.resolveResource(exchange, fallBack, locations)));     }      @Override @NonNull     public Mono resolveUrlPath(@NonNull String resourcePath,@NonNull List locations,@NonNull ResourceResolverChain chain) {         return chain                 .resolveUrlPath(resourcePath, locations)                 .switchIfEmpty(Mono.defer(()->chain.resolveUrlPath(fallBack, locations)));     } } ```  Its function is similar to that in nginx:  ```javascript location / {   try_files $uri $uri/ @router; } location @router {   rewrite ^.*$ /index.html last; } ```","closed","type: enhancement,","trionfordring","2022-02-03T07:53:51Z","2022-02-16T08:49:55Z"
"","28763","Documentation mentions password but should be personal access token","The documentation for spring-cloud-config [authentication section](https://cloud.spring.io/spring-cloud-config/reference/html/#_authentication) specifies a password field, but makes no mention that this password should be a personal access token instead of the password.","closed","for: external-project,","henrylangenhoven","2022-07-06T09:47:27Z","2022-07-06T11:06:29Z"
"","28218","警告: [deprecation] AccessibleObject中的isAccessible()已过时","The current environment：Windows10、jdk-11.0.14、IntelliJ IDEA 2021.3.3、Gradle-7.3.3 compile spring-framework-5.3.17 encounters an error: spring-framework-v5.3.17\spring-core\src\main\java\org\springframework\core\CoroutinesUtils.java:73: 警告: [deprecation] AccessibleObject中的isAccessible()已过时 if (method.isAccessible() && !KCallablesJvm.isAccessible(function))","closed","status: invalid,","doveylovey","2022-03-23T04:02:35Z","2022-04-08T07:14:27Z"
"","28066","Add support for starting a context that has been pre-processed","The counterpart of #28065 is that we need a way to start an `ApplicationContext` that has been pre-processed. Part of the refresh phase for such a context already ran, and therefore should not be invoked again.  Removing a low-level infrastructure, such as a `BeanDefinitionRegistryProcessor` implementation registered as a `@Bean` can be dangerous as said bean may implement extra interfaces (bean instance post-processing) that should actually run.   Starting a context this way should also provide the information that it runs in ""AOT optimized mode"" so that components can decide for themselves if they need to do something or rely on the AOT optimization.","closed","theme: aot,","snicoll","2022-02-17T08:18:22Z","2022-04-08T12:21:34Z"
"","28518","Add reflection hints for Web controllers","The core framework invokes `@RequestMapping`-annotated methods (`@GetMapping`, etc) using reflection. To run in a native image, we need hints for those. We may also want to infer that return types are going to be serialized, or that input times are going to be mapped from the request.  All this can go away if we generate an optimized code for the router but let's go the hints route for now.","closed","theme: aot,","snicoll","2022-05-24T14:07:30Z","2022-06-13T13:29:35Z"
"","28497","Introduce utility to register hints for an annotation that uses AliasFor","The core framework allows the use of `@AliasFor` which creates a JDK proxy behind the scenes. Registering a reflection hint for the attributes of the annotation is not enough for this to be used at runtime in a native image.   To ease the registration, we'll add a utility that takes care of this logic.","closed","theme: aot,","snicoll","2022-05-20T12:15:52Z","2022-05-20T13:23:05Z"
"","28758","Consider adding an example of buffering WebClient body in the filter in the reference documentation","The code samples in #26489 are very useful and I keep coming back to them. Recently I forgot the exact title and spent a while to remember how to find it. Perhaps it is a good candidate to add to the documentation, perhaps in [this section][section]? I would be willling to create that PR but I figured it probably makes sense to ask first.  [section]: https://docs.spring.io/spring-framework/docs/5.2.22.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-filter","open","status: waiting-for-triage,","alexanderankin","2022-07-05T11:37:28Z","2022-07-05T11:40:20Z"
"","28460","Reduce visibility of methods from ExitCodeGenerators to package private","The class `ExitCodeGenerators` is only package private, but all methods are public--they can be package private too.","closed","status: waiting-for-triage,","ullenboom","2022-05-14T13:14:03Z","2022-05-14T13:25:07Z"
"","28158","Add support for Spring Boot rules for property lookup in SystemEnvironmentPropertySource","The class [SystemEnvironmentPropertySource](https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/env/SystemEnvironmentPropertySource.java#L106) already supports lookup of properties from environment variables using the rules defined in `SystemEnvironmentPropertySource.resolvePropertyName`.  Example: A property with the name `some.property=value` with be resolved when defined as an environment variable `SOME_PROPERTY=value`.  In Spring Boot slightly different rules are used for resolving properties from environment variables, see [Binding from Environment Variables](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables).  The rules are: 1. Replace dots (.) with underscores (_). 2. Remove any dashes (-). 3. Convert to uppercase.  The second rule is causing a different result for values with dashes: * Spring: `property.first-second=value` will resolve to `PROPERTY_FIRST_SECOND=value` * Spring Boot: `property.first-second=value` will resolve to `PROPERTY_FIRSTSECOND=value`  I'm aware that Spring and Spring Boot are two different frameworks, but for situations where a combination of both are used (as in some of our applications) it would be very handy to also support the Spring Boot rule (Remove any dashes (-)) in addition to the current implemented rules in Spring.  As a temporary solution I have overwritten [StandardEnvironment.customizePropertySources](https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/env/StandardEnvironment.java#L96) and implemented an own `SystemEnvironmentPropertySource` with the additional rule.  I'd be happy to create a pull request if you agree with the change.","open","in: core,","anessi","2022-03-10T23:06:24Z","2022-04-25T09:40:51Z"
"","28659","Move Mock duplicates to test fixtures","The AOT tests are relying on mock implementations that are duplicated in the codebase. We should rationalize those in test fixtures instread as it makes it hard to change an interface that those duplicated mocks implement.","closed","theme: aot,","snicoll","2022-06-20T06:12:19Z","2022-06-20T06:57:51Z"
"","28556","Simplify SourceFileAssert assertion methods","The `SourceFileAssert` class offers a lot of assertions that we ended up not using. We should remove them before the module is made public. This will also help keep qdox as an implementation detail that we could possibly remove later.","closed","theme: aot,","philwebb","2022-06-03T00:24:38Z","2022-06-03T01:09:19Z"
"","28280","Remove DNS lookups during websocket connection initiation","The `ServletServerHttpRequest` `getLocalAddress` and `getRemoteAddress` methods contain additional DNS queries. The `servletRequest.getLocalName()` method requests a `hostname` from an IP address, and the `InetSocketAddress` constructor calls `InetAddress.getByName`, which requests an IP address from a `hostname`.  It looks like these requests can be omitted if you use `servletRequest.getLocalAddr()` and `servletRequest.getRemoteAddr()` instead of `get*Name()` methods.  If DNS is not properly configured on the server, then the establishment of a `websocket` connection hangs (for a few seconds).  Problematic stack trace:  ``` 	at java.net.Inet4AddressImpl.getHostByAddr(Native Method) 	at java.net.InetAddress$2.getHostByAddr(InetAddress.java:933) 	at java.net.InetAddress.getHostFromNameService(InetAddress.java:618) 	at java.net.InetAddress.getHostName(InetAddress.java:560) 	at java.net.InetAddress.getHostName(InetAddress.java:532) 	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.populateLocalName(NioEndpoint.java:1506) 	at org.apache.tomcat.util.net.SocketWrapperBase.getLocalName(SocketWrapperBase.java:277) 	at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:478) 	at org.apache.coyote.Request.action(Request.java:517) 	at org.apache.catalina.connector.Request.getLocalName(Request.java:1357) 	at org.apache.catalina.connector.RequestFacade.getLocalName(RequestFacade.java:1002) 	at org.springframework.http.server.ServletServerHttpRequest.getLocalAddress(ServletServerHttpRequest.java:200) 	at org.springframework.web.socket.server.standard.AbstractStandardUpgradeStrategy.upgrade(AbstractStandardUpgradeStrategy.java:116) 	at org.springframework.web.socket.server.support.AbstractHandshakeHandler.doHandshake(AbstractHandshakeHandler.java:297) 	at org.springframework.web.socket.server.support.WebSocketHttpRequestHandler.handleRequest(WebSocketHttpRequestHandler.java:178) 	at org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter.handle(HttpRequestHandlerAdapter.java:52) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ```  The impression is that these addresses are not even used by Spring, but are only needed to ensure the operation of the `WebSocketSession` methods `getLocalAddress()` and `getRemoteAddress()`, and we don't use these methods at all.","closed","type: enhancement,","ud1","2022-04-04T10:25:28Z","2022-04-08T11:26:57Z"
"","28907","RecordedInvocation instance resolution is inconsistent","The `RuntimeHintsAgent` records all invocations to instrumented methods as `RecordedInvocation`. They retain a reference to the actual object instance in case of virtual invocations; in case of static invocations, this is set to `null`. Several methods in `RecordedInvocation` and `RuntimeHintsInvocationsAssert` do not take this nullability into account properly.  `RecordedInvocation` also incorrectly resolves the `TypeReference` of those recorded instances.","closed","in: core,","bclozel","2022-08-01T15:22:59Z","2022-08-01T16:06:03Z"
"","28284","ModelAttributeMethodArgumentResolver does not support custom field binding for immutable objects","The `paramName` value for the constructor field is available, but is not used during binding on line 256 when `binder.convertIfNecessary(value, paramTypes[i], methodParam)` is called. When `propertyEditorRegistry.findCustomEditor(requiredType, propertyName)` is finally called in the `TypeConverterDelegate`, it is with a null value for the `propertyName` field, so any custom field editors will not be found.   **Affects:** 5.3.16  ---","open","status: feedback-provided,","seabamirum","2022-04-04T17:38:29Z","2022-04-13T00:37:34Z"
"","28609","ObjectToObjectConverter doesn't consider return type of static methods","The `ObjectToObject` converter currently checks the [return type for non-static methods](https://github.com/spring-projects/spring-framework/blob/9c9b2356cec4a74c685320c5b8b1b6eb283f9dc0/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToObjectConverter.java#L175); however, it does [no such check for static methods](https://github.com/spring-projects/spring-framework/blob/9c9b2356cec4a74c685320c5b8b1b6eb283f9dc0/spring-core/src/main/java/org/springframework/core/convert/support/ObjectToObjectConverter.java#L192). This means that it's possible for `canConvert` to return `true` when the actual conversion would throw an exception.  The following test shows the problem:  ```java public class ObjectToObjectConverterTests {  	@Test 	void fromWithDifferentReturnType() { 		GenericConversionService conversionService = new GenericConversionService(); 		conversionService.addConverter(new ObjectToObjectConverter()); 		// assertThat(conversionService.canConvert(String.class, Data.class)).isFalse(); 		Data data = conversionService.convert(""test"", Data.class); 	}  	static class Data {  		private final String value;  		private Data(String value) { 			this.value = value; 		}  		@Override 		public String toString() { 			return this.value; 		}  		public static Optional valueOf(String string) { 			return (string != null) ? Optional.of(new Data(string)) : Optional.empty(); 		}  	}  } ```","closed","in: core,","philwebb","2022-06-10T21:17:17Z","2022-06-13T15:36:19Z"
"","28627","NullBean breaks transitivity-contract of Object.equals","The `NullBean` class violates the transitivity property which is required by the contract for overwriting Object.equals ( see https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object ). That is: If `A` and `B` are equal, and `B` and `C` are equal, then `A` and `C` should be equal as well.  However, a NullBean `N1`, the value `null`,  and a NullBean `N2` break transitivity: `N1` is equal to `null`, `null` is equal to `N2`, but `N1` is *not* equal to `N2`.","open","type: enhancement,","NWuensche","2022-06-14T18:53:34Z","2022-06-14T20:30:51Z"
"","28748","Factory method is lost for AOT-processed beans that do not require autowiring","The `ListableBeanFactory` has these methods: ``` String[] getBeanNamesForAnnotation(Class annotationType); Map getBeansWithAnnotation(Class annotationType) throws BeansException;  A findAnnotationOnBean(String beanName, Class annotationType) ```  Which are useful in cases like this: ``` @Bean @GlobalChannelInterceptor(patterns = ""dateChannel"") WireTap loggingWireTap() { 	.... }  @Bean @IntegrationConverter Converter currentSeconds() {     ... } ```  After AOT has processed those beans and generated respective functional substitutions, there is no annotation info on bean definition anymore: an instance supplier just calls the target factory method via lambda: ```   /**    * Get the bean definition for 'currentSeconds'    */   public static BeanDefinition getCurrentSecondsBeanDefinition() {     ResolvableType beanType = ResolvableType.forClassWithGenerics(Converter.class, Date.class, Integer.class);     RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);     beanDefinition.setInstanceSupplier(InstanceSupplier.of(IntegrationApplication__BeanDefinitions::getCurrentSecondsInstance));     return beanDefinition;   }    /**    * Get the bean instance for 'currentSeconds'.    */   private static Converter getCurrentSecondsInstance(RegisteredBean registeredBean) {     return registeredBean.getBeanFactory().getBean(IntegrationApplication.class).currentSeconds();   } ```  I workaround it with some `Registration` bean definition from the `BeanDefinitionRegistryPostProcessor` at the moment and that's probably will let me to avoid some potential reflection for those annotations at runtime, but I believe there might be some use-cases when the mentioned `BeanFactory` API is called at runtime.","closed","theme: aot,","artembilan","2022-07-02T16:42:18Z","2022-07-26T13:00:29Z"
"","28434","Simplify Base64Utils","The `java.util.Base64` Encoder and Decoder classes have methods that accept strings as well as return strings. These can be used directly instead of converting between bytes and strings in the Spring classes.   This might also create a tiny performance improvement due to the java.util use of a deprecated, but useful String constructor, as well as its use of ISO_8859_1 encoding when converting strings to bytes. Given the allowable character range, ISO_8859_1 will result in the same conversions.  It appears that `Base64Utils` is only used within Spring Framework in `GsonBuilderUtils`, so a possibility would be to have that class use `java.util.Base64` directly, and deprecate`Base64Utils`.   A final observation - `Base64Utils` has explicit checks for empty strings and byte array parameters. The outputs are the same without , just potentially doing a bit more work before reaching the same answer. if these checks were intended as a safety-check as opposed to a performance optimization, these checks could also be removed.","open","status: waiting-for-triage,","j3graham","2022-05-09T23:09:52Z","2022-07-31T05:07:04Z"
"","28684","Consider making GenerationContext extend from Closeable","The `GenerationContext` keeps generated classes around so that multiple processors (or multiple round of the same processor) get a chance to contribute to the same file if necessary.  The Default implementation has a `writeGeneratedContent` that must be called at the end. We thought that it might be more obvious to make the context extend from `Closeable` so that a method that does this must be implemented.  The problem is `withName` that creates copies of the context with specialized naming convention. We don't really want those to be closed as the ""main"" context is still being processed. It's also unclear if we want to prevent users to use the context once it has been closed.","closed","theme: aot,","snicoll","2022-06-23T10:12:55Z","2022-07-26T14:53:14Z"
"","28574","CompileWithTargetClassAccessClassLoader does not implement findResource","The `CompileWithTargetClassAccessClassLoader` implements `findResources` but missed `findResource`.","closed","theme: aot,","philwebb","2022-06-06T19:30:00Z","2022-06-06T19:31:19Z"
"","28174","The ``methodCache`` in AdvisedSupport doesn't work for the first time","The ``methodCache`` in AdvisedSupport doesn't work for the first time，because the following method will create a new ``AdvisedSupport`` object   https://github.com/spring-projects/spring-framework/blob/v5.3.16/spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupport.java#L519-L527   https://github.com/spring-projects/spring-framework/blob/v5.3.16/spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupport.java#L466-L475","open","in: core,","brucelwl","2022-03-13T09:14:56Z","2022-04-25T09:41:49Z"
"","28819","Replace use of the tt HTML tag in Javadoc","The `` HTML tag was used in HTML 4 to define teletype text. It is not supported in HTML5 and its use is discouraged (https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tt).","open","type: documentation,","marcwrobel","2022-07-14T10:47:50Z","2022-07-31T05:11:05Z"
"","28702","RuntimeHintsUtils#registerAnnotation does not consider AliasFor in meta-annotation","The `@EnableGlobalAuthentication` in Spring Security uses `@Configuration` as a meta-annotation, which in turn uses `@AliasFor`. When using `RuntimeHintsUtils.registerAnnotation(hints, EnableGlobalAuthentication.class)` it does not work because the util method only considers `@AliasFor` inside the `EnableGlobalAuthentication` class, ignoring what is in the `@Configuration`, therefore leading to an error like this:  ``` Caused by: com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces [interface org.springframework.security.config.annotation.authentication.configuration.EnableGlobalAuthentication, interface org.springframework.core.annotation.SynthesizedAnnotation] not found. Generating proxy classes at runtime is not supported. Proxy classes need to be defined at image build time by specifying the list of interfaces that they implement. To define proxy classes use -H:DynamicProxyConfigurationFiles= and -H:DynamicProxyConfigurationResources= options. ``` If done manually, like so, it works: ```java hints.reflection().registerType(EnableGlobalAuthentication.class, RuntimeHintsUtils.ANNOTATION_HINT); hints.proxies().registerJdkProxy(EnableGlobalAuthentication.class, SynthesizedAnnotation.class); ```  **To simulate:** Change the [security sample](https://github.com/spring-projects-experimental/spring-native/tree/sb-3.0.x/samples/security) this way:  1. Create this class: ```java class CoreSecurityHints implements RuntimeHintsRegistrar {  	private static final Consumer HINT = builder -> builder.withMembers( 			MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);  	@Override 	public void registerHints(RuntimeHints hints, ClassLoader classLoader) { 		registerDefaultAuthenticationEventPublisherTypes(hints); 		// hints.reflection().registerType(EnableGlobalAuthentication.class, RuntimeHintsUtils.ANNOTATION_HINT); it works if done this way 		// hints.proxies().registerJdkProxy(EnableGlobalAuthentication.class, SynthesizedAnnotation.class);                  RuntimeHintsUtils.registerAnnotation(hints, EnableGlobalAuthentication.class); 	}  	private void registerDefaultAuthenticationEventPublisherTypes(RuntimeHints hints) { 		hints.reflection().registerType(AuthenticationFailureBadCredentialsEvent.class, HINT) 				.registerType(AuthenticationFailureCredentialsExpiredEvent.class, HINT) 				.registerType(AuthenticationFailureDisabledEvent.class, HINT) 				.registerType(AuthenticationFailureExpiredEvent.class, HINT) 				.registerType(AuthenticationFailureLockedEvent.class, HINT) 				.registerType(AuthenticationFailureProviderNotFoundEvent.class, HINT) 				.registerType(AuthenticationFailureProxyUntrustedEvent.class, HINT) 				.registerType(AuthenticationFailureServiceExceptionEvent.class, HINT) 				.registerType(AuthenticationServiceException.class, HINT) 				.registerType(AccountExpiredException.class, HINT) 				.registerType(BadCredentialsException.class, HINT) 				.registerType(CredentialsExpiredException.class, HINT) 				.registerType(DisabledException.class, HINT) 				.registerType(LockedException.class, HINT) 				.registerType(UsernameNotFoundException.class, HINT) 				.registerType(ProviderNotFoundException.class, HINT); 	}  } ```  2. Add `@ImportRuntimeHints(CoreSecurityHints.class)` in the `SecuringWebApplication` class 3. Run the `build.sh` script","closed","theme: aot,","marcusdacoregio","2022-06-24T14:10:31Z","2022-06-25T15:09:33Z"
"","28808","SimpleEvaluationContext should disable array allocation","The [Javadoc for SimpleEvaluationContext](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html) states that it is:  > tailored to support only a subset of the SpEL language syntax, e.g. excluding references to Java types, constructors, and bean references.  Since array allocation is a special kind of _constructor_ we should also disable array allocation in order to adhere to the contract of `SimpleEvaluationContext`.  This may be a breaking change for some users. Consequently, this change should likely only be made in Spring Framework 6.0.","open","type: enhancement,","quaff","2022-07-13T00:50:10Z","2022-07-13T08:13:14Z"
"","28397","Provide the HttpRequest on the ClientResponse interface","The [ClientResponse](https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ClientResponse.java) currenly does not provide an accessor to the HttpRequest object for which it was built.  This could be useful on (ExchangeFilterFunction)(https://github.com/spring-projects/spring-framework/blob/main/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/ExchangeFilterFunction.java) when handling redirects that happen at the TcpClient level.  Take for example the following sample: ```     public Mono filter(ClientRequest request, ExchangeFunction next)     {         return next.exchange(request)                    .doOnSubscribe(s -> {                        logger.info(""--> "" + request.method() + ' ' + request.url()); //1                    })                    .doOnError(error -> logger.info(""<-- HTTP FAILED"", error))                    .timed()                    .map(timed -> {                        var tookMs = timed.elapsed().toMillis();                        var response = timed.get(); //2                        logger.info(""<-- {} {}"", response.statusCode(), request.url());                        return response;                    });     } ```  In the line ""1"", I print the URL being requested originally, however the URL that it was finally used could be different on ""2"" if a redirect was followed. At the moment, there isn't a way of accessing that information from the ClientResponse object.","open","status: waiting-for-triage,","jonathannaguin","2022-04-29T11:42:34Z","2022-04-29T11:45:19Z"
"","28886","ConfigurationClassParser won't add PropertySources of the same name correctly","Thanks to the team for taking the time.  **Affects:** 5.3.18 and main branch   **Affected code**  https://github.com/spring-projects/spring-framework/blob/28ca0dd64209a003dcd577212ad06624dfbc2684/spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java#L482-L502  **Discussion**  The `addPropertySource` method is affected by a bug IMO where the effect of the if statement is reverted by the fact that `PropertySource`s are [hashed](https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/env/PropertySource.java#L147) using their `name` property.  When code reaches the affected if-statement, it means that a `PropertySource` of name `foo` is already registered in the Spring context, and that PropertySource is assigned to the `existing` variable. The idea is to replace (L499) the old property source with name `foo` with the `CompositePropertySource` containing both.  The problem is, given that  - `CompositePropertySource` holds a [**Set**](https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/env/CompositePropertySource.java#L45) of PropertySources - PropertySources are hashed by their `getName()`, which is not extended currently - Both PropertySources to compose have same name  In the end, the second PropertySource won't be added and CompositePropertySource will hold only one PropertySource of name `foo`  **Affected case**  We found a problem when multiple teams work on different Java libraries, each declaring some property sources from classpath files.  In the end, we discovered that if two libraries hold the same `env.yaml` in different packages, but the associated PropertySource name is computed by the file name (not fully qualified path), two libraries define a PropertySource named `env.yaml` and clash.  We expect this to happen even if teams define any kind of MapPropertySource with the same non-unique name. We have implemented a workaround by using the fully qualified resource URL.   **Suggested solution**  Have CompositePropertySource use List than Set?  **Test case**  Not _yet_ available","open","status: waiting-for-triage,","djechelon","2022-07-29T09:24:34Z","2022-07-29T09:25:47Z"
"","28577","Add testing support for AOT contributions","Testing AOT contributions using the `TestCompiler` requires a lot of setup, and I am not even sure it is possible to test AOT contributions outside of the Spring Framework at the moment.   Here is an example: https://github.com/spring-projects/spring-framework/blob/62d98685ce1cb39202879690334e2cc660f69204/spring-aop/src/test/java/org/springframework/aop/scope/ScopedProxyBeanRegistrationAotProcessorTests.java#L63-L80  * `TestBeanRegistrationsAotProcessor` is an internal test fixture (empty class to make a protected class public) * `MockBeanFactoryInitializationCode` is defined in the test * `testCompile` is [rather involved](https://github.com/spring-projects/spring-framework/blob/62d98685ce1cb39202879690334e2cc660f69204/spring-aop/src/test/java/org/springframework/aop/scope/ScopedProxyBeanRegistrationAotProcessorTests.java#L141-L160)  Perhaps a JUnit extension would be useful?","open","theme: aot,","snicoll","2022-06-07T09:05:05Z","2022-06-21T18:52:10Z"
"","28739","Spring WebFlux - Provide LocaleContext for validation message interpolator","Temporarily set LocaleContextHolder to provide validation message interpolator with locale context (SPR-17231). Fixes #21764.","open","type: enhancement,","borisfox73","2022-07-01T07:42:03Z","2022-07-01T08:28:11Z"
"","28869","Add annotation support for registering reflection hints","Team,  While I do appreciate the annotation support that has been provided by spring native, it would be so much easier to denote at the class/package level as to whether or not it requires reflection at compile time. The beauty of annotated meta data is that you can reference it inline at the class level instead of having to cross reference between a configuration centric class and the associated POJO that requires reflection.  I see that quarkus has this feature and for good reason, please add to the Spring Framework. https://javadoc.io/doc/io.quarkus/quarkus-core/latest/io/quarkus/runtime/annotations/RegisterForReflection.html","closed","status: invalid,","srunnoe","2022-07-25T13:10:02Z","2022-07-25T16:12:48Z"
"","28750","@Import and component scan of the same class results in duplicate bean registration with different names","Talk is cheap，show you the code below   1. Add `@Import(EnglishCat.class)` on the `@SpringBootApplication` main class，but the package of the `EnglishCat` class is not at the default scan package. 2. Add `@ImportResource({""classpath:spring/applicationContext.xml""})` also on the `@SpringBootApplication` main class  ```java package com.meituan.mdp.module1;  import com.meituan.mdp.module2.EnglishCat; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Import; import org.springframework.context.annotation.ImportResource;  @Import(EnglishCat.class) @ImportResource({""classpath:spring/applicationContext.xml""}) @SpringBootApplication public class ApplicationLoader {      public static void main(String[] args) {         SpringApplication application = new SpringApplication(ApplicationLoader.class);         application.setAdditionalProfiles(""test"");         application.run(args);     } } ```  3. The English Cat code as below，and the package is `com.meituan.mdp.module2`, and implements `BeanNameAware`, in order to see the bean name of the class has been registered to the Spring IOC container.  ```java package com.meituan.mdp.module2;  import org.springframework.beans.factory.BeanNameAware; import org.springframework.context.annotation.Configuration; import javax.annotation.PostConstruct;  @Configuration public class EnglishCat implements BeanNameAware {      String beanName;      @PostConstruct     public void sayHello() {         System.out.println(this.beanName +"":hello"");     }      @Override     public void setBeanName(String name) {         this.beanName = name;     } } ```  4. The code of `spring/applicationContext.xml` as below, only configures the component-scan，and the parameter base-package is `com.meituan.mdp.module2`, include the class of `EnglishCat`.  ```xml          ```  Now we run the sample, we can see Spring registers two beans with the class of `EnglishCat`. One is through the configuration class's registration. The other is through the `` in the XML，configuration by the `@ImportResource`. And the bean name is not the same.     If `` is replaced by `@ComponentScan`, the issue will gone, so I also read the source of Spring, to check the difference.  First: I found the registration of the Configuration class will check the list of Configuration in the code `ConfigurationClassParser#configurationClasses`, and the logic of `@ComponentScan` will add the Configuration class to `ConfigurationClassParser#configurationClasses`, but the process logic of `` will not.  Second: When process the `@Import(EnglishCat.class)`, the `EnglishCat` will be registered to the Spring container by a configuration Class whose bean name is `Class#getName` (spring source code is `ConfigurationClassPostProcessor#importBeanNameGenerator`), and register not judge the type.  In conclusion, no matter the order of processing `@Import(EnglishCat.class)` and `spring/applicationContext.xml`, the Spring container will register two beans of type `EnglishCat`，finally lead to some problem.  I don't know why the bean name of Imported configuration class is not the same with the component-scan (`AnnotationBeanNameGenerator#buildDefaultBeanName`)?  This code I have uploaded to GitHub in repository [ioc-singleton-issue-sample1](https://github.com/AmberyWang/ioc-singleton-issue-sample1). You can clone and run to see this issue.  And if you use auto configuration of Spring-boot, you also will meet this issue, and I also write a sample, upload to GitHub in repository [ioc-singleton-issue-sample2](https://github.com/AmberyWang/ioc-singleton-issue-sample2), you also can clone and run to see.  Expecting a reply! Thank you !!  Yours","closed","for: stackoverflow,","AmberyWang","2022-07-03T10:14:37Z","2022-07-03T15:03:45Z"
"","27904","Fix Javadoc links to JSR 305 annotations","Take a look at https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/lang/NonNull.html:  ```java @Target(value={METHOD,PARAMETER,FIELD}) @Retention(value=RUNTIME) @Documented @Nonnull @TypeQualifierNickname public @interface NonNull ```  The link behind `Nonnull` points to https://docs.oracle.com/javase/8/docs/api/javax/annotation/Nonnull.html?is-external=true, which is wrong  `Nonnull` is a JSR-305 datatype.","closed","type: documentation,","ullenboom","2022-01-07T17:18:51Z","2022-01-21T18:39:20Z"
"","28015","Synthesized annotation toString() doesn't match non-synthesized annotation on Java 9+","Synthesized annotations that contain arrays and/or strings do not generate the same `toString()` value as the non-synthesized version.   The non-synthesized annotation's `toString()` method returns a string which is a code equivalent version of that annotation meaning that you can take the result of the `toString()`, copy and paste it into code, and have it compile. This is very convenient when writing a code generation library since it allows you to copy annotations.  This does not work with synthesized annotations though as the way the array gets serialized in `toString()` doesn't match.  Actual Annotation:  ```java @Bean(""testValue"") ```  Non-Synthesized Annotation `toString()`:  ```java @org.springframework.context.annotation.Bean(value = {""testValue""}) ```  Synthesized Annotation `toString()`:  ```java @org.springframework.context.annotation.Bean(value = [testValue]) ```  https://github.com/spring-projects/spring-framework/blob/a0c97e4c36e5e07bc13bab4409ec740332a57871/spring-core/src/main/java/org/springframework/core/annotation/SynthesizedMergedAnnotationInvocationHandler.java#L202","closed","type: enhancement,","jeff-miller-cfa","2022-02-07T18:39:11Z","2022-02-11T14:16:27Z"
"","28285","Introduce @AliasFor attribute type conversion","Suppose that I have multiple `ExecutorService` beans to apply them within `@Async` annotation. Here is the pools configuration.  ```java @Configuration @EnableAsync class AsyncConfig {     @Bean     public ExecutorService fixedPool(@Value(""${fixed-pool-size}"") int poolSize) {         return Executors.newFixedThreadPool(poolSize);     }      @Bean     public ExecutorService cachedPool() {         return Executors.newCachedThreadPool();     } } ```  If I want to use one of these of pools as an async executor, I have several options.  1. **Specifiying pool bean name directly**  ```java @Async(""fixedPool"") public void myAsyncMethod() { ... } ```  In this case, I have to repeat `""fixedPool""` literal over and over again. Any typo would result to an error in runtime. Though I could move it to  public `String` constant, I don't like this approach. Because constants do not provide any context. Besides, its not the object-oriented way.  2. **Declaring custom annotations for each pool**  ```java @Target({TYPE, METHOD}) @Retention(RUNTIME) @Async(""fixedPool"") public @interface AsyncFixedPool { } ... @Target({TYPE, METHOD}) @Retention(RUNTIME) @Async(""cachedPool"") public @interface AsyncCachedPool { } ```  Now I can use either `@AsyncFixedPool` or `@AsyncCachedPool` annotation. On the other hand, I have to declare a separate annotation for each new pool that can be added lately.  And here is my proposal. It would be much convenient, If Spring allowed to specify `@AliasFor` enum attributes that can be converted to `String`. Here is my idea.  ```java @Getter @RequiredArgsConstructor public enum PoolType {     FIXED_POOL(""fixedPool""),     CACHED_POOL(""cachedPool"");      private final beanName; }  @Target({TYPE, METHOD}) @Retention(RUNTIME) @Async public @interface CustomAsync {     // here we're specifying PoolTypeConverter to transform PoolType enum to String value     @AliasFor(annotation = Async.class, attribute = ""value"", converter = PoolTypeConverter.class)     PoolType value(); }  // , Functional interface public class PoolTypeConverter implements AliasForConverter {     @Override     public String convert(PoolType poolType) {         return poolType.getBeanName();     } } ```  Now I can apply `@CustomAsync` and specify the required executor by enum.  Such feature would open so many possibilities in custom annotations reusing.","closed","type: enhancement,","SimonHarmonicMinor","2022-04-04T18:59:05Z","2022-04-05T15:44:40Z"
"","27993","Add support for strict JSON comparison in WebTestClient","Support for `expectedBody().json(, true);`  Part of the code base already has support - via `JsonExpectationsHelper` - but `WebTestClient` has no method to use the strict version. The existing method uses `lenient`, which is not always desired.  Example:  Let's say `/persons/1/` returns the following response:  ```json {   ""name"":""John"",   ""surname"":""Smith"" } ```  The following test works fine:  ```java webTestClient.get()     .uri(""/persons/1"")     .accept(MediaType.APPLICATION_JSON)     .exchange()     .expectStatus().isOk()     .expectBody().json(""{\""name\"":\""John\""}""); ```  I'm just adding a new method so that we can use strict comparison when appropriate.  Example:  This test fails because the response has more fields than expected and we're using strict mode:   ```java webTestClient.get()     .uri(""/persons/1"")     .accept(MediaType.APPLICATION_JSON)     .exchange()     .expectStatus().isOk()     .expectBody().json(""{\""name\"":\""John\""}"", true); ```  But the following test passes because we're expecting all fields:  ```java webTestClient.get()     .uri(""/persons/1"")     .accept(MediaType.APPLICATION_JSON)     .exchange()     .expectStatus().isOk()     .expectBody().json(""{\""name\"":\""John\"",\""surname\"":\""Smith\""}"", true); ```","closed","type: enhancement,","elgleidson","2022-02-01T10:08:47Z","2022-02-05T19:30:03Z"
"","28644","Spring official build and test, using OpenJDK?","Spring官方构建和测试，使用的是OpenJDK吗","closed","for: stackoverflow,","TangDynasty06","2022-06-17T01:55:24Z","2022-06-17T04:55:37Z"
"","28699","Support for CGLIB BeanCopier utility on JDK 17 still error","springframework.version 5.3.21 jdk.version 17  old [issues](https://github.com/spring-projects/spring-framework/issues/28530) I find this error still happening that is fault way to use? public static void main(String[] args) { BeanCopier beanCopier = BeanCopier.create(A.class, B.class, false); } Exception in thread ""main"" org.springframework.cglib.core.CodeGenerationException: java.lang.reflect.InaccessibleObjectException-->Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @32cf48b7 at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:589) at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) at java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java) at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) at org.springframework.cglib.beans.BeanCopier$Generator.create(BeanCopier.java:98) at org.springframework.cglib.beans.BeanCopier.create(BeanCopier.java:52) at club.edm.bscwallet.server.BscWalletApplication.main(BscWalletApplication.java:17) Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @32cf48b7 at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354) at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:553) ... 13 more ```     public static void main(String[] args) {         BeanCopier beanCopier = BeanCopier.create(A.class, B.class, false);         System.out.println(beanCopier);         A a = new A();     }      static public class A {      }      static public class B {      } ``` @jhoeller","open","status: waiting-for-triage,","SuperEdison","2022-06-24T10:35:52Z","2022-06-30T03:21:22Z"
"","28512","Alternative for ServletContextListener while using webflux/netty","Spring-weblux : 5.3.12 Java : 1.8 Netty : 4.1.71  `ServletContextListener` is part of `servlet-api`. Therefore, it is not available now after migrating to netty stack. Do we have any alternative for `ServletContextListener` to use while using netty server ?","closed","for: stackoverflow,","jweavers","2022-05-24T08:17:53Z","2022-05-24T08:42:53Z"
"","28436","SimpleMessageListenerContainer disconnects from message provider","spring-jms 5.3.19  Hello community, We are using org.springframework.jms.listener.SimpleMessageListenerContainer (SMLC) as a message listener for azure service bus (ASB). We are facing some strange issues when azure is not available for a short period of time and our SMLC is not able to reconnect. We end up with application running but not consuming any messages. As you can imagine, this took some time to realize and lot of messages were not processed.  Yes – monitoring your message service for incoming and outgoing messages to spot this kind of problem is a good thing (we were not so lucky to had it)  Yes – there is a simple mechanism in SMLC for reconnecting, but in our case, it is not sufficient. It may happen that it can try only once and there is no hook in case of unsuccessful reconnecting.  Yes – in this case the use of DefaultMessageListenerContainer (DMLC) would seem as reasonable – I has configurable reconnecting strategy. But we cannot use it. DMLC is using pull mechanism, so he constantly makes requests to ASB which leads to throttling problem in ASB and to solve it we would have to upgrade our pricing plan – which is not an option – we like the SMLC push approach which is not producing as many requests to ASB  After some time spent with SMLC we came with a solution, but it is not a nice solution because we reused(misused) onException method and we execute it over and over again to successfully reconnect with our broker – because only this method is capable to reconnect with message provider. The reason is - only here you are able to set sessions and consumers to null:  ```Java public void onException(JMSException ex) { 	// First invoke the user-specific ExceptionListener, if any. 	invokeExceptionListener(ex);  	// Now try to recover the shared Connection and all consumers... 	if (this.recoverOnException) { 		if (logger.isDebugEnabled()) { 			logger.debug(""Trying to recover from JMS Connection exception: "" + ex); 		} 		try { 			synchronized (this.consumersMonitor) { 				this.sessions = null; 				this.consumers = null; 			} 			refreshSharedConnection(); 			initializeConsumers(); 			logger.debug(""Successfully refreshed JMS Connection""); 		} 		catch (JMSException recoverEx) { 			logger.debug(""Failed to recover JMS Connection"", recoverEx); 			logger.error(""Encountered non-recoverable JMSException"", ex); 		} 	} } ```  Is it possible to take this code  ```Java synchronized (this.consumersMonitor) { 	this.sessions = null; 	this.consumers = null; } refreshSharedConnection(); initializeConsumers(); logger.debug(""Successfully refreshed JMS Connection""); ``` out to some method and call it directly - like void/boolean refreshContainer()?  In this case it can still remain simple, but you gain the ability to refresh connections/consumers and the developer can implement for example backoff as he wants. Also it would be nice to somehow know if you reconnected successfully or not.  Thank you for consideration of this proposal.","open","status: waiting-for-triage,","elnath","2022-05-10T07:37:48Z","2022-05-10T07:41:05Z"
"","28320","CVE-2022-22965又出现了，请问啥时候修复？","spring-framework中的表单绑定的问题，实际是CVE-2010-1622漏洞在高版本jdk上的绕过。在JDK 9及以上的版本中，新增的module属性可以被利用从而绕过了之前CVE-2010-1622漏洞的修复逻辑。","closed","for: stackoverflow,","1290708840","2022-04-11T06:58:53Z","2022-04-11T07:25:56Z"
"","28222","Caused by: java.lang.NoClassDefFoundError","spring-core-5.3.16  when i invoke org.springframework.cglib.beans.BeanMap.create(obj)，I checked this class(BeanMapEmitter.class) doesn't exist, but it's still being quoted(org.springframework.cglib.beans.BeanMap.Generator#generateClass, line number: 141)，appear this following error message:   > Exception in thread ""main"" java.lang.IllegalStateException: Unable to load cache item 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.beans.BeanMap$Generator.create(BeanMap.java:138) 	at org.springframework.cglib.beans.BeanMap.create(BeanMap.java:68) 	at com.javaosc.kernel.common.enhance.KitReflectionTest.main(KitReflectionTest.java:28) Caused by: java.lang.NoClassDefFoundError: org/springframework/cglib/beans/BeanMapEmitter 	at org.springframework.cglib.beans.BeanMap$Generator.generateClass(BeanMap.java:142) 	at org.springframework.cglib.core.DefaultGeneratorStrategy.generate(DefaultGeneratorStrategy.java:25) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:358) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	... 6 more Caused by: java.lang.ClassNotFoundException: org.springframework.cglib.beans.BeanMapEmitter 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) 	... 14 more","closed","status: duplicate,","dylan-tao","2022-03-23T17:04:06Z","2022-03-23T19:03:32Z"
"","28381","404 occurs when configuring access to local static files, which may be caused by URL transcoding","spring-boot:2.6.7 spring-webmvc:5.3.19  I have configured access to local static resources  ```java     @Override     public void addResourceHandlers(ResourceHandlerRegistry registry) {         registry.addResourceHandler(""/image1/**"").addResourceLocations(""file:D:\\Data\\TD\\image1\\"");     } ```  When I request a path: http://localhost:8080/image1/P/test%20simple.jpg Prompt 404 Not Found  Was found during debugging `org.springframework.web.servlet.resource.PathResourceResolver#encodeOrDecodeIfNecessary`  The code here will change the URI to: `P/test%2520simple.jpg`  The code is `org.springframework.web.servlet.resource.PathResourceResolver` on line 157  The `pathToUse` variable becomes `P/test%2520simple.jpg`","closed","status: duplicate,","Ziyear","2022-04-26T09:59:39Z","2022-04-26T10:13:48Z"
"","28323","@Conditional not load @configuration properties","spring-boot-starter-parent 2.6.6  Hello.  I am using the `@Conditional` annotation to validate if one of my beans has one property or another.  The problem I have is that when my @configuration class is executed ``` @Bean public three loadAnyBean(beanConfigOne one, beanConfigOne two) {  return CarConfig.newBuilder().env(""dev"").one(one).two(two).build();  } } ```  My beans one and two have no value.  This bean are of type `@configuration` and its properties are loaded with #{xxxxxxx}.  If I remove the `@Conditional` from my beans, everything works fine.  Can you help me? what am I doing wrong?","closed","for: stackoverflow,","jichu20","2022-04-11T08:43:59Z","2022-04-11T11:32:33Z"
"","28198","Remove obsolete org.springframework.core.NestedIOException","Spring's custom `org.springframework.core.NestedIOException` is obsolete and can be replaced with standard `IOException` usage.","closed","type: enhancement,","sbrannen","2022-03-18T15:53:05Z","2022-03-18T16:00:57Z"
"","28468","spring_ddj_explain","Spring 中文解释","closed","status: invalid,","dujiang0311","2022-05-16T15:13:53Z","2022-05-16T15:38:12Z"
"","28203","Spring Webflux returns Chinese garbled characters on ios","Spring Webflux returns json with a default response header of Content-Type of application/json, which is fine on browsers such as chrome, but messes up on ios. On ios when the response header Content-Type returns application/json;charset=UTF-8 there is no problem on ios. So, can I change the Content-Type of the response header to application/json;charset=UTF-8 on ios?","closed","for: stackoverflow,","kukume","2022-03-21T00:47:15Z","2022-03-21T06:29:30Z"
"","28541","Spring WebFlux doesn't support generic type serialization using kotlin serialization.","Spring WebFlux 5.2.30  The writeBody method of `AbstractMessageWriterResultHandler` class uses `actualElementType` which is inferred from the body argument looks like `DataList `not the `DataList` to check which `HttpMessageWriter` is available, the `HttpMessageWriter` class invokes `KotlinSerializationJsonEncoder's` `canEncode` method, the `actualElementType` can't be used to get the serializer, so the kotlin serialization throws an exception. The serialization was fallback to using Jackson.  ![image](https://user-images.githubusercontent.com/12178855/170991501-b9b625a8-58a5-46e6-af64-065315442883.png)  ![image](https://user-images.githubusercontent.com/12178855/170991635-48066d0e-7630-4e5c-8481-9d7f05deeaad.png)  ![image](https://user-images.githubusercontent.com/12178855/170991654-04eb7c7f-fc5b-4f1f-86fc-99cbdeb42ef5.png)  ![image](https://user-images.githubusercontent.com/12178855/170991681-2fe4f9c5-ce1f-446f-8d84-f1c83a241d6a.png)","open","status: waiting-for-triage,","danny-su","2022-05-30T12:39:45Z","2022-05-30T12:42:13Z"
"","28599","Charset for input stream ignored in Jaxb2XmlDecoder","Spring Web 5.3.18 Affected class: Jaxb2XmlDecoder  I am making a web request to a service that returnes XML, and having it decoded into a custom object. The response is encoded using ""ISO-8859-1"" and the charset is included in the response header, however, it's not used when building the XMLEventReader in Jaxb2XmlDecoder.  I have run the service against a mocked service producing the exact same response just encoded with UTF-8, and the object was unmarshalled correctly. The issues is the Jaxb2xmlDecoder attempts to unmashal in the method `decode` using the following:  ```java try { 	Iterator eventReader = inputFactory.createXMLEventReader(dataBuffer.asInputStream()); 	List events = new ArrayList<>(); 	eventReader.forEachRemaining(event -> events.add((XMLEvent) event)); 	return unmarshal(events, targetType.toClass()); } ```  The change required to use the correct encoding would be to replace ``` java inputFactory.createXMLEventReader(dataBuffer.asInputStream()); ```  with ``` java inputFactory.createXMLEventReader(dataBuffer.asInputStream(), mimeType.getCharset()); ```  ---  For completness, below is my current implementation. The WebClient used to make the request is created using: ```Java WebClient.builder() .codecs(clientCodecs -> {     clientCodecs.defaultCodecs().jaxb2Encoder(new Jaxb2XmlEncoder());     clientCodecs.defaultCodecs().jaxb2Decoder(new Jaxb2XmlDecoder()); }).build(); ```  And the request itself is: ```Java this.webClient.get()     .uri(uri)     .headers(headers -> headers.addAll(getHeaders))     .retrieve()     .bodyToMono(MyClass.class)     .block(); ```  The headers set are for the content type being `application/xml`   The exception thrown is: ``` Caused by: java.util.NoSuchElementException: ParseError at [row,col]:[287271,24] Message: Invalid byte 1 of 1-byte UTF-8 sequence. 	at com.sun.xml.internal.stream.XMLEventReaderImpl.next(XMLEventReaderImpl.java:252) 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s): 	*__checkpoint ⇢ Body from GET http://localhost:8008/ABCD [DefaultClientResponse] Original Stack Trace: 		at com.sun.xml.internal.stream.XMLEventReaderImpl.next(XMLEventReaderImpl.java:252) 		at java.util.Iterator.forEachRemaining(Iterator.java:116) 		at org.springframework.http.codec.xml.Jaxb2XmlDecoder.decode(Jaxb2XmlDecoder.java:194) 		at org.springframework.http.codec.xml.Jaxb2XmlDecoder.lambda$decodeToMono$2(Jaxb2XmlDecoder.java:183) 		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:113) 		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107) 		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:295) 		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337) 		at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) 		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:159) 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) 		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260) 		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) 		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:400) 		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:419) 		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:473) 		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:703) 		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:93) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436) 		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:327) 		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:299) 		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) 		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658) 		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584) 		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) 		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) 		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 		at java.lang.Thread.run(Thread.java:748) ```","closed","type: bug,","mo-zachery-harley","2022-06-09T12:49:28Z","2022-06-13T12:04:22Z"
"","28855","JPA exception mapping fails with Hibernate 6.1.1 in spring 6.0.0-M5","Spring version 6.0.0-M5  Exception mapping fails with `java.lang.NoSuchMethodError`  ``` Caused by: java.lang.NoSuchMethodError: 'java.io.Serializable org.hibernate.StaleObjectStateException.getIdentifier()' 	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:304) 	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:232) ```  In Hibernate 5 the method had the following signature:  `java.io.Serializable org.hibernate.StaleObjectStateException.getIdentifier()`  But it has changed in hibernate 6.x to be:  `java.lang.Object org.hibernate.StaleObjectStateException.getIdentifier()`  The change was made in this commit [https://github.com/hibernate/hibernate-orm/commit/5b3c6c488461943364d3ce8b696e999d77109419#diff-97a3fcd51fd4aefa42e50567ebf6dec8d8f404d2e5be39f6b4647c1698ef3aba](https://github.com/hibernate/hibernate-orm/commit/5b3c6c488461943364d3ce8b696e999d77109419#diff-97a3fcd51fd4aefa42e50567ebf6dec8d8f404d2e5be39f6b4647c1698ef3aba)","open","type: bug,","aspan","2022-07-22T10:34:38Z","2022-07-22T12:42:54Z"
"","28179","Using DataClassRowMapper causes ""No property found for column"" debug messages in logs","Spring JDBC: 5.3.16 Spring Boot 2.6.4  We're experimenting with the new `DataClassRowMapper` and found that if logging is set to `DEBUG` level then the [No property found for column](https://github.com/spring-projects/spring-framework/blob/5598f998168f564117f689d58317498dea59f029/spring-jdbc/src/main/java/org/springframework/jdbc/core/BeanPropertyRowMapper.java#L347) debug message is output.  This is confusing as it suggests that the column / property isn't being mapped, which isn't true as it is mapped during the constructor injection instead.  Steps to reproduce:  1. Change spring logging to be `debug` in the [test log file](https://github.com/spring-projects/spring-framework/blob/5598f998168f564117f689d58317498dea59f029/spring-jdbc/src/test/resources/log4j2-test.xml#L12). 2. Run one of the tests - `./gradlew spring-jdbc:test --tests org.springframework.jdbc.core.KotlinDataClassRowMapperTests` 3. View the standard output from the test in spring-jdbc/build/reports/tests/test/classes/org.springframework.jdbc.core.KotlinDataClassRowMapperTests.html  e.g. ``` 08:37:03.946 [Test worker] DEBUG o.s.j.c.JdbcTemplate - Executing SQL query [select name, age, birth_date, balance from people] 08:37:03.953 [Test worker] DEBUG o.s.j.d.DataSourceUtils - Fetching JDBC Connection from DataSource 08:37:03.973 [Test worker] DEBUG o.s.j.c.DataClassRowMapper - No property found for column 'name' mapped to field 'name' 08:37:03.973 [Test worker] DEBUG o.s.j.c.DataClassRowMapper - No property found for column 'age' mapped to field 'age' 08:37:03.974 [Test worker] DEBUG o.s.j.c.DataClassRowMapper - No property found for column 'birth_date' mapped to field 'birth_date' 08:37:03.974 [Test worker] DEBUG o.s.j.c.DataClassRowMapper - No property found for column 'balance' mapped to field 'balance' 08:37:03.975 [Test worker] DEBUG o.s.j.c.DataClassRowMapper - No property found for column 'e_mail' mapped to field 'e_mail' ```  The message should only be output if no property has been found / mapped.  In this case [DataClassRowMapper](https://github.com/spring-projects/spring-framework/blob/5598f998168f564117f689d58317498dea59f029/spring-jdbc/src/main/java/org/springframework/jdbc/core/DataClassRowMapper.java#L84) deliberately suppresses the properties.  One solution would be to keep a set of suppressed properties and then only output the message if not in the set.  Note that the log message is only output if logging is set to `DEBUG`, so it isn't a high severity issue.","closed","type: enhancement,","petergphillips","2022-03-15T09:27:44Z","2022-03-16T10:30:08Z"
"","28117","PROPAGATION_REQUIRES_NEW of TransactionTemplate does not work","Spring Framework 5.3.16 Spring Boot 2.5.10  When `TransactionTemplate` is retrieved from another class, `PROPAGATION_REQUIRES_NEW` of `TransactionTemplate` does not work.  Here is part of the code that reproduces it:  ```java     @Transactional(isolation = Isolation.READ_COMMITTED)     @Retryable(ObjectOptimisticLockingFailureException.class)     public boolean demo() {         Child child = childRepository.findFirstByOrderById().orElseThrow();         // if using `Transactions.getNew()`, the new transaction will not be actually created, which is not expected         // check the mysql general log, we can see the `insert` and `update` scripts are executed in the same transaction         // weirdly, changing `Transactions.getNew()` to `transactionTemplate` can fix it         Transactions.getNew().execute(status -> {             Assert.state(status.isNewTransaction(), ""New transaction required"");             Parent parent = new Parent();             parent.setChild(child);             // inserting a parent record will lock(S lock) the child row             // to avoid deadlock, we start a new transaction to insert it             return parentRepository.save(parent);         });         // updating a record will lock(X lock) the row         child.setName(""child-a"");         childRepository.save(child);         return true;     } ``` Please see the reproduction: https://github.com/Edsuns/transaction-template-issues.","open","in: data,","Edsuns","2022-03-01T05:04:50Z","2022-03-02T15:46:42Z"
"","28045","MappingJacksonValue and Jackson2CodecSupport#registerObjectMappersForType do not work together","Spring Framework 5.3.15 Spring Boot 2.6.3  I set up 2 `ObjectMapper`s (one per api version) : the last version uses the default `ObjectMapper` (created by Spring Boot), and i instantiate an other `ObjectMapper` for the version 1 (there is different settings for the dates, the null fields, and so on). I also need to build a Jackson Filter at runtime (the filter depends on the roles of the authenticated user), for that i can use the `MappingJacksonValue` wrapper. But when the values are wrapped, Spring will always use the default `ObjectMapper`.  We can see here that the `ObjectMapper` is selected before unwraping the value: https://github.com/spring-projects/spring-framework/blob/4eaee1e7381d5f3d8cd6e3ab77c8cfcf7ef2d716/spring-web/src/main/java/org/springframework/http/codec/json/AbstractJackson2Encoder.java#L195-L211  Is that ""by design"" or is this a missing feature?   Sample code: ```java @Configuration public class Config {     private static final MimeType[] EMPTY_MIME_TYPES = {};      @Bean     CodecCustomizer myJacksonCodecCustomizer(ObjectMapper objectMapper) {         return (configurer) -> {             CodecConfigurer.DefaultCodecs defaults = configurer.defaultCodecs();             defaults.jackson2JsonDecoder(new Jackson2JsonDecoder(objectMapper, EMPTY_MIME_TYPES));              Jackson2JsonEncoder jackson2JsonEncoder = new Jackson2JsonEncoder(objectMapper, EMPTY_MIME_TYPES);             // API v2 will use the default object mapper             jackson2JsonEncoder.registerObjectMappersForType(Controller.HelloV1.class, map -> {                 map.put(MediaType.APPLICATION_JSON, mapperForApiV1());             });             defaults.jackson2JsonEncoder(jackson2JsonEncoder);         };     }      private ObjectMapper mapperForApiV1() {         Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();         builder.featuresToEnable(SerializationFeature.WRITE_DATES_WITH_ZONE_ID);         builder.serializationInclusion(JsonInclude.Include.NON_ABSENT);         builder.modules(new SimpleModule(), new JavaTimeModule());         // And other settings         return builder.build();     } }  @RestController public class Controller {     @GetMapping(""/v1/hello"")     public Mono hello1() {         return Mono.just(new HelloV1(""world"", true, null));     }      @GetMapping(""/v2/hello"")     public Mono hello2() {         return Mono.just(new HelloV2(""world"", true, null));     }      @GetMapping(""/v1/wrapped-hello"")     public Mono wrappedHello1() {         MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(new HelloV1(""world"", true, null));         // mappingJacksonValue.setFilters(buildFilterFromRoles());         return Mono.just(mappingJacksonValue);     }      @GetMapping(""/v2/wrapped-hello"")     public Mono wrappedHello2() {         MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(new HelloV2(""world"", true, null));         // mappingJacksonValue.setFilters(buildFilterFromRoles());         return Mono.just(mappingJacksonValue);     }      private FilterProvider buildFilterFromRoles() {         // The actual filter is configured according to the roles of the authenticated user         SimpleBeanPropertyFilter theFilter = SimpleBeanPropertyFilter                 .serializeAllExcept(""canBeMasked"");         return new SimpleFilterProvider().addFilter(""myFilter"", theFilter);     }      public record HelloV1(String hello, boolean canBeMasked, String nullField) {}      public record HelloV2(String hi, boolean canBeMasked, String nullField) {} } ```  Expected results: ""/v1/wrapped-hello"" should return the same serialization than ""/v1/hello""","closed","type: bug,","ghostd","2022-02-12T22:10:25Z","2022-03-16T09:32:16Z"
"","27957","ServletServerHttpRequest getHeaders() throws IllegalArgumentException instead of ignoring invalid content type */*","Spring Boot version 2.6.2  [repo link](https://github.com/redapel/spring-boot-headers)  Curl command: ```shell curl localhost:8080/headers -H ""Content-type:\*/\*"" ```  Inside `/headers` method endpoint, when using `ServletServerHttpRequest getHeaders()` method produce the following result.  Actual result: `java.lang.IllegalArgumentException: Content-Type cannot contain wildcard type '*'`  Expected result: Exception should be ignored like what the comment say in the source code.  ```java // Ignore: simply not exposing an invalid content type in HttpHeaders... ```  We cannot prevent someone out there to not craft this kind of curl command request.","closed","type: bug,","redapel","2022-01-20T02:41:16Z","2022-02-02T17:36:58Z"
"","28228","@Transactional test does not execute all JPA lifecycle callback methods","Spring Boot v2.6.4  `@Transactional` tests are useful to roll back any test data created during tests; however, when a Spring integration test is annotated with `@Transactional` the following JPA lifecycle callback methods are not executed:  * `@PostPersist` * `@PostLoad` * `@PreUpdate` * `@PostUpdate`  Example project with tests demonstrating the issue here:  https://github.com/hughwphamill/transaction-test-entity-issue  I understand this is the desired behavior from a JPA perspective, but it's still undesirable from a test perspective.  `@Transactional` is incredibly useful in Spring integration tests to roll back test data, while exercising your whole application end to end.  If your business logic uses JPA entity listeners then your application can't be properly tested in a `@Transactional` test.","closed","type: documentation,","hughwphamill","2022-03-24T10:52:15Z","2022-03-28T15:26:51Z"
"","28558","Publish spring-core-test module","Spring Boot now need to use the TestCompiler class so we should publish the module.","closed","theme: aot,","philwebb","2022-06-03T00:55:45Z","2022-06-03T01:09:20Z"
"","28277","DefaultLifecycleProcessor doesn't wait for a Phase to stop completely if its bean is dependent on other SmartLifeCycle bean","Spring 5.2.2.RELEASE  There are 2 `SmartLifecycle` beans: `Phase888Service` and `Phase999Service`.   `Phase999Service` is dependent on `Phase888Service`.  ```java @Service @Slf4j public class Phase888Service implements SmartLifecycle {      @Autowired     private Phase999Service phase999Service;      private volatile boolean isRunning;      @Override     public int getPhase() {         return 888;     }      @Override     public void start() {         isRunning = true;     }      @Override     public void stop() {         throw new RuntimeException();     }      @Override     public void stop(Runnable callback) {         isRunning = false;          log.info("">>>>> Now stop 888"");          new Thread(() -> {             log.info("">>>>> Now stop 888"");             try {                 Thread.sleep(2000L);             } catch(InterruptedException e) {                 throw new RuntimeException(e);             }              log.info("">>>>> 888 stopped."");             callback.run();          }, ""Stop 888"").start();     }      @Override     public boolean isRunning() {         return isRunning;     } } ```  ```java @Service @Slf4j public class Phase999Service implements SmartLifecycle {      private volatile boolean isRunning;      @Override     public int getPhase() {         return 999;     }      @Override     public void start() {         isRunning = true;     }      @Override     public void stop() {         throw new RuntimeException();     }      @Override     public void stop(Runnable callback) {         isRunning = false;          log.info("">>>>> Now stop 999"");          new Thread(() -> {             log.info("">>>>> Now stop 999"");             try {                 Thread.sleep(4000L);             } catch(InterruptedException e) {                 throw new RuntimeException(e);             }              log.info("">>>>> 999 stopped."");             callback.run();          }, ""Stop 999"").start();     }      @Override     public boolean isRunning() {         return isRunning;     } } ```  When I stop the application the log looks like this:  ```   .   ____          _            __ _ _  /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \ ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \  \\/  ___)| |_)| | | | | || (_| |  ) ) ) )   '  |____| .__|_| |_|_| |_\__, | / / / /  =========|_|==============|___/=/_/_/_/  :: Spring Boot ::        (v2.2.2.RELEASE)  [INFO ] 2022-04-02 16:19:44.797 [            main] testing.Main : Starting Main on Marks-Smart-PC with PID 390888 (D:\workspace\testing\test-lifecycle-stop\build\classes\java\main started by Mark in D:\workspace\testing) [INFO ] 2022-04-02 16:19:44.800 [            main] testing.Main : No active profile set, falling back to default profiles: default [DEBUG] 2022-04-02 16:19:45.508 [            main] o.s.c.s.DefaultLifecycleProcessor : Starting beans in phase 888 [DEBUG] 2022-04-02 16:19:45.508 [            main] o.s.c.s.DefaultLifecycleProcessor : Successfully started bean 'phase999Service' [DEBUG] 2022-04-02 16:19:45.508 [            main] o.s.c.s.DefaultLifecycleProcessor : Successfully started bean 'phase888Service' [DEBUG] 2022-04-02 16:19:45.508 [            main] o.s.c.s.DefaultLifecycleProcessor : Starting beans in phase 999 [INFO ] 2022-04-02 16:19:45.514 [            main] testing.Main : Started Main in 0.961 seconds (JVM running for 1.673) [DEBUG] 2022-04-02 16:19:48.530 [  Stop Stop Stop] o.s.c.s.DefaultLifecycleProcessor : Stopping beans in phase 999 [INFO ] 2022-04-02 16:19:48.531 [  Stop Stop Stop] testing.Phase888Service : >>>>> Now stop 888 [INFO ] 2022-04-02 16:19:48.531 [  Stop Stop Stop] testing.Phase999Service : >>>>> Now stop 999 [INFO ] 2022-04-02 16:19:48.531 [        Stop 888] testing.Phase888Service : >>>>> Now stop 888 [INFO ] 2022-04-02 16:19:48.532 [        Stop 999] testing.Phase999Service : >>>>> Now stop 999 [INFO ] 2022-04-02 16:19:50.540 [        Stop 888] testing.Phase888Service : >>>>> 888 stopped. [DEBUG] 2022-04-02 16:19:50.540 [        Stop 888] o.s.c.s.DefaultLifecycleProcessor : Bean 'phase888Service' completed its stop procedure [DEBUG] 2022-04-02 16:19:50.540 [  Stop Stop Stop] o.s.c.s.DefaultLifecycleProcessor : Stopping beans in phase 888 [INFO ] 2022-04-02 16:19:52.535 [        Stop 999] testing.Phase999Service : >>>>> 999 stopped. [DEBUG] 2022-04-02 16:19:52.535 [        Stop 999] o.s.c.s.DefaultLifecycleProcessor : Bean 'phase999Service' completed its stop procedure ```  - `Phase888Service`  stop takes 4 sec and `Phase999Service` takes 2 sec. - `Phase888Service` begins to stop in phase 999 since it depends on `Phase999Service`. - Phase 888 begins to stop before `Phase999Service` stopped.  When I dive into the `DefaultLifecycleProcessor`, I found that it just passes the `countDownLatch` to `doStop()` for stopping the `dependentBeans`, and the `countDownLatch` is counted down after the `dependentBean` stopped.   ```java private void doStop(Map lifecycleBeans, final String beanName,                     final CountDownLatch latch, final Set countDownBeanNames) {      Lifecycle bean = lifecycleBeans.remove(beanName);     if (bean != null) {         String[] dependentBeans = getBeanFactory().getDependentBeans(beanName);         for (String dependentBean : dependentBeans) {             doStop(lifecycleBeans, dependentBean, latch, countDownBeanNames);               // ‘latch’ is counted down after the dependentBean is stopped         }         try {             if (bean.isRunning()) {                 if (bean instanceof SmartLifecycle) {                     if (logger.isTraceEnabled()) {                         logger.trace(""Asking bean '"" + beanName + ""' of type ["" +                                 bean.getClass().getName() + ""] to stop"");                     }                     countDownBeanNames.add(beanName);                     ((SmartLifecycle) bean).stop(() -> {                         latch.countDown();                         countDownBeanNames.remove(beanName);                         if (logger.isDebugEnabled()) {                             logger.debug(""Bean '"" + beanName + ""' completed its stop procedure"");                         }                     });                 }                 else {                     if (logger.isTraceEnabled()) {                         logger.trace(""Stopping bean '"" + beanName + ""' of type ["" +                                 bean.getClass().getName() + ""]"");                     }                     bean.stop();                     if (logger.isDebugEnabled()) {                         logger.debug(""Successfully stopped bean '"" + beanName + ""'"");                     }                 }             }             else if (bean instanceof SmartLifecycle) {                 // Don't wait for beans that aren't running...                 latch.countDown();             }         }         catch (Throwable ex) {             if (logger.isWarnEnabled()) {                 logger.warn(""Failed to stop bean '"" + beanName + ""'"", ex);             }         }     } } ```","open","in: core,","mark7473247","2022-04-02T11:44:35Z","2022-04-02T12:45:21Z"
"","28821","Use `{@code}` instead of HTML entities in Javadoc","Special characters, like < or >, don't need to be escaped in `{@code}` Javadoc tag (https://reflectoring.io/howto-format-code-snippets-in-javadoc/). Using `{@code}` improves readability of the Javadoc in code.","closed","","marcwrobel","2022-07-14T11:00:11Z","2022-07-19T07:53:35Z"
"","28098","Support type-safe transaction rollback rules","Source code in question：  ```java private int getDepth(Class exceptionClass, int depth) { 	if (exceptionClass.getName().contains(this.exceptionName)) { 		// Found it! 		return depth; 	} 	// If we've gone as far as we can go and haven't found it... 	if (exceptionClass == Throwable.class) { 		return -1; 	} 	return getDepth(exceptionClass.getSuperclass(), depth + 1); } ```  test code:  ```java public class CustomException extends Exception { }  public class CustomExceptionX extends Exception { }  @Override @Transactional(rollbackFor = CustomException.class) public void testTransaction() throws Exception {     taskMapper.softDeleteById(1, ""test"");     if (1 == 1) {         throw new CustomExceptionX();     } } ```","closed","type: enhancement,","hduyyg","2022-02-23T09:12:33Z","2022-03-04T18:36:36Z"
"","28085","ConfigurationClasses has userless data","Sorry to bother you, I mentioned this issue a few days ago, but it was closed by you without an explanation at that time. I think it is necessary to explain to you again that the configurationClasses container does have data that should not exist. Through my modification, the existing functions will not be damaged after testing, and it is indeed helpful to read the source code. ![image](https://user-images.githubusercontent.com/34882843/154908857-27a38569-abb0-40e9-8f46-bde18b7ba5fa.png)","closed","status: duplicate,","Evanhelovex","2022-02-21T07:34:59Z","2022-02-21T09:06:49Z"
"","28576","Support JSON Pointer in @HttpExchange interface","Sometimes we need extract data from child node instead of root document. For example get index mappings from ElasticSearch:  ```java @HttpExchange(""http://localhost:9200"") public interface ElasticSearchIndexOperations {  	@GetExchange(""/{index}/_mapping"") 	@JsonPointer(""/${index}/mappings"") 	Mappings getMapping(@PathVariable String index);   } ``` NOTE: placeholders in `@JsonPointer(""/${index}/mappings"")` need to be resolved  base on method parameters.","open","in: web,","quaff","2022-06-07T01:34:13Z","2022-06-07T09:33:23Z"
"","28657","I have some questions to ask how to solve","Some  problems  in  CoroutinesUtils.Class  'await(kotlin.coroutines.Continuation)' in 'kotlinx.coroutines.Deferred' cannot be applied to '(kotlin.coroutines.Continuation>)'  'awaitSingleOrNull(reactor.core.publisher.Mono, kotlin.coroutines.Continuation)' in 'kotlinx.coroutines.reactor.MonoKt' cannot be applied to '(reactor.core.publisher.Mono, kotlin.coroutines.Continuation>)'  'callSuspend(kotlin.reflect.KCallable, java.lang.Object[], kotlin.coroutines.Continuation)' in 'kotlin.reflect.full.KCallables' cannot be applied to '(kotlin.reflect.KFunction>, java.lang.Object[], kotlin.coroutines.Continuation>)'  'callSuspend(kotlin.reflect.KCallable, java.lang.Object[], kotlin.coroutines.Continuation)' in 'kotlin.reflect.full.KCallables' cannot be applied to '(kotlin.reflect.KFunction>, java.lang.Object[], kotlin.coroutines.Continuation>)'","closed","for: stackoverflow,","zhangsai123","2022-06-19T11:12:11Z","2022-06-19T12:10:06Z"
"","28853","SockJsServiceRegistration#setSupressCors has a typo and should be deprecated","SockJsServiceRegistration#setSupressCors name contains a typo. It is now deprecated in favor of a correctly spelled method, setSuppressCors.  Closes gh-28806","closed","type: bug,","marcwrobel","2022-07-21T21:57:52Z","2022-07-22T14:17:21Z"
"","28511","Seems bit aggressive to announce for the enforcement of java 17 in spring6","So this means, We cannot run Spring Boot 3.x or Spring 6 applications in Oracle Weblogic. Since even latest version of Weblogic only support JDK 11.  Or am I missing something?","closed","status: invalid,","Nidhi-Tanwar14","2022-05-24T07:41:54Z","2022-06-06T11:58:41Z"
"","28534","OncePerRequestFilter gets hit over and over when batching using a FORWARD","So as you know, the diff between a FORWARD and REDIRECT is that REDIRECT reissues the request and does a round robin outside the DMZ.  A FORWARD uses the saame REQUEST/RESPONSE to loop internally.  However in testing, I noticed that the 'OncePerRequest' filter keeps gets hit over and over when looping a batch call using a FORWARD.  Thats not 'OncePerRequestFilter' ... thats 'PotentiallySeveralDozenTimesPerRequestFilter' :)  I tested this by Using HTTPClient in my integration tests and outputting the request session id when it was hitting the doFilterInternal() method; it was the same request being used (session had NOT been reissued because request had NOT been dropped and recreated... thus same session, same request)  Is this expected functionality?? Or is this a BUG?","open","status: waiting-for-triage,","orubel","2022-05-27T17:57:21Z","2022-06-05T15:49:47Z"
"","28781","Introduce ProxyHints.registerJdkProxy(String...)","Since users might not have a concrete need to work with `TypeReference`, we should introduce `ProxyHints.registerJdkProxy(String...)` to simplify use of the API for registering a dynamic proxy based on fully qualified class names of the required interfaces.","open","theme: aot,","sbrannen","2022-07-10T16:50:26Z","2022-07-12T13:08:35Z"
"","27908","Simplify debugging of Undertow transferTo issue #25310","Since undertowHttpServer conflicts with other HTTPServers. Temporarily bypass with transferToForUndertow. It's better than return and pass.","closed","type: task,","JiangTChen","2022-01-09T14:51:47Z","2022-01-14T14:59:59Z"
"","28751","Simplify @EneabledIfRuntimeHintsAgent support","Since the `RuntimeHintsAgentCondition` is based solely on the result of invoking a `boolean` static method, there is no need to implement a custom `ExecutionCondition`. For such use cases, the `@EnabledIf` support in JUnit Jupiter is sufficient.  This commit therefore replaces the custom `RuntimeHintsAgentCondition` with use of `@EnabledIf` as a meta-annotation.  Please note that this PR also removes the `@Tag(""RuntimeHintsTests"")` declaration. If that is still needed for particular use cases, that can be retained.","closed","theme: aot,","sbrannen","2022-07-03T18:36:03Z","2022-07-15T17:06:26Z"
"","28147","Upgrade Kotlin to 1.6.20-RC","Since Kotlin 1.6.20 won't be available for M3, the upgrade to 1.6.20 will be part of M4, see #28036.","closed","in: kotlin,","sdeleuze","2022-03-09T09:49:48Z","2022-03-09T09:51:03Z"
"","28455","Resolve package cycle around MissingServletRequestPartException","Since #27910 / #27948 `web.multipart.MissingServletRequestPartException` extends `web.bind.ServletRequestBindingException` which unfortunately creates a package cycle since the `web.bind` package depends on `web.multipart` within its binder implementations.  The root of the problem there is that `MissingServletRequestPartException` serves two rather different purposes: It is being thrown by `RequestPartServletServerHttpRequest` as a low-level API exception (which is why it lives in the `web.multipart` package), but then also used by `RequestParamMethodArgumentResolver` for handler method argument binding (for which it should actually live in `web.bind`). The proper solution would be to use a different exception type for the bind purpose, and to only let that one extend `ServletRequestBindingException` as of 6.0. Let's revisit this for M5.","closed","type: regression,","jhoeller","2022-05-12T11:47:43Z","2022-06-01T17:19:10Z"
"","28249","SimpleUrlHandlerMapping invokes HandlerInterceptor twice","SimpleUrlHandlerMapping is causing double call of HandlerInterceptor. This is related to https://github.com/spring-projects/spring-data-rest/issues/1955 which has been fixed; should be an easy fix.  This bug was recently introduced in the last year and was fixed in other mappings but not underlying ones like SimpleUrlHandlerMapping.  I have tested and have working code showing an example (but requires external properties/config files).  Have tried removing filters, different adapters. Still the same.   Wasn't until I saw that error that I noticed the bug wasn't fixed in `SimpleUrlHandlerMapping`.  Output from a debug more clearly shows the error:  ``` 11:26:34.378 [http-nio-8080-exec-1] DEBUG o.s.security.web.FilterChainProxy - Secured GET /v0.4/user/show/5 Parsing Uri....... 11:26:34.397 [http-nio-8080-exec-1] DEBUG o.s.web.servlet.DispatcherServlet - GET ""/v0.4/user/show/5"", parameters={} 11:26:34.404 [http-nio-8080-exec-1] DEBUG o.s.w.s.h.SimpleUrlHandlerMapping - Mapped to demo.application.controller.UserController@40d10481 interceptor NO CACHED API RESPONSE interceptor NO CACHED API RESPONSE at usercontroller... user/show has user... [id, version, username, password, uid, firstName, lastName, email, emailVerified, oauthId, oauthProvider, avatarUrl, enabled, accountExpired, accountLocked, passwordExpired, authorities, userame] [id, version, username, password, uid, firstName, lastName, email, emailVerified, oauthId, oauthProvider, avatarUrl, enabled, accountExpired, accountLocked, passwordExpired, authorities, userame] ```  The 'UserController' is only called once (as shown above) but the handlerinterceptor's prehandle/posthandle are being triggered twice each","closed","status: invalid,","orubel","2022-03-29T15:57:20Z","2022-04-03T07:16:40Z"
"","28306","ISSUE 28305 treat mariaDB as an independent database type","Signed-off-by: Mayra Quiroga","closed","status: declined,","ben-enfuse-io","2022-04-07T21:23:44Z","2022-04-18T18:56:51Z"
"","28892","Include shadow jar source in published source jars","Shadowed jars do not currently include their source code in our published source jars. This can make debugging and developing a little tricky, especially with javapoet classes which are central to our AOT apis.","closed","type: task,","philwebb","2022-07-30T09:23:30Z","2022-07-30T09:28:41Z"
"","28902","WebClientIntegrationTests are failing if port 80 is in use","Several tests from `WebClientIntegrationTests` are failing for me locally when port 80 is in use. To reproduce this ensure the build is not pulling results from the cache.  ```bash $ nc -vz localhost 80 Connection to localhost (127.0.0.1) 80 port [tcp/http] succeeded! ``` ```bash $ ./gradlew clean --no-build-cache :spring-webflux:test --tests ""org.springframework.web.reactive.function.client.WebClientIntegrationTests""  > Task :spring-beans:compileTestFixturesJava /home/vpavic/dev/projects/spring-projects/spring-framework/worktree-main/spring-core/build/classes/java/main/org/springframework/lang/Nullable.class: warning: Cannot find annotation method 'when()' in type 'Nonnull': class file for javax.annotation.Nonnull not found warning: unknown enum constant When.MAYBE   reason: class file for javax.annotation.meta.When not found /home/vpavic/dev/projects/spring-projects/spring-framework/worktree-main/spring-core/build/classes/java/main/org/springframework/lang/NonNullApi.class: warning: Cannot find annotation method 'value()' in type 'TypeQualifierDefault': class file for javax.annotation.meta.TypeQualifierDefault not found /home/vpavic/dev/projects/spring-projects/spring-framework/worktree-main/spring-core/build/classes/java/main/org/springframework/lang/NonNullFields.class: warning: Cannot find annotation method 'value()' in type 'TypeQualifierDefault' 4 warnings  > Task :spring-webflux:test  WebClientIntegrationTests > malformedResponseChunksOnBodilessEntity(ClientHttpConnector) > org.springframework.web.reactive.function.client.WebClientIntegrationTests.malformedResponseChunksOnBodilessEntity(ClientHttpConnector)[3] FAILED     java.lang.AssertionError at MessageFormatter.java:115  WebClientIntegrationTests > malformedResponseChunksOnEntityWithBody(ClientHttpConnector) > org.springframework.web.reactive.function.client.WebClientIntegrationTests.malformedResponseChunksOnEntityWithBody(ClientHttpConnector)[3] FAILED     java.lang.AssertionError at MessageFormatter.java:115  WebClientIntegrationTests > exchangeWithRelativeUrl(ClientHttpConnector) > org.springframework.web.reactive.function.client.WebClientIntegrationTests.exchangeWithRelativeUrl(ClientHttpConnector)[1] FAILED     java.lang.AssertionError at MessageFormatter.java:115  WebClientIntegrationTests > exchangeWithRelativeUrl(ClientHttpConnector) > org.springframework.web.reactive.function.client.WebClientIntegrationTests.exchangeWithRelativeUrl(ClientHttpConnector)[2] FAILED     java.lang.AssertionError at MessageFormatter.java:115  WebClientIntegrationTests > exchangeWithRelativeUrl(ClientHttpConnector) > org.springframework.web.reactive.function.client.WebClientIntegrationTests.exchangeWithRelativeUrl(ClientHttpConnector)[3] FAILED     java.lang.AssertionError at MessageFormatter.java:115  WebClientIntegrationTests > exchangeWithRelativeUrl(ClientHttpConnector) > org.springframework.web.reactive.function.client.WebClientIntegrationTests.exchangeWithRelativeUrl(ClientHttpConnector)[4] FAILED     java.lang.AssertionError at MessageFormatter.java:115  165 tests completed, 6 failed  > Task :spring-webflux:test FAILED  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':spring-webflux:test'. > There were failing tests. See the report at: file:///home/vpavic/dev/projects/spring-projects/spring-framework/worktree-main/spring-webflux/build/reports/tests/test/index.html  * Try: > Run with --stacktrace option to get the stack trace. > Run with --info or --debug option to get more log output. > Run with --scan to get full insights.  * Get more help at https://help.gradle.org  BUILD FAILED in 21s 93 actionable tasks: 74 executed, 19 up-to-date  A build scan was not published as you have not authenticated with server 'ge.spring.io'. ``` ```bash $ systemctl stop nginx.service ``` ```bash $ nc -vz localhost 80 nc: connect to localhost (127.0.0.1) port 80 (tcp) failed: Connection refused ``` ```bash $ ./gradlew clean --no-build-cache :spring-webflux:test --tests ""org.springframework.web.reactive.function.client.WebClientIntegrationTests""  > Task :spring-beans:compileTestFixturesJava /home/vpavic/dev/projects/spring-projects/spring-framework/worktree-main/spring-core/build/classes/java/main/org/springframework/lang/Nullable.class: warning: Cannot find annotation method 'when()' in type 'Nonnull': class file for javax.annotation.Nonnull not found warning: unknown enum constant When.MAYBE   reason: class file for javax.annotation.meta.When not found /home/vpavic/dev/projects/spring-projects/spring-framework/worktree-main/spring-core/build/classes/java/main/org/springframework/lang/NonNullApi.class: warning: Cannot find annotation method 'value()' in type 'TypeQualifierDefault': class file for javax.annotation.meta.TypeQualifierDefault not found /home/vpavic/dev/projects/spring-projects/spring-framework/worktree-main/spring-core/build/classes/java/main/org/springframework/lang/NonNullFields.class: warning: Cannot find annotation method 'value()' in type 'TypeQualifierDefault' 4 warnings  BUILD SUCCESSFUL in 20s 93 actionable tasks: 74 executed, 19 up-to-date  A build scan was not published as you have not authenticated with server 'ge.spring.io'. ```","open","status: waiting-for-triage,","vpavic","2022-08-01T10:02:43Z","2022-08-01T16:32:49Z"
"","28883","Deleting Sensitive Information from the Memory","Sensitive information (for example, passwords in login requests) stored in the temporary memory is not cleared in time after being used. It depends on the recycling mechanism of the JDK and may be used. ![image](https://user-images.githubusercontent.com/54844681/181671792-13686097-26eb-4bc3-a06c-7421141cf80c.png)","closed","status: invalid,","xukun-cpu","2022-07-29T02:42:47Z","2022-07-29T05:05:38Z"
"","28054","Remove deprecated SocketUtils","See:  -  #28052","closed","type: enhancement,","sbrannen","2022-02-15T15:46:36Z","2022-03-21T16:59:25Z"
"","28421","Add byte[] to supported types in SimpleJmsHeaderMapper","See more info in the https://github.com/spring-projects/spring-integration/issues/3788 and its related PR.  For consistency it is better to have a good interoperability between Spring JMS and Spring Integration.","closed","type: enhancement,","artembilan","2022-05-05T16:44:57Z","2022-05-06T14:26:38Z"
"","28642","Document that Kotlin inline classes are not supported yet","See https://github.com/spring-projects/spring-framework/issues/28638#issuecomment-1157757880 for more context.","closed","in: kotlin,","sdeleuze","2022-06-16T15:00:34Z","2022-06-17T11:03:39Z"
"","28632","Add example using @NestedTestConfiguration","See https://github.com/spring-projects/spring-framework/issues/28611#issuecomment-1154708483 for background.","open","type: documentation,","sbrannen","2022-06-15T11:53:02Z","2022-06-27T16:24:22Z"
"","28630","Refine @Required Kotlin documentation to use annotation use site targets","See https://github.com/spring-projects/spring-framework/issues/28596#issuecomment-1156147396 related comment.","closed","in: kotlin,","sdeleuze","2022-06-15T08:26:31Z","2022-06-17T11:03:38Z"
"","28833","Don't use BeanRegistrationExcludeFilter as an exclude signal","See https://github.com/spring-projects/spring-framework/issues/28526#issuecomment-1150592510","closed","theme: aot,","philwebb","2022-07-18T10:07:59Z","2022-07-28T06:26:13Z"
"","27980","Improve documentation for implementing AspectJ around advice","See https://github.com/spring-projects/spring-framework/issues/27963#issuecomment-1018306098","closed","in: core,","sbrannen","2022-01-26T15:30:04Z","2022-01-26T16:35:03Z"
"","28582","Add support for annotation processors with TestCompiler","See https://github.com/spring-projects/spring-boot/issues/31266 for background.","closed","theme: aot,","philwebb","2022-06-07T23:53:18Z","2022-06-07T23:54:21Z"
"","28352","Return UnmodifiableMap in MVC PathVariableMapMethodArgumentResolver","See gh-28127.","closed","type: enhancement,","dugenkui03","2022-04-16T13:45:34Z","2022-04-16T16:10:44Z"
"","28113","Avoid multiple invocations of private lifecycle method","See gh-28083","closed","in: core,","vikeychen","2022-02-28T17:02:28Z","2022-03-01T17:09:23Z"
"","28448","Update javadoc as type-level @Controller is now required","See gh-22154 which removed support for a type-level `@RequestMapping` annotation alone being sufficient for handler detection.","closed","type: task,","wilkinsona","2022-05-11T13:19:36Z","2022-05-11T14:48:03Z"
"","28685","Platform Transaction Manager / error on afterCommit should NOT trigger afterCompletion with success code","see [AbstractPlatformTransactionManager:782](https://github.com/spring-projects/spring-framework/blob/main/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L782)  Errors on afterCommit still trigger afterCompletion with committed status.  This confuses our custom synchronization callback, into performing its ""afterCompletion"" action even though the ""afterCommit"" step of the transaction has failed. This is present in the latest code and our only option is to track the flow of the transaction in our custom synchronization callback to confirm that ""afterCommit"" has been called before ""beforeCompletion""  We believe this is a bug and should be handled more explicitly, probably with an additional synchronization callback method and/or an adjustment to the transaction flow.  More precisely, `org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerSynchronization.afterCommit` synchronization callback is throwing an error which is not captured by `AbstractPlatformTransactionManager`","open","status: waiting-for-triage,","eliasbalasis","2022-06-23T11:54:45Z","2022-06-23T15:03:06Z"
"","28107","A request to empty file in runnable jar cause 404","Same as this issue: https://github.com/spring-projects/spring-boot/issues/16034  `org.springframework.core.io.AbstractFileResolvingResource` will consider an empty file in runnable jar is unreadable.    It cause different and confusing behavior after `mvn package`.  I think empty folders can indeed be considered unreadable, but files should not be the same.  Do you have any plans to fix it?","closed","in: core,","dcsuibian","2022-02-25T08:36:38Z","2022-02-25T14:50:28Z"
"","28690","native-image: Missing resource hint for ConfigurableMimeFileTypeMap","Running the native-image from spring-native samples in branch `sb-3.0.x` leads to  ``` org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'javamailService': Unsatisfied dependency expressed through constructor parameter 0: Error creating bean with name 'mailSender': Instantiation of supplied bean failed 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArgument(AutowiredInstantiationArgumentsResolver.java:319) ~[na:na] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArguments(AutowiredInstantiationArgumentsResolver.java:232) ~[na:na] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:154) ~[na:na] 	at com.example.javamail.service.JavamailService__BeanDefinitions.getJavamailServiceInstance(JavamailService__BeanDefinitions.java:31) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[javamail:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:735) ~[javamail:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:431) ~[javamail:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[javamail:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1307) ~[javamail:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1296) ~[javamail:3.0.0-SNAPSHOT] 	at com.example.javamail.JavamailApplication.main(JavamailApplication.java:10) ~[javamail:0.0.1-SNAPSHOT] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mailSender': Instantiation of supplied bean failed 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1234) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1374) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1294) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArgument(AutowiredInstantiationArgumentsResolver.java:302) ~[na:na] 	... 22 common frames omitted Caused by: java.lang.IllegalStateException: Could not load specified MIME type mapping file: class path resource [org/springframework/mail/javamail/mime.types] 	at org.springframework.mail.javamail.ConfigurableMimeFileTypeMap.getFileTypeMap(ConfigurableMimeFileTypeMap.java:126) ~[na:na] 	at org.springframework.mail.javamail.ConfigurableMimeFileTypeMap.afterPropertiesSet(ConfigurableMimeFileTypeMap.java:110) ~[na:na] 	at org.springframework.mail.javamail.JavaMailSenderImpl.(JavaMailSenderImpl.java:115) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.boot.autoconfigure.mail.MailSenderPropertiesConfiguration.mailSender(MailSenderPropertiesConfiguration.java:44) ~[javamail:0.0.1-SNAPSHOT] 	at org.springframework.boot.autoconfigure.mail.MailSenderPropertiesConfiguration__BeanDefinitions.lambda$getMailSenderInstance$0(MailSenderPropertiesConfiguration__BeanDefinitions.java:41) ~[na:na] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:63) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:51) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:156) ~[na:na] 	at org.springframework.boot.autoconfigure.mail.MailSenderPropertiesConfiguration__BeanDefinitions.getMailSenderInstance(MailSenderPropertiesConfiguration__BeanDefinitions.java:41) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[javamail:6.0.0-SNAPSHOT] 	... 34 common frames omitted Caused by: java.io.FileNotFoundException: class path resource [org/springframework/mail/javamail/mime.types] cannot be opened because it does not exist 	at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:183) ~[javamail:6.0.0-SNAPSHOT] 	at org.springframework.mail.javamail.ConfigurableMimeFileTypeMap.createFileTypeMap(ConfigurableMimeFileTypeMap.java:149) ~[na:na] 	at org.springframework.mail.javamail.ConfigurableMimeFileTypeMap.getFileTypeMap(ConfigurableMimeFileTypeMap.java:123) ~[na:na] 	... 43 common frames omitted ```  There's a resource hint missing.","closed","theme: aot,","mhalbritter","2022-06-23T14:58:38Z","2022-06-23T17:05:34Z"
"","27928","Gradle apiDiff task does not work against a milestone","Running `./gradlew apiDiff -PbaselineVersion=6.0.0-M1` leads to:  ``` Starting a Gradle Daemon (subsequent builds will be faster) > Task :spring-instrument:apiDiff FAILED > Task :spring-jcl:apiDiff FAILED  FAILURE: Build completed with 2 failures.  1: Task failed with an exception. ----------- * What went wrong: Execution failed for task ':spring-instrument:apiDiff'. > Could not resolve all files for configuration ':detachedConfiguration9'.    > Could not find org.springframework:spring-instrument:6.0.0-M1.      Searched in the following locations:        - https://repo.maven.apache.org/maven2/org/springframework/spring-instrument/6.0.0-M1/spring-instrument-6.0.0-M1.pom        - https://repo.spring.io/libs-spring-framework-build/org/springframework/spring-instrument/6.0.0-M1/spring-instrument-6.0.0-M1.pom      Required by:          project :  * Try: > Run with --stacktrace option to get the stack trace. > Run with --info or --debug option to get more log output. > Run with --scan to get full insights. ==============================================================================  2: Task failed with an exception. ----------- * What went wrong: Execution failed for task ':spring-jcl:apiDiff'. > Could not resolve all files for configuration ':detachedConfiguration10'.    > Could not find org.springframework:spring-jcl:6.0.0-M1.      Searched in the following locations:        - https://repo.maven.apache.org/maven2/org/springframework/spring-jcl/6.0.0-M1/spring-jcl-6.0.0-M1.pom        - https://repo.spring.io/libs-spring-framework-build/org/springframework/spring-jcl/6.0.0-M1/spring-jcl-6.0.0-M1.pom      Required by:          project :  * Try: > Run with --stacktrace option to get the stack trace. > Run with --info or --debug option to get more log output. > Run with --scan to get full insights. ==============================================================================  * Get more help at https://help.gradle.org  Deprecated Gradle features were used in this build, making it incompatible with Gradle 8.0.  You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins.  See https://docs.gradle.org/7.3.3/userguide/command_line_interface.html#sec:command_line_warnings  BUILD FAILED in 15s 31 actionable tasks: 8 executed, 4 from cache, 19 up-to-date ```  Adding the milestone repo manually fixes the problem.","closed","type: task,","snicoll","2022-01-13T10:47:00Z","2022-01-13T11:28:48Z"
"","28025","Improve CollectionFactory to allow for single statement collection creation","Right now `CollectionFactory` allows to create a collection type, trying to find the most suitable implementation based on an concrete instance.   We have some use cases in AOT where we'd like to be able to streamline the creation of a collection in a single statement. We've tried something along those lines:  ```java Stream.of(new RuntimeBeanReference(""myCommandHandler"")).collect(Collectors.toCollection(ManagedList::new)) ```  Unfortunately the indirection with the collector can easily confuse the compiler. A more direct use where the `collectionFactory` would be provided with a bunch of elements could be nice.","open","type: enhancement,","snicoll","2022-02-10T09:27:47Z","2022-07-12T07:48:09Z"
"","28404","Caching HttpStatus/Series instances by int key","Reusing same solution of org.springframework.web.socket.sockjs.transport.TransportType to avoid a loop and allocations of Enum.values().","closed","status: declined,","dfa1","2022-05-01T20:06:33Z","2022-05-10T08:42:47Z"
"","28263","Refine PropertyDescriptor filtering","Restrict property paths under `Class` and properties of types `ClassLoader` or `ProtectionDomain`.  Closes gh-28260","closed","status: declined,","luozhenyu","2022-03-31T11:19:34Z","2022-03-31T11:22:01Z"
"","28741","in asynchronous tasks use request.getParameter(),  It may cause the next ""get request"" to fail to obtain parameters","reproduce project link : https://github.com/toohandsome/springdemo/  Spring Boot version: 2.7.1  ```xml      org.springframework.boot     spring-boot-starter       org.springframework.boot     spring-boot-starter-web  ```  demo:  ```java     @Autowired     private RestTemplate restTemplate;      @GetMapping(""/runTest"")     public String runTest() {          new Thread(new Runnable() {             @Override             public void run() {                 for (; ; ) {                     try {                         HttpHeaders headers = new HttpHeaders();                         MultiValueMap map = new LinkedMultiValueMap<>();                         map.add(""name"", ""xiaoming"");                         map.add(""age"", ""123456"");                         headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);                         HttpEntity> param = new HttpEntity<>(map, headers);                         ResponseEntity response = restTemplate.postForEntity(""http://127.0.0.1:8080/postTest"", param, String.class);                     } catch (Exception e) {                         e.printStackTrace();                     }                 }             }         }).start();           new Thread(new Runnable() {             @Override             public void run() {                 for (; ; ) {                     try {                         HashMap objectObjectHashMap = new HashMap<>();                         objectObjectHashMap.put(""a"", ""1"");                         objectObjectHashMap.put(""b"", ""1"");                         ResponseEntity response = restTemplate.getForEntity(""http://127.0.0.1:8080/getParams?a={a}&b={b}"", String.class, objectObjectHashMap);                     } catch (Exception e) {                         e.printStackTrace();                     }                 }             }         }).start();         return ""run success"";     }       @GetMapping(""/getParams"")     public String getParams(String a, int b) {         return ""get success"";     }       @PostMapping(""/postTest"")     public String postTest(HttpServletRequest request) {         String age1 = request.getParameter(""age"");         String name1 = request.getParameter(""name"");         new Thread(new Runnable() {             @Override             public void run() {                 String age2 = request.getParameter(""age"");                 String name2 = request.getParameter(""name"");                 try {                     Thread.sleep(200);                 } catch (InterruptedException e) {                     throw new RuntimeException(e);                 }                 age2 = request.getParameter(""age"");                 name2 = request.getParameter(""name"");             }         }).start();         return ""post success"";     }  ```  call runtest method with browser, it will get error msg like this:  ``` java.lang.IllegalStateException: Optional int parameter 'b' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type ```  ![image](https://user-images.githubusercontent.com/46422252/176940942-3d328f1d-9778-4622-9def-f954c4cc90d3.png)   I found it was because  ``` org.springframework.web.method.annotation.RequestParamMethodArgumentResolver#resolveName ``` return a null value.   ![image](https://user-images.githubusercontent.com/46422252/176942039-4a2b8ab2-f84f-48b7-b8a3-072b58b1d173.png)   Based on further analysis, i found   ``` org.apache.tomcat.util.http.Parameters#handleQueryParameters ```  this method parsing parameters found didQueryParameters is true ,Tomcat thinks that the parameter has been resolved.  Can we handle it in this case?   When the RequestParamMethodArgumentResolver cannot get the parameters from the NativeWebRequest, try to get them from query string?","closed","status: invalid,","toohandsome","2022-07-01T17:33:17Z","2022-07-08T13:38:52Z"
"","28810","Fix Kotlin code snippets language","Replace `[source,java,indent=0,subs=""verbatim,quotes"",role=""secondary""]` by `[source,kotlin,indent=0,subs=""verbatim,quotes"",role=""secondary""]` in the asciidoc documentation.","closed","type: documentation,","sdeleuze","2022-07-13T07:20:41Z","2022-07-13T08:14:50Z"
"","28420","Remove Log4J initialization from package-info.java in spring-web","Remove Log4J initialization from package-info.java as Log4jConfigListener and Log4jWebConfigurer have been removed from since 5.0.x","closed","in: web,","nealshan","2022-05-05T12:21:25Z","2022-05-05T14:16:06Z"
"","28411","Remove Log4J configurer from package-info.java in spring-core","Remove Log4J configurer from package-info.java as Log4jConfigurer has been removed sicne spring5.0.x.","closed","in: core,","nealshan","2022-05-04T03:26:25Z","2022-05-05T14:24:07Z"
"","28104","remove unnecessary imports","remove java.io.Serializable","closed","","dawn9117","2022-02-25T00:56:41Z","2022-02-25T01:00:40Z"
"","28863","Remove clear() call to release method of WeakEntryReference and SoftEntryReference","Remove `clear()` call to release method of `WeakEntryReference` and `SoftEntryReference`.  The code of the same behavior as the `clear` method is included inside the `enqueue` method.  java.lang.ref.Reference  ```java     /**      * Clears this reference object.  Invoking this method will not cause this      * object to be enqueued.      *      *  This method is invoked only by Java code; when the garbage collector      * clears references it does so directly, without invoking this method.      */     public void clear() {         this.referent = null;     }      /**      * Clears this reference object and adds it to the queue with which      * it is registered, if any.      *      *  This method is invoked only by Java code; when the garbage collector      * enqueues references it does so directly, without invoking this method.      *      * @return   true if this reference object was successfully      *           enqueued; false if it was already enqueued or if      *           it was not registered with a queue when it was created      */     public boolean enqueue() {         this.referent = null;         return this.queue.enqueue(this);     } ```","open","type: enhancement,","bcc829","2022-07-25T05:25:12Z","2022-07-31T05:09:26Z"
"","27953","Adds customization option for Executors coming from AsyncConfigurers","Related to https://github.com/spring-projects/spring-boot/issues/29151 Required by https://github.com/spring-cloud/spring-cloud-sleuth/issues/2100  cc @snicoll @wilkinsona","open","in: core,","marcingrzejszczak","2022-01-19T13:48:40Z","2022-05-23T14:24:03Z"
"","28395","Add header resolver for HttpExchange method","Related to #28386","closed","type: enhancement,","OlgaMaciaszek","2022-04-28T19:58:02Z","2022-05-03T11:43:35Z"
"","28842","Reintroduce Javadoc links to Apache HttpClient 5.1 APIs","Reintroduce commented out Javadoc links to Apache website which are now working  Closes #28811","closed","type: task,","adrianbob","2022-07-19T12:24:46Z","2022-07-19T13:40:19Z"
"","28482","redundancy judgment","redundancy judgment of  handlerMappings in  handlePreFlight","closed","status: declined,","ShijunDeng","2022-05-19T06:45:17Z","2022-05-19T06:59:11Z"
"","28687","Support Connection.getMetadata() on LazyConnectionDataSourceProxy","reduce unnecessary connect request when get database metadata.","open","status: waiting-for-triage,","laststem","2022-06-23T14:17:08Z","2022-07-31T05:10:17Z"
"","28084","Introduce DurationEditor for java.time.Duration support","Recently, in a project that is using spring-framework (no spring-boot), I saw a `@Configuration` class with  a lot of configuration about timeouts injected as plain `long` (most likely milliseconds but it is not explicitly documented, as often it happens):  ``` @Value(""${connect.timeout}"") long connectTimeout; ```  With this small patch, it would be possible to directly inject a `Duration`:  ``` @Value(""${connect.timeout}"") Duration connectTimeout; ```  In my opinion, this is less error prone, as usually these configuration values must be adjusted with some calculations (i.e. seconds to milliseconds).  This patch allows two formats: - ISO 8601 format with PT prefix, e.g. `PT10s`, `PT1m30s` (as `Duration.parse`); - simplified format without PT prefix, e.g. `10s`, `1m`, `2h` (IMHO this format is very readable for properties files).  Comments and feedback is welcome. I'm not sure about using a property editor, perhaps a `Converter` is a better choice? And I'm not sure if this should be mentioned somewhere in the spring-reference... please advice :-)","open","in: core,","dfa1","2022-02-20T20:35:43Z","2022-05-05T13:57:12Z"
"","28893","How to make @Exceptionhandler execute without sorting by Map","Recently, I want to use @Exceptionhandler to handle different exceptions, but I found that HttpMediaTypeException and UnsupportedMediaTypeException were not handled by my UnsupportedMediaTypeExceptionHandler,  ![_) 8WWZ~RMFRPDFZ9R%15 8](https://user-images.githubusercontent.com/69103691/181920507-ec72481b-5349-4dae-8f14-6ae6622206f2.png)  but caught by my UnexpectedExceptionHandlerHandler ![R%3_LLD3Q_1@$}V3%L%V62P](https://user-images.githubusercontent.com/69103691/181920520-9b2eecd4-d11f-40de-a205-aaa269c2ad68.png)  Then I found the reason is ExceptionHandlerExceptionResolver.getExceptionHandlerMethod(@Nullable HandlerMethod handlerMethod, Exception exception)  when processing, ![AOO2_@N ~RM0~O ~0S7C}A](https://user-images.githubusercontent.com/69103691/181920668-e656ca5f-4306-49e3-a7f3-37b6012288e4.png)  it executed in sequence according to the key order of the Map ![0B$%88{MVF@O6S$9E%Q7}PR](https://user-images.githubusercontent.com/69103691/181920651-5f66ba1f-4257-4969-958e-50ac962db250.png)  The UnexpectedExceptionHandlerHandler was catch any exception, and it was in front of the UnsupportedMediaTypeExceptionHandler. That's why it caused such a tragedy, so I want to ask how to make my UnexpectedExceptionHandlerHandler execute finally.  At present, my method is to rename my UnexpectedExceptionHandlerHandler to ZzUnexpectedExceptionHandlerHandler to ensure its final execution😀😀😀","closed","status: invalid,","RovingSea","2022-07-30T15:19:59Z","2022-08-01T12:40:03Z"
"","28820","Loss of context path after using ServerRequest.from","Recently I found a strange behaviour after adding a Filter to our project that uses `ServerRequest.from`. After I added the filter the contextPath was gone and the pathWithinApplication contained the full path.  As we are using a reverse Proxy and want to return correct location headers we are dependent on the contextPath set by the `ForwardedHeaderTransformer`.  My question is if this is intended behaviour or is this a bug in the framework.  I think I found the culprit of this behaviour [here](https://github.com/spring-projects/spring-framework/blob/963fd75aff06f903195448bf6e4a760e65b3a908/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/DefaultServerRequestBuilder.java#L213): ``` public BuiltServerHttpRequest(String id, HttpMethod method, URI uri, HttpHeaders headers, 				MultiValueMap cookies, Flux body) { 			this.id = id; 			this.method = method; 			this.uri = uri; 			this.path = RequestPath.parse(uri, null); 			this.headers = HttpHeaders.readOnlyHttpHeaders(headers); 			this.cookies = unmodifiableCopy(cookies); 			this.queryParams = parseQueryParams(uri); 			this.body = body; 		} ``` in the `this.path = RequestPath.parse(uri, null);` where the context path is explicitly set to null.  The issue looks similar to https://github.com/spring-projects/spring-framework/issues/25279 where the behaviour was fixed for mutating ServerHttpRequests","closed","type: bug,","danielrehmann","2022-07-14T10:54:37Z","2022-07-14T13:25:58Z"
"","28170","Polish Javadoc for Environment","Reading the Javadoc of `org.springframework.core.env.Environment`, I found that there are some missing `{@code}` tag for `Environment`. This PR fixes them by adding the missing `{@code}` tags.","closed","type: task,","gorisanson","2022-03-12T07:49:30Z","2022-03-13T02:30:07Z"
"","28847","Support for Netty 5","Reactor Netty 2.0 milestones are already tracking Netty 5, see https://github.com/reactor/reactor-netty/issues/1873 and related issues. We need to add server side adapters and a client connector for the same in the Spring Framework. There is also a new buffer API.  - [ ] #28874","open","type: enhancement,","rstoyanchev","2022-07-21T14:32:34Z","2022-07-26T09:41:20Z"
"","27936","Instrument webmvc","Questions/todo items: - Error handling might be more tricky than this - Controller class/method tag is missing from the span - Integrating with Micrometer's new http tag provider - Consolidating tags (e.g.: we have `method` and `http.method`) - Add tests - Do we want to keep LongtaskTimer here?","open","status: waiting-for-triage,","jonatan-ivanov","2022-01-15T00:11:21Z","2022-02-18T20:01:17Z"
"","28134","LocalDataSourceJobStore for Quartz should not invoke setDontSetAutoCommitFalse(true)","Quartz locks SQL using `select xxxx for update` when `useDBLocks` is `true`. (https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/java/org/quartz/impl/jdbcjobstore/StdRowLockSemaphore.java)  And `dontSetAutoCommitFalse` is default use false in `JobStoreSupport` class. (https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/java/org/quartz/impl/jdbcjobstore/JobStoreSupport.java)  But Spring Framework invokes `setDontSetAutoCommitFalse(true)` with `springTxDataSource`.  https://github.com/spring-projects/spring-framework/blob/68757073b0cf69c41d5c17e8abdffbc388cdbabe/spring-context-support/src/main/java/org/springframework/scheduling/quartz/LocalDataSourceJobStore.java#L101-L103  and Quartz code is:  ```java             if (!isDontSetAutoCommitFalse()) {                 conn.setAutoCommit(false);             } ```  (code in https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/java/org/quartz/impl/jdbcjobstore/JobStoreSupport.java, line 803)  the `executeInLock` method code is   ```java     @Override     protected Object executeInLock(             String lockName,              TransactionCallback txCallback) throws JobPersistenceException {         boolean transOwner = false;         Connection conn = null;         try {             if (lockName != null) {                 // If we aren't using db locks, then delay getting DB connection                  // until after acquiring the lock since it isn't needed.                 if (getLockHandler().requiresConnection()) {                     conn = getConnection();                 }                                  transOwner = getLockHandler().obtainLock(conn, lockName);             }              if (conn == null) {                 conn = getConnection();             }              return txCallback.execute(conn);         } finally {             try {                 releaseLock(lockName, transOwner);             } finally {                 cleanupConnection(conn);             }         }     } ```  (code in https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/java/org/quartz/impl/jdbcjobstore/JobStoreCMT.java, line 225)  In MySQL, `select for update ` need run in a transaction; see: https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html  but now is not begin transaction for run `TransactionCallback`.  So spring framework need remove this code or change to the following:  ```java // Configure transactional connection settings for Quartz. 		setDataSource(TX_DATA_SOURCE_PREFIX + getInstanceName()); 		setDontSetAutoCommitFalse(false);//bug fix need changeto false for transactional connection   		// Register transactional ConnectionProvider for Quartz. 		DBConnectionManager.getInstance().addConnectionProvider( 				TX_DATA_SOURCE_PREFIX + getInstanceName(), 				new ConnectionProvider() { 					@Override 					public Connection getConnection() throws SQLException { 						// Return a transactional Connection, if any. 						return DataSourceUtils.doGetConnection(dataSource); 					} 					@Override 					public void shutdown() { 						// Do nothing - a Spring-managed DataSource has its own lifecycle. 					} 					@Override 					public void initialize() { 						// Do nothing - a Spring-managed DataSource has its own lifecycle. 					} 				} 		);  		// Non-transactional DataSource is optional: fall back to default 		// DataSource if not explicitly specified. 		DataSource nonTxDataSource = SchedulerFactoryBean.getConfigTimeNonTransactionalDataSource(); 		final DataSource nonTxDataSourceToUse = (nonTxDataSource != null ? nonTxDataSource : this.dataSource);  		// Configure non-transactional connection settings for Quartz. 		setNonManagedTXDataSource(NON_TX_DATA_SOURCE_PREFIX + getInstanceName()); if(nonTxDataSource != null  ){ 		setDontSetAutoCommitFalse(true);// bug fix need changeto true for none transactional connectio } ```","open","status: feedback-provided,","lizongbo","2022-03-04T02:45:17Z","2022-03-05T10:11:10Z"
"","28575","Provide a way to request a WebSession without creating one","Provide a way to request a session without creating one. Please see https://github.com/spring-projects/spring-framework/issues/26958 for details  Note that this is intended to track the change mentioned in https://github.com/spring-projects/spring-framework/issues/26958#issuecomment-856986682  > We can explore a more optimal, longer term solution for 6.0, such as new methods on WebSession and ServerWebExchange or perhaps a non-blocking id generator if that's even feasible.","open","type: enhancement,","rwinch","2022-06-06T21:35:07Z","2022-06-07T09:32:17Z"
"","28726","Missing documentation for spring.spel.ignore and spring.xml.ignore","Properties `spring.spel.ignore` (https://github.com/spring-projects/spring-framework/issues/25153) and `spring.xml.ignore` (https://github.com/spring-projects/spring-framework/issues/25151) are not documented. Other similar properties are documented in the appendix https://docs.spring.io/spring-framework/docs/current/reference/html/appendix.html so I think it would make sense to add these there as well.","open","type: documentation,","joca-bt","2022-06-29T09:41:05Z","2022-07-01T13:59:13Z"
"","28487","Add support for programmatically registered beans in AOT","Programmatically registered beans are currently not supported by AOT. It is an important issue for Spring Cloud, as we rely on registering beans in the Bootstrap context. A related [issue](https://github.com/spring-projects-experimental/spring-native/issues/1606) has been created in spring-native, but since it's not going to be addressed within spring-native backlog, I'm opening one here as well.  The issue became apparent after merging [this commit](https://github.com/spring-cloud/spring-cloud-config/pull/2065) intended as a bug fix for [another issue](https://github.com/spring-projects-experimental/spring-native/issues/1516).  Log related to this issue: ```  *************************** APPLICATION FAILED TO START ***************************  Description:  Parameter 0 of method singleTextEncryptorLocator in org.springframework.cloud.config.server.config.EncryptionAutoConfiguration required a single bean, but 2 were found: 	- defaultTextEncryptor: defined in null 	- textEncryptor: a programmatically registered singleton ```","closed","status: invalid,","OlgaMaciaszek","2022-05-19T15:15:06Z","2022-05-20T14:08:01Z"
"","28243","BeanPropertyRowMapper's support for direct column name matches is missing in DataClassRowMapper","Presently [DataClassRowMapper](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-jdbc/src/main/java/org/springframework/jdbc/core/DataClassRowMapper.java#L101)  appears to _assume_ that all database columns use `snake_case`  Say I have a kotlin class like: ``` data class MyClass(val myFoo: String, val myBar: String) ```  and a database table with columns `myFoo, myBar`  a naive selection like  ``` select myFoo, myBar FROM ... ```  will fail, because the mapper will expect the columns to be named with underscores.   This can be worked around by adding aliases with underscores: ``` select myFoo as my_foo, myBar as my_bar FROM ... ```  But this is less than ideal. Ideally this would be configurable and support a few standard formats out of the box, e.g. `snake_case`, `camelCase`, `PascalCase`.","closed","type: bug,","madorb","2022-03-28T21:45:33Z","2022-04-08T11:26:56Z"
"","28266","Incorrect ResolvedType of RestController RequestBody argument","Please see attached code, Seems that type is incorrectly resolved for controller method's RequestBody argument. In case we have one level of inheritance, type resolved correctly. In case we have two or more levels of inheritance, type resolved incorrectly.  For example, in scenario in which type gets resolved correctly in all cases, I would expect to get the string ""ConcreteType"" as a result for triggering all following apis: * https://localhost:.../working/type1 * https://localhost:.../working/type2 * https://localhost:.../not_working/type1 * https://localhost:.../not_working/type2  However, 'working' path yields the correct result - ""ConcreteType"", while 'not_working' path yields the wrong result - ""AbstractType"".  dependencies: spring-boot-starter:2.6.1 spring-boot-starter-web:2.6.1 spring-boot-starter-undertow:2.6.1 spring-web:5.3.13  ``` public class AbstractType {     private String id;      public String getId()     {         return id;     } } ```  ``` public class ConcreteType extends AbstractType {     private String name;      public String getName()     {         return name;     } } ```  ``` @RestController @RequestMapping(value = ""/not_working"", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) public class NotWorkingConcreteAPI extends SingleParameterizedGenericAPI { } ```  ``` @RestController @RequestMapping(value = ""/working"", produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE) public class WorkingConcreteAPI extends MultiParameterizedGenericAPI { } ```  ``` public abstract class SingleParameterizedGenericAPI extends MultiParameterizedGenericAPI { } ```  ``` public class MultiParameterizedGenericAPI {     @PostMapping(""/type1"")     public String type1(@RequestBody TYPE_1 t1)     {         return t1.getClass().getSimpleName();     }      @PostMapping(""/type2"")     public String type2(@RequestBody TYPE_2 t2)     {         return t2.getClass().getSimpleName();     } } ```","closed","in: web,","goldami1","2022-03-31T16:40:41Z","2022-04-18T13:42:35Z"
"","28124","Add consumeListWith() to KotlinBodySpec>","Please add something like the following method to `KotlinBodySpec` in `org.springframework.test.web.reactive.server`:  ```kotlin     fun  KotlinBodySpec>.consumeListWith(consumer: (List) -> Unit): KotlinBodySpec> {         return consumeWith { result ->             consumer(result.responseBody!!)         }     } ```  So that instead of the usual:  ```kotlin     expectBody>().consumeWith { result ->                 val list = result.responseBody!!                 assertThat(list).... ```  We could then simply write:  ```kotlin     expectBody>().consumeListWith { list ->                 assertThat(list).... ```                  At least I wouldn't know what else to do with an `EntityExchangeResult` anyway, except for well get the actual result from it.","closed","in: kotlin,","lathspell","2022-03-02T15:32:16Z","2022-03-16T08:48:31Z"
"","28067","decoding exception ""Could not find end of the body"" Spring-boot webflux fucntional route multipart file upload not working from angular/chrome/browser agents","Parts coming as null, where as same working when uploading from postman, but it failing from angular/chrome agent and verified the request b/w postman and chrome both are similar  Code:  ```java public Mono uploadDocument(ServerRequest request) {      return request         .body(BodyExtractors.toMultipartData())         .map(             parts -> {               log.info(""parts size  "" + parts.size());               Map formParts = parts.toSingleValueMap();               log.error(""Form data parts "" + formParts.toString());               FormFieldPart uploadFormField = (FormFieldPart) formParts.get(""fileUploadModel"");               log.error(""Form field value "" + uploadFormField.toString());               FilePart file = (FilePart) formParts.get(""file"");               FileUploadModel fileUpload = fileUploadModelVO(uploadFormField);               return uploadDocumentService.uploadFile(fileUpload, file).map(this::documentMapper);             })         .flatMap(             document ->                 ServerResponse.ok()                     .contentType(MediaType.APPLICATION_JSON)                     .body(document, FileUploadModel.class));   } ```  Parts coming as null, where as same working when uploading from postman, but it failing from angular/chrome agent and verified the request b/w postman and chrome both are similar  ```java  public Mono uploadDocument(ServerRequest request) {      return request         .body(BodyExtractors.toMultipartData())         .map(             parts -> {               log.info(""parts size  "" + parts.size());               Map formParts = parts.toSingleValueMap();               log.error(""Form data parts "" + formParts.toString());               FormFieldPart uploadFormField = (FormFieldPart) formParts.get(""fileUploadModel"");               log.error(""Form field value "" + uploadFormField.toString());               FilePart file = (FilePart) formParts.get(""file"");               FileUploadModel fileUpload = fileUploadModelVO(uploadFormField);               return uploadDocumentService.uploadFile(fileUpload, file).map(this::documentMapper);             })         .flatMap(             document ->                 ServerResponse.ok()                     .contentType(MediaType.APPLICATION_JSON)                     .body(document, FileUploadModel.class));   } ```  Postman Request:  ``` Warning: Self signed certificate in certificate chain POST /eap/consultation/document/uploadDocument/ HTTP/1.1 User-Agent: PostmanRuntime/7.28.4 Accept: */* Postman-Token: f98a5224-a2f3-4609-b2e5-219a03cc6b82 Host: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Accept-Encoding: gzip, deflate, br Connection: keep-alive Content-Type: multipart/form-data; boundary=------------------------- -019436366390284846853277 Content-Length: 178369 ----------------------------019436366390284846853277 Content-Disposition: form-data; name=""file""; filename=""Gmail - Your Zomato order from Pista House (1).PDF""  ----------------------------019436366390284846853277 Content-Disposition: form-data; name=""fileUploadModel"" { ""fileName"":""fileee2ff333"", ""description"": ""url changes"", ""caseId"":""50"" } ----------------------------019436366390284846853277-- ```  Chrome Request: ``` POST /eap/consultation/document/uploadDocument HTTP/1.1 Host: xxxxxxxxxxxxxxxxxxxxxx Connection: keep-alive Content-Length: 178351 sec-ch-ua: ""Google Chrome"";v=""95"", ""Chromium"";v=""95"", "";Not A Brand"";v=""99"" Accept: */* Content-Type: multipart/form-data; boundary=----WebKitFormBoundarySwprz3OeLnKlYLf8 sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 sec-ch-ua-platform: ""Windows"" Origin: https:/********************* Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://*************************** Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9 ------WebKitFormBoundaryCXUDq20q3OAAg1eO Content-Disposition: form-data; name=""file""; filename=""Food-bill.pdf"" Content-Type: application/pdf ------WebKitFormBoundaryCXUDq20q3OAAg1eO Content-Disposition: form-data; name=""fileUploadModel"" {""caseId"":1011,""description"":"""",""fileName"":""Food-bill.pdf""} ------WebKitFormBoundaryCXUDq20q3OAAg1eO-- ```  Service configuration: ``` @Configuration @EnableWebFlux public class ConsultationServWebConfig implements WebFluxConfigurer {    @Override   public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {     SynchronossPartHttpMessageReader partReader = new SynchronossPartHttpMessageReader();     partReader.setEnableLoggingRequestDetails(true);      MultipartHttpMessageReader multipartReader = new MultipartHttpMessageReader(partReader);     multipartReader.setEnableLoggingRequestDetails(true);      configurer.defaultCodecs().multipartReader(multipartReader);   }    @Override   public void addCorsMappings(CorsRegistry registry) {     registry.addMapping(""/**"").allowedHeaders(""*"").allowedMethods(""*"").allowedOrigins(""*"");   } } ```  With SynchronossPartHttpMessageReader parts coming as null from angular where as same working from postman.  DefaultPartHttpMessageReader giving decoding exception could not find end of the body where as same working from postman","open","status: feedback-provided,","bsreddy125","2022-02-17T07:56:11Z","2022-03-01T19:27:46Z"
"","27905","Fix SpEL propertyReadWriteWithRootObject() test","Partially modify PropertyAccessTests#propertyReadWriteWithRootObject. The test case is for method 'withRootObject' but actually it's copied for the previous case.","closed","in: core,","justlikeliuen","2022-01-08T02:56:50Z","2022-01-08T16:09:49Z"
"","28028","Add core JavaPoet utilities","Our prototype with Spring Native has shown that working with multiple statements and/or code blocks can lead to repetitive code. Also, JavaPoet does not resolve imports on code snippet so that makes code assertion a bit awkward.   this issue is about porting those utilities in `spring-core` so that we can benefit from it.","closed","theme: aot,","snicoll","2022-02-10T13:46:35Z","2022-02-10T15:02:31Z"
"","28550","Always construct new exception on error in DefaultWebClient","Otherwise memory leak may occur due to repeated use of singleton exception. This is due to the ability for Throwable to contain a list of suppressed exceptions (and therefore being mutable) and the list to grow indefinitely.","closed","type: bug,","pokab","2022-06-01T00:45:54Z","2022-06-01T14:33:28Z"
"","28746","Fix GenericApplicationContextTests on Microsoft Windows","origin unit test will cause bug when get a resource with unknown protocol   Related to:  - #28703  - commit 9868c28c737cfadc50f029887e029155b2b2085d","closed","in: core,","jasonjiang9527","2022-07-02T14:34:39Z","2022-07-05T09:27:39Z"
"","28206","In the case of code redundancy, package scanning is performed in the spring container...","org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider In spring5.3.x, there is code redundancy. During package scanning, when parsing class meta information, when creating a ScannedGenericBeanDefinition object, its constructor has set the source attribute. But after creating it, set it up again。It's still the same in the latest version","open","in: core,","AssumeJson","2022-03-21T14:26:28Z","2022-04-25T09:53:04Z"
"","28106","spring-core 5.3.16 Unknown class appears","org.springframework.cglib.beans.BeanMap.Generator#generateClass as the picture shows ![image](https://user-images.githubusercontent.com/50291874/155638503-9dd07858-d072-43aa-969e-81f2a96aa4c0.png) @spring-projects-issues","closed","for: stackoverflow,","livk-cloud","2022-02-25T01:52:22Z","2022-02-25T07:42:16Z"
"","28539","The value of method parameter may be reversed","org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#registerDependentBean ![image](https://user-images.githubusercontent.com/18898924/170870624-d06f1c67-1dbe-4434-9230-240fadeab339.png)  ![image](https://user-images.githubusercontent.com/18898924/170870604-a3ad8658-8730-4621-a6fe-227a87d5ca8e.png)","open","status: waiting-for-triage,","HaimiZhou","2022-05-29T13:15:16Z","2022-05-29T13:20:16Z"
"","27900","Simplify HashMap declaration in test fixture","Optimize the initialization of hashmap","closed","type: task,","springmonster","2022-01-07T02:08:56Z","2022-01-07T09:25:23Z"
"","28549","Optimize SpEL and property placeholder support for @Async qualifiers","optimize spel in AsyncExecutionAspectSupport","open","status: feedback-provided,","dawn9117","2022-05-31T23:54:50Z","2022-06-20T13:07:32Z"
"","28189","Support ""application/problem+json"" as the response Content-Type","Once  #28187 provides `ProblemDetail` along with the `ErrorResponse` hierarchy of exceptions that encapsulate HTTP status, headers, and body, to support RFC 7807, it is also necessary to improve content negotiation and formatting specifically for error responses.  In Spring MVC it is possible to configure [content type resolution](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation) and [message conversion](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-message-converters) and likewise in WebFlux to configure [content type resolution](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-content-negotiation) and [message codecs](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-config-message-codecs), but those apply to both `@RequestMapping` and `@ExceptionHandler` methods.   Error handling however has a different perspective. The range of supported media types might be more limited and different, e.g. only `application/problem+json`. The resolution of the request content type might also be done differently, .e.g. defaulting to `application/problem+json` if not explicitly requested, or perhaps even enforcing it.  Such a mechanism is also a convenient place for other configuration related to how `ProblemDetail` should be rendered..","closed","type: enhancement,","rstoyanchev","2022-03-16T18:20:15Z","2022-05-09T17:32:48Z"
"","28567","Introduce attribute support in Kotlin RouterFunction DSL","On current spring framework version (5.3.19), RouterFunction **attributes** are **not supported** by RouterFunction Kotlin **DSL**.   RouterFunction attributes is currently supported by Java Builder : - https://github.com/spring-projects/spring-framework/blob/172102d225c916e2ca24b87aa0f0a74d824815b2/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RouterFunctionBuilder.java#L335 - https://github.com/spring-projects/spring-framework/blob/172102d225c916e2ca24b87aa0f0a74d824815b2/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RouterFunctionBuilder.java#L350 - https://github.com/spring-projects/spring-framework/blob/172102d225c916e2ca24b87aa0f0a74d824815b2/spring-webmvc/src/main/java/org/springframework/web/servlet/function/RouterFunctionBuilder.java#L328 - https://github.com/spring-projects/spring-framework/blob/172102d225c916e2ca24b87aa0f0a74d824815b2/spring-webmvc/src/main/java/org/springframework/web/servlet/function/RouterFunctionBuilder.java#L343   But RouterFunction attributes support is missing from all Kotlin DSL : - https://github.com/spring-projects/spring-framework/blob/172102d225c916e2ca24b87aa0f0a74d824815b2/spring-webflux/src/main/kotlin/org/springframework/web/reactive/function/server/RouterFunctionDsl.kt#L65 - https://github.com/spring-projects/spring-framework/blob/172102d225c916e2ca24b87aa0f0a74d824815b2/spring-webflux/src/main/kotlin/org/springframework/web/reactive/function/server/CoRouterFunctionDsl.kt#L66 - https://github.com/spring-projects/spring-framework/blob/172102d225c916e2ca24b87aa0f0a74d824815b2/spring-webmvc/src/main/kotlin/org/springframework/web/servlet/function/RouterFunctionDsl.kt#L62","closed","in: kotlin,","christophejan","2022-06-05T10:47:07Z","2022-06-08T15:10:03Z"
"","28777","InstantiationAwareBeanPostProcessor implementations are not invoked with an AOT-processed context","Obtaining a bean provided by a configuration class that has dependencies caused trouble during AOT processing.  The Boot Configuration for `JdbcRepositoriesAutoConfiguration` contains a conditional configuration class `SpringBootJdbcConfiguration` depending on the `ApplicationContext`.  ```java @Configuration(proxyBeanMethods = false) @ConditionalOnMissingBean(AbstractJdbcConfiguration.class) static class SpringBootJdbcConfiguration extends AbstractJdbcConfiguration {      private final ApplicationContext applicationContext;      SpringBootJdbcConfiguration(ApplicationContext applicationContext) {         this.applicationContext = applicationContext;     }      @Override     protected Set> getInitialEntitySet() throws ClassNotFoundException {         return new EntityScanner(this.applicationContext).scan(Table.class);     }  } ```   The `AbstractJdbcConfiguration` exposes a bean of type `RelationalManagedTypes`  ```java @Bean public RelationalManagedTypes jdbcManagedTypes() throws ClassNotFoundException { 	return RelationalManagedTypes.fromIterable(getInitialEntitySet()); } ```  Obtaining `jdbcManagedTypes` via `registeredBean.getBeanFactory().getBean(registeredBean.getBeanName(), ManagedTypes.class))` within a `BeanRegistrationAotProcessor` errors with    ``` Exception in thread ""main"" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration$SpringBootJdbcConfiguration': Failed to instantiate [org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration$SpringBootJdbcConfiguration]: No default constructor found 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1305) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1197) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) 	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:393) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1323) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1160) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:205) 	at org.springframework.data.aot.ManagedTypesBeanRegistrationAotProcessor.processAheadOfTime(ManagedTypesBeanRegistrationAotProcessor.java:57) ```","closed","theme: aot,","christophstrobl","2022-07-08T10:52:07Z","2022-07-26T07:28:31Z"
"","28151","Update AOT processing to account for multiple init or destroy methods","Now that #28013 is implemented we need to make sure that the bean definition is registered with the appropriate init and destroy method names.","closed","theme: aot,","snicoll","2022-03-09T13:36:55Z","2022-03-12T12:41:15Z"
"","28237","Update copyright date in reference manual","Now is 2022. ![issue](https://user-images.githubusercontent.com/69554233/160265993-49b4bc34-066c-4ff0-bb3a-921950a42f1c.png)","closed","type: documentation,","awxiaoxian2020","2022-03-27T03:57:16Z","2022-03-27T08:06:08Z"
"","28197","Add Node.js file extensions to javascript","Node.js recognizes .mjs as an ES6 module and .cjs as a CommonJS module. Other web servers e.g. in other languages recognize them as well. This change makes the resource handlers in Spring Web work the same with *.mjs as *.js.  Example with Python:  ``` $ curl -v localhost:8000/hello.mjs > /dev/null ... < Content-type: application/javascript < Content-Length: 825 < Last-Modified: Tue, 15 Mar 2022 11:00:54 GMT <  ```","closed","status: declined,","dsyer","2022-03-18T11:38:49Z","2022-03-18T13:48:52Z"
"","28874","Support Netty 5's Buffer API","Netty 5 introduced a new `Buffer` API, replacing Netty 4's `ByteBuf`. We should support this new API through our `DataBuffer` abstraction. New methods and abstractions might be required to capture the semantics of Netty 5's `Buffer`, which are different from Nety 4's `ByteBuf` in some areas.  Parent issue: #28847.","open","type: enhancement,","poutsma","2022-07-26T09:07:53Z","2022-07-26T09:10:39Z"
"","28418","Add RootBeanDefinition constructor that accepts a ResolvableType","Needing to use a builder in order to create a `RootBeanDefinition` with a `ResolvableType` is cumbersome. A new constructor would help simplify things, especially AOT generated code.","closed","type: enhancement,","philwebb","2022-05-05T06:29:05Z","2022-05-11T14:40:46Z"
"","28715","Pass headers to STOMP receipt callbacks","My use case for wanting access to the headers in receipt callbacks is to communicate additional information about the result of processing of a message back to the client.   Relevant parts from the STOMP docs: https://stomp.github.io/stomp-specification-1.2.html#RECEIPT ``` RECEIPT A RECEIPT frame is sent from the server to the client once a server has successfully processed a client frame that requests a receipt. A RECEIPT frame MUST include the header receipt-id, where the value is the value of the receipt header in the frame which this is a receipt for.  RECEIPT receipt-id:message-12345  ^@ A RECEIPT frame is an acknowledgment that the corresponding client frame has been processed by the server. Since STOMP is stream based, the receipt is also a cumulative acknowledgment that all the previous frames have been received by the server. However, these previous frames may not yet be fully processed. If the client disconnects, previously received frames SHOULD continue to get processed by the server. ```   Please let me know if I can improve anything or if you think this requires more discussion up front =)","open","type: enhancement,","napstr","2022-06-27T18:55:53Z","2022-08-02T06:42:07Z"
"","28295","Meet NPE when I call RestTemplate.exchange()","My spring-web version is 5.2.8.RELEASE.  ``` java.lang.NullPointerException: null  at org.springframework.http.server.ServletServerHttpResponse.lambda$writeHeaders$0(ServletServerHttpResponse.java:103)  at java.base/java.util.Map.forEach(Map.java:661)  at org.springframework.http.server.ServletServerHttpResponse.writeHeaders(ServletServerHttpResponse.java:102)  at org.springframework.http.server.ServletServerHttpResponse.flush(ServletServerHttpResponse.java:89)  at org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor.handleReturnValue(HttpEntityMethodProcessor.java:222)  at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82)  at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:123)  at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878)  at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792)  at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)  at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)  at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)  at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)  at org.springframework.web.servlet.FrameworkServlet.doPut(FrameworkServlet.java:920)  at javax.servlet.http.HttpServlet.service(HttpServlet.java:655)  at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)  at javax.servlet.http.HttpServlet.service(HttpServlet.java:733)  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)  at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)  at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126)  at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(OAuth2AuthenticationProcessingFilter.java:176)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92)  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92)  at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77)  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)  at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)  at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)  at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)  at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358)  at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271)  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)  at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)  at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)  at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:93)  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)  at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)  at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)  at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)  at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)  at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)  at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)  at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)  at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)  at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:747)  at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)  at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373)  at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)  at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868)  at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1589)  at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)  at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)  at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)  at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)  at java.base/java.lang.Thread.run(Thread.java:834) ```","closed","","Tao-Zhang-Myob","2022-04-07T05:39:03Z","2022-04-21T10:12:34Z"
"","28221","Can we use ConcurrentHashMap to add BeanDefinition to ConcurrentMap instead of set","My project has one hundred thousand beans+ to initialize into spring. However every time it needs several imnutes to complete its work. I found ClassPathBeanDefinitionScanner.doScan 's code which does work one by one.  So I have a question, because it use Set to collect, can we use ConcurrentHashMap instead of it? That map's value just can use any Object such as new Object to fill it like Set inner code.  My spring version :  5.1.19.  Below is that current release code:   My Suggestion is that:  `protected Set doScan(String... basePackages) {         Assert.notEmpty(basePackages, ""At least one base package must be specified"");         Set beanDefinitions = new LinkedHashSet<>();          ConcurrentHashMap candidates = new ConcurrentHashMap();         Arrays.stream(basePackages).parallel().map(x->{             return   findCandidateComponents(basePackage);                      }).forEach(x->{              candidates.put(x,new Object());         });          for (String basePackage : basePackages) {              for (BeanDefinition candidate : candidates) {                 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);                 candidate.setScope(scopeMetadata.getScopeName());                 String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);                 if (candidate instanceof AbstractBeanDefinition) {                     postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);                 }                 if (candidate instanceof AnnotatedBeanDefinition) {                     AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);                 }                 if (checkCandidate(beanName, candidate)) {                     BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);                     definitionHolder =                             AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);                     beanDefinitions.add(definitionHolder);                     registerBeanDefinition(definitionHolder, this.registry);                 }             }         }         return beanDefinitions;     }`","closed","status: duplicate,","kyangcmXF","2022-03-23T07:45:18Z","2022-03-23T07:53:54Z"
"","28735","Move `BindingReflectionHintsRegistrar` to spring-context","Move `BindingReflectionHintsRegistrar` to `spring-context` module in `org.springframework.context.aot` package because:  - Otherwise we can't test it with the agent that lives in spring-core-test  - Conceptually this is for reflection based serialization like Jackson (that lives in `spring-web`) and databinder (that lives in `spring-context`)","closed","theme: aot,","sdeleuze","2022-06-30T09:53:20Z","2022-06-30T10:10:27Z"
"","28867","Add missing closing parenthesis in reference doc","missing closing parenthesis under ""Any other argument"" section","closed","type: documentation,","arvyy","2022-07-25T10:20:49Z","2022-07-25T11:33:52Z"
"","28683","StackOverflowError when using BindingReflectionHintsRegistrar","Minimal reproducer:  ``` import org.springframework.hateoas.CollectionModel;  public static void main(String[] args) {   BindingReflectionHintsRegistrar reflectionHintsRegistrar = new BindingReflectionHintsRegistrar();   ReflectionHints reflectionHints = new ReflectionHints();   reflectionHintsRegistrar.registerReflectionHints(reflectionHints, CollectionModel.class); } ```  It looks like the `ResolvableType` in the `CollectionModel1` is the problem, as this crashes too:  ``` reflectionHintsRegistrar.registerReflectionHints(reflectionHints, ResolvableType.class); ```","closed","in: core,","mhalbritter","2022-06-23T08:22:47Z","2022-06-23T13:47:28Z"
"","28759","Correctly identify MaxUploadSizeExceededException through keywords in message from Jetty 9.4.x","MaxUploadSizeExceededException is recognized based on the exception message containing the words ""size"" and ""exceed"". Jetty server throws a message  [""Request exceeds maxRequestSize..."".](https://github.com/eclipse/jetty.project/blob/064682b4ce57282e49a80a64b6d7a7a66fb47b28/jetty-util/src/main/java/org/eclipse/jetty/util/MultiPartInputStreamParser.java#L641)  Shouldn't such message also be treated as a MaxUploadSizeExceededException?   The proposed change addresses the issue regarding handling errors for too large file uploads when using the Jetty 9.4.x server. Now it is possible that MultipartException is thrown instead of MaxUploadSizeExceededException when the file exceeds the size limit.","closed","type: enhancement,","kacperkrzyzak","2022-07-05T13:13:08Z","2022-07-13T11:24:35Z"
"","28486","Add support for child contexts in AOT","Many Spring Cloud Projects heavily rely on child contexts. This is currently not supported by AOT. The [issue](https://github.com/spring-projects-experimental/spring-native/issues/766) was raised before in the spring-native repo, however, a decision has been taken to move it over to Spring Framework 6 backlog.","open","status: feedback-provided,","OlgaMaciaszek","2022-05-19T14:56:38Z","2022-06-09T05:43:42Z"
"","28834","Make ResourcePatternHints.Builder.build public","Makes the `ResourcePatternHints.Builder.build()` method public. I assume it's an oversight that it's not public, as the class and all other methods are.","closed","status: invalid,","mhalbritter","2022-07-18T11:45:23Z","2022-07-18T12:02:55Z"
"","28532",".","M","closed","status: invalid,","simplyjustganesh7","2022-05-27T11:09:36Z","2022-05-30T08:06:18Z"
"","28877","Introduce TestGenerationContext","Looking at #28684, it became apparent that `Closeable` wasn't really an option but that we could make `writeGeneratedContent` more prominent and let it throws an `IOException`. This had a knock-off effect on the tests which was easily handled using our internal `TestGenerationContext`.  This impacts obviously tests outside of the Spring Framework so a public variant of it is needed.","closed","theme: aot,","snicoll","2022-07-26T14:49:20Z","2022-07-26T15:56:36Z"
"","28274","Semantic versioning concerns","Like many others, I'm looking at upgrading from Spring 5.3.13 to 5.3.18. According to semantic versioning, that should be a patch upgrade and thus not introduce new or changed APIs or dependencies. However, the diff for `build.gradle` includes the following changes:  - org.jetbrains.dokka 1.5.0 -> 1.6.10  - org.apache.logging.log4j 2.14.1 -> 2.17.2  - io.smallrye.reactive:mutiny 1.1.1 -> 1.4.0  - com.google.protobuf:protobuf-java-util 3.18.0 -> 3.19.3  - com.h2database:h2 1.4.200 -> 2.1.210  - com.rometools:rome 1.16.0 -> 1.18.0  - org.xmlunit 2.8.3 -> 2.9.0  - org.assertj:assertj-core 3.21.0 -> 3.22.0  - org.mockito 4.0.0 -> 4.4.0  - net.sourceforge.htmlunit:htmlunit 2.54.0 -> 2.59.0  Many of these seem harmless or only used in testing (or utterly required like the log4j upgrade). However, some raise flags like the `xmlunit` or `rometools` upgrades because we are currently using (and shipping) the older versions.  Am I needlessly worried here?","closed","for: stackoverflow,","nkiesel","2022-04-02T01:23:40Z","2022-04-02T07:41:46Z"
"","28638","BeanUtils cannot instantiate a Kotlin data class that uses a value class as a constructor parameter","Kotlin value classes currently cannot be used in configuration bindings in Spring Boot 2.6.6.  This is a repro case:  ```kotlin package com.example  import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.context.properties.ConfigurationProperties import org.springframework.boot.context.properties.ConfigurationPropertiesScan import org.springframework.boot.context.properties.ConstructorBinding import org.springframework.boot.runApplication import org.springframework.context.annotation.Bean  fun main(args: Array) {     System.setProperty(""SPRING_APPLICATION_JSON"", ""{ \""predicate\"": \""C\"" }"")     runApplication(*args) }  @SpringBootApplication @ConfigurationPropertiesScan(basePackages = [""com.example""]) class SpringTest {      @Bean     fun someBean(config: PredicateConfiguration): String {         println(""predicate: ${config.predicate.value}"")         return """"     }  }  @JvmInline value class Predicate(val value: Char)  @ConfigurationProperties @ConstructorBinding data class PredicateConfiguration(val predicate: Predicate) ```  It fails with the following error message:  ``` Failed to bind properties under '' to com.example.PredicateConfiguration:      Reason: java.lang.IllegalArgumentException: object is not an instance of declaring class ```","open","in: kotlin,","MrBuddyCasino","2022-06-15T20:40:16Z","2022-06-16T14:57:12Z"
"","28559","Improve AssertJ usage in cache config tests","Just some code improvements I've found while studying code in that area. It boils down to using more AssertJ features instead of hand-written code and removes `public` at some places (unnecessary with JUnit 5).","closed","type: task,","neiser","2022-06-03T08:01:02Z","2022-06-03T09:02:21Z"
"","28361","runtime generate controller class","jdk11 spring5.3.18 springboot 2.6.6 reflect generate controler class runtime jdk compile inject spring failed please help me,thanks  error as follow:  Error creating bean with name 'sss.serverDubboApi.HelloServiceImplDubboApiController': Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class .sss.serverDubboApi.HelloServiceImplDubboApiController: Common causes of this problem include using a final class or a non-visible class; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.NoClassDefFoundError-->sss/serverDubboApi/HelloServiceImplDubboApiController at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:628) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:233) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1282) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1243) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:494) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:349) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:342) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1172) at swagger.dubbo.builder.SpringHelper.registerBeanDefinition(SpringHelper.java:30) at swagger.dubbo.ApiScannerBootstrap.init(ApiScannerBootstrap.java:54) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:389) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:333) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:157) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:440) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:620) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:953) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:740) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:415) at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) at sss.CustomApplication.main(CustomApplication.java:20) Caused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class sss.serverDubboApi.HelloServiceImplDubboApiController: Common causes of this problem include using a final class or a non-visible class; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.NoClassDefFoundError-->/serverDubboApi/HelloServiceImplDubboApiController at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:209) at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110) at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:478) at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:342) at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:291) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:455) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1808) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:620) ... 38 common frames omitted Caused by: org.springframework.cglib.core.CodeGenerationException: java.lang.NoClassDefFoundError-->/sss/serverDubboApi/HelloServiceImplDubboApiController at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:558) at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) at org.springframework.cglib.proxy.Enhancer.generate(Enhancer.java:585) at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) at java.base/java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:264) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java) at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) at org.springframework.cglib.proxy.Enhancer.createHelper(Enhancer.java:572) at org.springframework.cglib.proxy.Enhancer.createClass(Enhancer.java:419) at org.springframework.aop.framework.ObjenesisCglibAopProxy.createProxyClassAndInstance(ObjenesisCglibAopProxy.java:57) at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:206) ... 45 common frames omitted Caused by: java.lang.NoClassDefFoundError: sss/serverDubboApi/HelloServiceImplDubboApiController at java.base/java.lang.ClassLoader.defineClass1(Native Method) at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1016) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:555) ... 60 common frames omitted Caused by: java.lang.ClassNotFoundException: sss.serverDubboApi.HelloServiceImplDubboApiController at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:581) at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:178) at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521) ... 67 common frames omitted","closed","for: stackoverflow,","vwyuheng","2022-04-20T14:45:13Z","2022-04-20T14:49:35Z"
"","28844","MethodValidationPostProcessor still use javax.validation","javax.validation is outdated. When can MethodValidationPostProcessor use jakarta.validation instead of javax.validation.","closed","status: invalid,","2012518013","2022-07-20T03:13:52Z","2022-07-20T11:49:57Z"
"","28650","The mail API problem in spring-context-support","jakarta.mail-api has been released to 2.1, and the package name has been changed from javax.mail to jakarta.mail, why is the javax.mail api referenced in spring?","closed","status: invalid,","llsi4275","2022-06-18T09:05:58Z","2022-06-18T09:16:43Z"
"","28400","Support for Jakarta Concurrency 3.0","Jakarta EE 10 includes several significant additions to the Jakarta Concurrency API, including a `jakarta.enterprise.concurrent.Asynchronous` annotation similar to EJB's `jakarta.ejb.Asynchronous` which we detect as well. When the Jakarta Concurrency 3.0 API is present at runtime, we should aim for consistent auto-adapting.","closed","type: enhancement,","jhoeller","2022-04-29T23:23:14Z","2022-05-05T15:28:24Z"
"","28410","Check that nullable annotations are from org.springframework.lang","It's quite easy to accidentally import the wrong `@Nullable` annotation. We can add a checkstyle rule to make sure it doesn't happen.","closed","type: task,","philwebb","2022-05-03T18:13:35Z","2022-05-05T15:43:08Z"
"","28324","Review ""default"" vs redirect model default settings and API","It's been a long time since this API and available options have been considered, and as per the discussion under #28069, we should review for potential changes towards 6.0.  One option would be to provide a `Rendering` API that aligns with what is available in WebFlux.  In the very least, we can deprecate the `ignoreDefaultModelOnRedirect` option on `RequestMappingHandlerAdapter` and change its default setting.","open","type: enhancement,","rstoyanchev","2022-04-11T11:07:48Z","2022-07-13T16:20:06Z"
"","28838","Prevent beans to be instantiated at build-time unless it has been flagged","It's becoming more apparent that certain beans will have to be instantiated at build time (typically to introspect the outcome of something that could have been overridden by the user). We want to make sure that these are limited and that trying to resolve too much dependencies will fail fast.  One idea was to adapt `ContextAnnotationAutowireCandidateResolver` to only resolve low-level dependencies, such as `ApplicationContext`, `BeanFactory`, and the like.","open","theme: aot,","snicoll","2022-07-18T16:04:40Z","2022-07-28T06:54:19Z"
"","28772","Provide SerializationHintsPredicates in RuntimeHintsPredicates","It would be nice to have the `SerializationHintsPredicates` in `RuntimeHintsPredicates` as we have for `reflections`, `resource` and `proxies`.  I've created one myself for now:  ```java public class SerializationHintsPredicates {  	public TypeHintPredicate onType(TypeReference typeReference) { 		Assert.notNull(typeReference, ""'typeReference' should not be null""); 		return new TypeHintPredicate(typeReference); 	}  	public TypeHintPredicate onType(Class type) { 		Assert.notNull(type, ""'type' should not be null""); 		return new TypeHintPredicate(TypeReference.of(type)); 	}  	public static class TypeHintPredicate implements Predicate {  		private final TypeReference type;  		TypeHintPredicate(TypeReference type) { 			this.type = type; 		}  		@Override 		public boolean test(RuntimeHints hints) { 			return hints.serialization().javaSerialization().anyMatch((hint) -> hint.getType().equals(this.type)); 		}  	}  } ```","closed","theme: aot,","marcusdacoregio","2022-07-07T14:19:45Z","2022-07-11T20:37:56Z"
"","28051","Expose MvcResult in WebTestClient","It would be great to access the `MvcResult` in the `WebTestClient` validation flow.  Currently, if you want to validate eg. the exception message and type, you have to:  ```java webTestClient.post()         ... 	.expectBody() 	.consumeWith(rsp -> {              MvcResult mvc = ((MvcResult) rsp.getMockServerResult());              assertEquals(""expected message"", mvc.getResolvedException().getMessage());              assertTrue(mvc.getResolvedException() instanceof MyCustomException);          }); ```  It would be great if that could just be integrated and asserted inside the builder flow, if possible?","closed","type: enhancement,","membersound","2022-02-15T08:32:38Z","2022-02-16T11:14:32Z"
"","27927","fix:Spring fails to determine XML is XSD-based if DOCTYPE appears in a comment","It solves the problem that `XmlValidationModeDetector` cannot determine whether XML is based on XSD due to improper parsing of comments spanning multiple lines in the original XML configuration file.  Fixes #27915","closed","status: superseded,","shooye","2022-01-12T16:37:21Z","2022-01-13T15:38:36Z"
"","27945","Port GroovyDynamicElementReader to Java","It makes the compilation much simpler and means you can open the project in Eclipse or VSCode without red errors.","closed","in: core,","dsyer","2022-01-18T12:13:09Z","2022-01-21T10:19:24Z"
"","28330","Add ""Implementation-Vendor-Id"" to MANIFEST.MF","It looks like there is an old closed issue that proposed something similar but with a much larger scope: https://github.com/spring-projects/spring-framework/issues/17888  I was hoping to put out a PR to add a hardcoded `Implementation-Vendor-Id` to the currently generated MANIFEST.MF file. I'd be happy to open the PR just wanted to make sure there weren't any issues I was not considering.   Impacted code section can be found here: https://github.com/spring-projects/spring-framework/blob/main/gradle/spring-module.gradle#L40-L53   Existing code ```groovy 	manifest.attributes[""Implementation-Title""] = project.name 	manifest.attributes[""Implementation-Version""] = project.version 	manifest.attributes[""Automatic-Module-Name""] = project.name.replace('-', '.')  // for Jigsaw 	manifest.attributes[""Created-By""] = 			""${System.getProperty(""java.version"")} (${System.getProperty(""java.specification.vendor"")})"" ```  Suggested Code ```groovy 	manifest.attributes[""Implementation-Title""] = project.name 	manifest.attributes[""Implementation-Version""] = project.version 	manifest.attributes[""Implementation-Vendor-Id""] = ""org.springframework"" 	manifest.attributes[""Automatic-Module-Name""] = project.name.replace('-', '.')  // for Jigsaw 	manifest.attributes[""Created-By""] = 			""${System.getProperty(""java.version"")} (${System.getProperty(""java.specification.vendor"")})"" ```  The goal of this change is to provide an easier route for identifying the namespace of the dependency since they are not packaged with a `pom.properties` file.","open","status: waiting-for-triage,","kwilsonO","2022-04-12T16:23:37Z","2022-04-12T16:27:32Z"
"","28916","How can I get generic bean through ApplicationContext or BeanFactory?","It is obviously right to inject one generic bean through @Autowired annotation since spring 4.0 just like this: `@Autowired private GenericClass genericPerson;`  But I can not find a proper way to fetch it through BeanFactory or ApplicationContext just like: `ApplicationContext.getBean(GenericClass.class)`  I do know there is some wrong in syntax, but there must be some other way to realize it, right?","open","status: waiting-for-triage,","dayAndnight2018","2022-08-03T01:01:26Z","2022-08-03T01:05:50Z"
"","28376","Add an interceptor for Controller","It is hoped that an interceptor can be provided to allow users to do custom processing before and after the methods in the controller, such as recording the request parameter log","open","status: feedback-provided,","brucelwl","2022-04-25T13:20:16Z","2022-06-05T17:33:59Z"
"","28793","Please tell me why Spring @RequestBody support the GET method ？","It does not seem to meet the HTTP protocol.","closed","for: stackoverflow,","wangqinggo","2022-07-12T08:51:56Z","2022-07-12T09:24:30Z"
"","28432","sun.nio.fs.WindowsPath$WindowsPathWithAttributes error while upgrading Batch with Spring boot from 2.1.8.RELEASE to 2.6.7","Issue upgrading Spring Boot from 2.1.8.RELEASE to 2.6.7 (exception stacktrace below).  The error happens when `org.springframework.batch.item.ExecutionContext.map` has a `String(key)` and `java.nio.file.Path(value)`.  When the `String(key)` gets mapped `String(value)`, the error goes away.  Exception:  ``` org.springframework.batch.core.step.FatalStepExecutionException: JobRepository failure forcing rollback 	at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:464) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:331) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:140) ~[spring-tx-5.3.19.jar:5.3.19] 	at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:273) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:375) ~[spring-batch-infrastructure-4.3.5.jar:4.3.5] 	at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:215) ~[spring-batch-infrastructure-4.3.5.jar:4.3.5] 	at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:145) ~[spring-batch-infrastructure-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:258) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:208) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:152) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.job.flow.JobFlowExecutor.executeStep(JobFlowExecutor.java:68) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.job.flow.support.state.StepState.handle(StepState.java:68) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.job.flow.support.SimpleFlow.resume(SimpleFlow.java:169) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.job.flow.support.SimpleFlow.start(SimpleFlow.java:144) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.job.flow.FlowJob.doExecute(FlowJob.java:137) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:320) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:149) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50) [spring-core-5.3.19.jar:5.3.19] 	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:140) [spring-batch-core-4.3.5.jar:4.3.5] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_275] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_275] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_275] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_275] 	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration$PassthruAdvice.invoke(SimpleBatchConfiguration.java:128) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215) [spring-aop-5.3.19.jar:5.3.19] 	at com.sun.proxy.$Proxy57.run(Unknown Source) [na:na] 	at org.springframework.boot.autoconfigure.batch.JobLauncherApplicationRunner.execute(JobLauncherApplicationRunner.java:199) [spring-boot-autoconfigure-2.6.7.jar:2.6.7] 	at org.springframework.boot.autoconfigure.batch.JobLauncherApplicationRunner.executeLocalJobs(JobLauncherApplicationRunner.java:173) [spring-boot-autoconfigure-2.6.7.jar:2.6.7] 	at org.springframework.boot.autoconfigure.batch.JobLauncherApplicationRunner.launchJobFromProperties(JobLauncherApplicationRunner.java:160) [spring-boot-autoconfigure-2.6.7.jar:2.6.7] 	at org.springframework.boot.autoconfigure.batch.JobLauncherApplicationRunner.run(JobLauncherApplicationRunner.java:155) [spring-boot-autoconfigure-2.6.7.jar:2.6.7] 	at org.springframework.boot.autoconfigure.batch.JobLauncherApplicationRunner.run(JobLauncherApplicationRunner.java:150) [spring-boot-autoconfigure-2.6.7.jar:2.6.7] 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:768) [spring-boot-2.6.7.jar:2.6.7] 	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:758) [spring-boot-2.6.7.jar:2.6.7] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) [spring-boot-2.6.7.jar:2.6.7] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) [spring-boot-2.6.7.jar:2.6.7] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) [spring-boot-2.6.7.jar:2.6.7] 	at com.example.demo.DemoApplication.main(DemoApplication.java:10) [main/:na] Caused by: java.lang.IllegalArgumentException: Failed to serialize object of type: class org.springframework.batch.item.ExecutionContext 	at org.springframework.util.SerializationUtils.serialize(SerializationUtils.java:60) ~[spring-core-5.3.19.jar:5.3.19] 	at org.springframework.batch.core.repository.dao.MapExecutionContextDao.copy(MapExecutionContextDao.java:117) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.repository.dao.MapExecutionContextDao.updateExecutionContext(MapExecutionContextDao.java:129) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.batch.core.repository.support.SimpleJobRepository.updateExecutionContext(SimpleJobRepository.java:218) ~[spring-batch-core-4.3.5.jar:4.3.5] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_275] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_275] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_275] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_275] 	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123) ~[spring-tx-5.3.19.jar:5.3.19] 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:388) ~[spring-tx-5.3.19.jar:5.3.19] 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) ~[spring-tx-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215) [spring-aop-5.3.19.jar:5.3.19] 	at com.sun.proxy.$Proxy50.updateExecutionContext(Unknown Source) ~[na:na] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_275] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_275] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_275] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_275] 	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration$PassthruAdvice.invoke(SimpleBatchConfiguration.java:128) [spring-batch-core-4.3.5.jar:4.3.5] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.3.19.jar:5.3.19] 	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215) [spring-aop-5.3.19.jar:5.3.19] 	at com.sun.proxy.$Proxy50.updateExecutionContext(Unknown Source) ~[na:na] 	at org.springframework.batch.core.step.tasklet.TaskletStep$ChunkTransactionCallback.doInTransaction(TaskletStep.java:452) ~[spring-batch-core-4.3.5.jar:4.3.5] 	... 41 common frames omitted Caused by: java.io.NotSerializableException: sun.nio.fs.WindowsPath$WindowsPathWithAttributes 	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) ~[na:1.8.0_275] 	at java.util.ArrayList.writeObject(ArrayList.java:768) ~[na:1.8.0_275] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_275] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_275] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_275] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_275] 	at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1154) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1496) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) ~[na:1.8.0_275] 	at java.util.concurrent.ConcurrentHashMap.writeObject(ConcurrentHashMap.java:1413) ~[na:1.8.0_275] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_275] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_275] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_275] 	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_275] 	at java.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1154) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1496) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178) ~[na:1.8.0_275] 	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) ~[na:1.8.0_275] 	at org.springframework.util.SerializationUtils.serialize(SerializationUtils.java:56) ~[spring-core-5.3.19.jar:5.3.19] 	... 69 common frames omitted ```","open","status: waiting-for-triage,","pmuralidh","2022-05-09T17:56:06Z","2022-05-11T18:59:06Z"
"","28831","Refine AOT APIs and migrate tests to use generated classes","Issue #28585 has unlocked our ability to simplify and hide a details with AOT APIs. If we migrate our tests to use `GeneratedClasses` we can then make the following changes:  - Drop the `MethodGenerator` interface - Make `GeneratedMethods` and `GeneratedClasses` have package-private constructors - Make some currently public methods package-private since they're only called from the `aot` package - Change the `using` or `builder` methods so that `Consumer` fields can be `final`.  In addition we can also fix the variable and parameter names from `builder` to `type` or `method` so that it becomes more obvious what is being built.","closed","type: task,","philwebb","2022-07-18T07:30:45Z","2022-07-18T07:48:01Z"
"","28454","make sure methodCache in AdvisedSupport work for the first time","Issue #28174 Add an getInterceptors class to make sure  methodCache in AdvisedSupport work for the first time","closed","status: waiting-for-triage,","Robin11223","2022-05-12T10:00:29Z","2022-05-19T05:33:55Z"
"","28178","An error occurred while registering beans using two ClassLoader","Is this a bug? ```java fun main(args: Array) {     var application =         runApplication(*args) as AnnotationConfigServletWebServerApplicationContext     var urls = arrayOf(File(""/home/HouXinLin/project/java/GradleDemo/build/libs/GradleDemo-1.0-SNAPSHOT.jar"").toURI().toURL())        var urlClassLoader_1 = URLClassLoader(urls)     var urlClassLoader_2 = URLClassLoader(urls)      var testClass1 = urlClassLoader_1.loadClass(""com.hxl.test.TestClass"")     application.registerBean(testClass1, BeanDefinitionCustomizer {  })     println(application.getBean(testClass1))//ok      application.removeBeanDefinition(""com.hxl.test.TestClass"")     var testClass2 = urlClassLoader_2.loadClass(""com.hxl.test.TestClass"")     application.registerBean(testClass2, BeanDefinitionCustomizer {  })     println(application.getBean(testClass2))// No qualifying bean of type 'com.hxl.test.TestClass' available } ```  Why did this error occur？Is it my code problem? Or spring internal reasons ```  No qualifying bean of type 'com.hxl.test.TestClass' available ```","closed","for: stackoverflow,","houxinlin","2022-03-14T23:05:55Z","2022-03-15T07:25:53Z"
"","28484","Is it possible to use @Autowired like annotations instead of getBeansWithAnnotation","Is it possible to use @Autowired like annotations instead of getBeansWithAnnotation , if not are there plans to support the feature  ![image](https://user-images.githubusercontent.com/96010787/169237615-1d244f1b-bad3-4a47-a2c9-09839583d349.png)","closed","status: declined,","sleeprite","2022-05-19T07:32:03Z","2022-05-19T08:39:22Z"
"","27922","Provide a bean instance descriptor API","Introspecting a type at build-time allows us to detect things that we typically do at runtime:  * `Executable` to use. * Injection points to honor (typically `@Autowired`). * Property values to inject, as defined on the `BeanDefinition`. * Initialization and destruction callback  Offering an API that uses the same algorithm as a traditional runtime is important to keep the behavior consistent. This enhancement is further refined as follows:  * https://github.com/spring-projects/spring-framework/issues/27920 * https://github.com/spring-projects/spring-framework/issues/27921","closed","theme: aot,","snicoll","2022-01-11T15:32:59Z","2022-02-14T13:07:31Z"
"","28828","Absence of dependencies for optional TestExecutionListener breaks integration tests","Integration test execution fails in Eclipse if modules like `spring-tx` are not on the classpath.  The attached reproducer is a bare bone Spring Boot application  created via the Initializr without any actual dependencies added. It builds fine on the command line (via Maven) but when imported into Eclipse, the test execution fails with the following stack trace:  ``` java.lang.IllegalStateException: Failed to load default TestExecutionListener [org.springframework.test.context.transaction.TransactionalTestExecutionListener]. 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.lambda$getDefaultTestExecutionListeners$1(AbstractTestContextBootstrapper.java:217) 	at org.springframework.core.io.support.SpringFactoriesLoader.instantiateFactory(SpringFactoriesLoader.java:233) 	at org.springframework.core.io.support.SpringFactoriesLoader.load(SpringFactoriesLoader.java:208) 	at org.springframework.core.io.support.SpringFactoriesLoader.load(SpringFactoriesLoader.java:182) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.getDefaultTestExecutionListeners(AbstractTestContextBootstrapper.java:223) 	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getDefaultTestExecutionListeners(SpringBootTestContextBootstrapper.java:114) 	at org.springframework.test.context.support.AbstractTestContextBootstrapper.getTestExecutionListeners(AbstractTestContextBootstrapper.java:130) 	at org.springframework.test.context.TestContextManager.(TestContextManager.java:138) 	at org.springframework.test.context.TestContextManager.(TestContextManager.java:122) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.lambda$getOrComputeIfAbsent$4(ExtensionValuesStore.java:86) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.computeValue(ExtensionValuesStore.java:223) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore$MemoizingSupplier.get(ExtensionValuesStore.java:211) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore$StoredValue.evaluate(ExtensionValuesStore.java:191) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore$StoredValue.access$100(ExtensionValuesStore.java:171) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:89) 	at org.junit.jupiter.engine.execution.ExtensionValuesStore.getOrComputeIfAbsent(ExtensionValuesStore.java:93) 	at org.junit.jupiter.engine.execution.NamespaceAwareStore.getOrComputeIfAbsent(NamespaceAwareStore.java:61) 	at org.springframework.test.context.junit.jupiter.SpringExtension.getTestContextManager(SpringExtension.java:294) 	at org.springframework.test.context.junit.jupiter.SpringExtension.beforeAll(SpringExtension.java:113) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeBeforeAllCallbacks$10(ClassBasedTestDescriptor.java:381) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeBeforeAllCallbacks(ClassBasedTestDescriptor.java:381) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:205) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:80) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:148) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:95) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:91) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:60) 	at org.eclipse.jdt.internal.junit5.runner.JUnit5TestReference.run(JUnit5TestReference.java:98) 	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:40) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:529) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:756) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:452) 	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210) Caused by: java.lang.reflect.InvocationTargetException 	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) 	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77) 	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) 	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499) 	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480) 	at org.springframework.core.io.support.SpringFactoriesLoader$FactoryInstantiator.instantiate(SpringFactoriesLoader.java:383) 	at org.springframework.core.io.support.SpringFactoriesLoader.instantiateFactory(SpringFactoriesLoader.java:230) 	... 58 more Caused by: java.lang.NoClassDefFoundError: org/springframework/transaction/annotation/AnnotationTransactionAttributeSource 	at java.base/java.lang.ClassLoader.defineClass1(Native Method) 	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1012) 	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150) 	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862) 	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760) 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681) 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520) 	at org.springframework.test.context.transaction.TransactionalTestExecutionListener.(TransactionalTestExecutionListener.java:154) 	... 65 more Caused by: java.lang.ClassNotFoundException: org.springframework.transaction.annotation.AnnotationTransactionAttributeSource 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520) 	... 75 more ```  The error is caused by the lookup of the `TestExecutionListener`s (`AbstractTestContextBootstrapper.getDefaultTestExecutionListeners()`), but the registered `FailureHandler` is not handling the exception as thrown by Eclipse. In Eclipse an `InvocationTagetException` is thrown wrapping a `NoClassDefFoundError` likely resulting from a different `Classloader` arrangement in the IDE's test execution.  [spring-test-reproducer.zip](https://github.com/spring-projects/spring-framework/files/9120130/spring-test-reproducer.zip)","closed","type: regression,","odrotbohm","2022-07-15T10:42:15Z","2022-07-15T11:54:44Z"
"","28747","Improve diagnostics for CGLIB ClassLoader issues on Java 9+","Inspired by the discussion in https://github.com/spring-projects/spring-hateoas/issues/1806, we should improve the diagnostics for CGLIB `ClassLoader` issues on Java 9+.  For example, in certain circumstances the JDK will hint that the user needs to provide `--add-opens=java.base/java.util.concurrent=ALL-UNNAMED` as a command-line argument -- for example, when trying to dynamically subclass a type from the `java.util.concurrent` package.  However, due to the nature of Spring's CGLIB fork (specifically the changes in `org.springframework.cglib.core.ReflectUtils.defineClass(...)`) the proper fix would be to use `--add-opens=java.base/java.lang=ALL-UNNAMED` to open up the protected `ClassLoader.defineClass(...)` method used by Spring's CGLIB fork.  `ReflectUtils` could be updated to add this additional diagnostic information to the exception thrown by `ReflectUtils.defineClass(...)`.","closed","type: enhancement,","sbrannen","2022-07-02T15:44:38Z","2022-07-13T09:20:53Z"
"","28581","Unneeded current path check","Inside the `StringUtils` class, method `cleanPath`, there is a conditional check for current path with no further logic inside it.  Could we drop this if check? Could raise a PR.   For reference: https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/util/StringUtils.java#L695","closed","status: invalid,","kvaithin","2022-06-07T22:12:45Z","2022-06-08T07:14:01Z"
"","28331","BeanFactory and BeanRegisty is extends ???","Inheritance is a parent-child relationship. Singletonbeanregistry is an abstraction of registration capability. Beanfactory should have this capability, but beanfactory and beanregisty are not parent-child relationships. Should they be inclusion relationships? Well, but now is abstractbeanfactory extensions factorybeanregistrysupport","open","status: waiting-for-triage,","wangkm1","2022-04-13T06:24:04Z","2022-04-13T06:27:34Z"
"","28242","Property name consistent with the one in the code","In XML file, the property name is 'integerProperty' while the field in the code is 'i'.","closed","status: invalid,","lifei-zhang-awx","2022-03-28T13:57:46Z","2022-03-28T14:35:44Z"
"","28006","Introduce token-based consumption of  multipart requests in WebFlux","In version 5.3, Spring Framework introduced the `DefaultPartHttpMessageReader` as a fully reactive way to handle multipart upload requests. One of the features of this message reader is [streaming mode](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/codec/multipart/DefaultPartHttpMessageReader.html#setStreaming-boolean-), where the contents of the uploaded parts is not stored in memory or on disk, but directly passed on to the subscriber (in the form of [DataBuffers](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/codec/multipart/Part.html#content--) ). This feature is particularly useful for server proxies, where the controller passes on the data buffers to another service, for instance by using `WebClient`.  However, there is a problem in the way streaming mode deals with back pressure. In streams produces by other `HttpMessageReader`s and codecs, there is a clear relationship between the requests made by the subscriber and the request made against the incoming buffer stream (for instance, the `ByteBufferDecoder` creates one `ByteBuffer` for each incoming `DataBuffer`). When `DefaultPartHttpMessageReader` is used in streaming mode, there is no such relationship, because each `Part` produced can consists of multiple databuffers. Effectively, there are two kinds of back pressure in streaming mode:  1. the back pressure of the `Part` elements, i.e. the 'outer' flux 2. the back pressure of the `DataBuffer` contents of each part, i.e. the 'inner' flux.   There are several scenarios to consider:  * What should happen when a request for a second part comes in, while the contents of the first has not been consumed yet? * What should happen when the inner flux is canceled, while the outer flux is not? * What should happen when `flatMap` is used on the `Part` stream?  * How should [prefetch be used](https://github.com/spring-projects/spring-framework/issues/27743)? * etc. etc.  Though I am sure we can come up with answers to these questions, the fact remains that in streaming scenarios, representing multipart data as `Flux` where each part contains a `Flux` has inherent difficulties with back pressure. Instead, we should introduce an alternative way to consume multipart data, a better fit for streaming scenarios.   ### Part tokens  Instead `Part` elements, the multipart upload is represented by a stream of part tokens. Each part in the multipart request is represented by a **header** token that contains the part headers, followed by one or more **body** tokens with data buffers containing the part body. Subsequent parts will result in another header token, followed by more body tokens, and so on.  For instance, a multipart message with a form field and a file will produce the following tokens:  1. header token containing the headers of the form field part 2. a body token containing the form field value 3. header token containing the headers of the file part 4. multiple body tokens containing buffers with the contents of the file  Using part tokens, there is a direct relationship between back pressure of the the token subscriber and that of the buffer input. In the case of body tokens, this even is a 1-on-1 relationship.  For instance, here is a typical controller method that splits the tokens into multiples fluxes that start with a header token, so that each inner flux contains the tokens of one part. The headers from said token can then be used if necessary, and the remaining body tokens can be used as well.  ```java @PostMapping(""/tokens"") Flux tokens(@RequestBody Flux tokens) { 	return tokens 			.windowUntil(token -> token instanceof PartToken.Headers, true)  // Flux> 			.concatMap(t -> t.switchOnFirst((signal, partTokens) -> { 				if (signal.hasValue()) { 					PartToken.Headers headersToken = (PartToken.Headers) signal.get(); 					HttpHeaders headers = headersToken.headers(); 					// Use info in headers if necessary 					Flux bodyBuffers = partTokens 							.filter(token -> token instanceof PartToken.Body) 							.cast(PartToken.Body.class) 							.map(PartToken.Body::buffer); 					// Send body buffers to other service 					return Mono.empty(); 				} 				else { 					return releaseBody(partTokens) 							.then(Mono.empty()); 				} 			}));  } ```","closed","type: enhancement,","poutsma","2022-02-04T10:23:21Z","2022-05-10T11:20:58Z"
"","28711","Aspects don't work in native-image","In the spring-native sample `class-proxies-aop` in the branch `sb-3.0.x`, the `@Aspect` works when running in AOT mode, but not in a native-image. There's no exception, the aspect just doesn't get executed.","open","theme: aot,","mhalbritter","2022-06-27T13:41:39Z","2022-06-28T13:30:34Z"
"","28804","Support infix expression calculation in NumberUtils","In the process of using springboot, I especially hope to write the calculation expression directly in the yaml configuration file","closed","status: declined,","jackycjw","2022-07-12T17:17:36Z","2022-07-13T12:47:59Z"
"","28101","Overriding an event listener method always results in parent method call","In the following code the `beforeEach` method of the `ParentConfig` class will get called failing the test. See https://github.com/biergit/listenerinheritanceissue  ```java @SpringBootTest @Import({ChildConfig.class}) class ListenerinheritanceissueApplicationTests {     public static int calledByParentConfigBeforeEach = 0;      @Test     void parentConfigBeforeTestMethodShouldNotBeCalled() {         Assertions.assertThat(calledByParentConfigBeforeEach).isEqualTo(0);     }      @Configuration     static class ParentConfig {         @BeforeTestMethod         public void beforeEach(BeforeTestMethodEvent e) {             ListenerinheritanceissueApplicationTests.calledByParentConfigBeforeEach++;         }      }      @Configuration     static class ChildConfig extends ParentConfig {         @Override         public void beforeEach(BeforeTestMethodEvent e) { 			// no call to super so there should be no invocation at all         }      }  } ```","closed","in: test,","biergit","2022-02-23T16:00:40Z","2022-02-28T09:28:54Z"
"","28688","native-image: Field 'PROPAGATION_REQUIRED' not found in class TransactionDefinition","In the `batch` sample from `spring-native` in `sb-3.0.x` branch, running the native image fails with the following exception:  ``` org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'batchApplication': Unsatisfied dependency expressed through field 'jobBuilderFactory': Error creating bean with name 'org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration': Unsatisfied dependency expressed through field 'configurers': Error creating bean with name 'batchConfigurer': Unable to initialize Spring Batch 	at org.springframework.beans.factory.aot.AutowiredFieldValueResolver.resolveValue(AutowiredFieldValueResolver.java:195) ~[na:na] 	at org.springframework.beans.factory.aot.AutowiredFieldValueResolver.resolveAndSet(AutowiredFieldValueResolver.java:167) ~[na:na] 	at com.example.batch.BatchApplication__Autowiring.apply(BatchApplication__Autowiring.java:14) ~[na:na] 	at org.springframework.beans.factory.support.InstanceSupplier.lambda$andThen$0(InstanceSupplier.java:64) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:735) ~[batch:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:431) ~[batch:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[batch:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1307) ~[batch:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1296) ~[batch:3.0.0-SNAPSHOT] 	at com.example.batch.BatchApplication.main(BatchApplication.java:49) ~[batch:0.0.1-SNAPSHOT] Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration': Unsatisfied dependency expressed through field 'configurers': Error creating bean with name 'batchConfigurer': Unable to initialize Spring Batch 	at org.springframework.beans.factory.aot.AutowiredFieldValueResolver.resolveValue(AutowiredFieldValueResolver.java:195) ~[na:na] 	at org.springframework.beans.factory.aot.AutowiredFieldValueResolver.resolveAndSet(AutowiredFieldValueResolver.java:167) ~[na:na] 	at org.springframework.batch.core.configuration.annotation.SimpleBatchConfiguration__Autowiring.apply(SimpleBatchConfiguration__Autowiring.java:17) ~[na:na] 	at org.springframework.beans.factory.support.InstanceSupplier.lambda$andThen$0(InstanceSupplier.java:64) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:225) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1267) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1228) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:483) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:338) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:331) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.batch.core.configuration.annotation.AbstractBatchConfiguration__BeanDefinitions.getJobBuildersInstance(AbstractBatchConfiguration__BeanDefinitions.java:30) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1374) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1294) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredFieldValueResolver.resolveValue(AutowiredFieldValueResolver.java:189) ~[na:na] 	... 21 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'batchConfigurer': Unable to initialize Spring Batch 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1752) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:604) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:254) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1590) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1554) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1445) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1332) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1294) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredFieldValueResolver.resolveValue(AutowiredFieldValueResolver.java:189) ~[na:na] 	... 52 common frames omitted Caused by: java.lang.IllegalStateException: Unable to initialize Spring Batch 	at org.springframework.boot.autoconfigure.batch.BasicBatchConfigurer.initialize(BasicBatchConfigurer.java:107) ~[batch:0.0.1-SNAPSHOT] 	at org.springframework.boot.autoconfigure.batch.BasicBatchConfigurer.afterPropertiesSet(BasicBatchConfigurer.java:96) ~[batch:0.0.1-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1798) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1748) ~[batch:6.0.0-SNAPSHOT] 	... 65 common frames omitted Caused by: org.springframework.core.Constants$ConstantException: Field 'PROPAGATION_REQUIRED' not found in class [org.springframework.transaction.TransactionDefinition] 	at org.springframework.core.Constants.asObject(Constants.java:145) ~[na:na] 	at org.springframework.core.Constants.asNumber(Constants.java:113) ~[na:na] 	at org.springframework.transaction.support.DefaultTransactionDefinition.setPropagationBehaviorName(DefaultTransactionDefinition.java:122) ~[batch:6.0.0-SNAPSHOT] 	at org.springframework.transaction.interceptor.TransactionAttributeEditor.setAsText(TransactionAttributeEditor.java:65) ~[na:na] 	at org.springframework.transaction.interceptor.NameMatchTransactionAttributeSource.setProperties(NameMatchTransactionAttributeSource.java:87) ~[na:na] 	at org.springframework.batch.core.repository.support.AbstractJobRepositoryFactoryBean.initializeProxy(AbstractJobRepositoryFactoryBean.java:182) ~[batch:5.0.0-M3] 	at org.springframework.batch.core.repository.support.AbstractJobRepositoryFactoryBean.afterPropertiesSet(AbstractJobRepositoryFactoryBean.java:212) ~[batch:5.0.0-M3] 	at org.springframework.batch.core.repository.support.JobRepositoryFactoryBean.afterPropertiesSet(JobRepositoryFactoryBean.java:225) ~[na:na] 	at org.springframework.boot.autoconfigure.batch.BasicBatchConfigurer.createJobRepository(BasicBatchConfigurer.java:134) ~[batch:0.0.1-SNAPSHOT] 	at org.springframework.boot.autoconfigure.batch.BasicBatchConfigurer.initialize(BasicBatchConfigurer.java:102) ~[batch:0.0.1-SNAPSHOT] 	... 68 common frames omitted ```  I guess there are some hints missing.","closed","theme: aot,","mhalbritter","2022-06-23T14:30:34Z","2022-07-01T12:54:53Z"
"","27906","Add Section on Authorization to STOMP WebSocket documentation","In the [Spring Framework Websockets documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket), there is a general section regarding authentication. However, there is no information about authorization. That led me to implement a custom `ChannelInterceptor` to do authorization based on destinations.  Then, a colleague luckily pointed me to the fact that there is a Spring Security implementation for web sockets and [separate documentation](https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/websocket.html), and I could throw away my code (which is good in the end).  My proposal is to add a section about authorization to the Spring Framework Websockets section that explains shortly how this is done (using `AbstractSecurityWebSocketMessageBrokerConfigurer`) or at least add a link to the Spring Security docs.  If this makes sense to you, I could also try to provide a PR. If you have suggestions (scope, location) for the PR, please let me know.  References:  - https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket - https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/websocket.html","closed","in: web,","jwedel","2022-01-08T11:24:07Z","2022-01-12T09:03:07Z"
"","28588","JdkHttpClientResourceFactory has dependency  on org.eclipse.jetty","in spring-web, `org.springframework.http.client.reactive.JdkHttpClientResourceFactory` makes use of the jetty LifeCycle class.  It would be good to be able to use JdkHttpClientResourceFactory with no extra dependencies.  This is in v 6.0","closed","type: bug,","j3graham","2022-06-08T19:12:44Z","2022-06-14T09:01:30Z"
"","28412","No warnings when beans not found due to circular references being disabled","In Spring Boot 2.6, circular references are now prohibited by default. However, the effects of this change are not obvious. In the following example, `Bar` is no longer found. In 2.5 they were found.  Code like this caused an issue in production that was not immediately detected because there were no errors either during startup or runtime.   It would be very helpful if Spring could provide any kind of feedback or warning when it has decided not to find beans due to this setting. Similar to how Spring refuses to start if you have a circular dependency.   ``` @Service @RequiredArgsConstructor public class Foo {   private final ApplicationContext applicationContext;    @PostConstruct   public void init() {     var bars = applicationContext.getBeansOfType(Bar.class);     // .stream() bars and do stuff with them.   } } ```  ``` @Service @RequiredArgsConstructor public class Bar {   private final Foo foo; } ```","open","status: waiting-for-triage,","lbenedetto","2022-05-04T11:19:59Z","2022-05-04T11:20:19Z"
"","28895","AnnotationUtils::findAnnotation no longer finds annotations on anonymous classes in Spring 6","In Spring 5, `AnnotationUtils.findAnnotation(Class, Class)`  would find the annotation on the following class: `Object foo = new @MyAnnotation Object() {};`, e.g. `AnnotationUtils.findAnnotation(foo, MyAnnotation.class)` would not return null.  With Spring 6.0.0-M5 / Java 17 the annotation will no longer be found.","closed","status: superseded,","janeisklar","2022-07-31T11:51:52Z","2022-08-01T07:29:53Z"
"","28141","Create XML NamespaceHandler as singleton","In some cases, the existing mechanism for creating a `NamespaceHandler` may result in repeated creation of the handler.  This PR changes the mechanism so that each `NamespaceHandler` is created as a singleton.","open","status: feedback-provided,","y987425112","2022-03-07T10:12:32Z","2022-04-14T14:09:30Z"
"","28245","CronExpression fails to calculate properly next execution when running on the day of daylight saving time (March 27, 2022)","In reference to https://github.com/spring-projects/spring-framework/issues/28095:  Affects: Spring Boot 2.6.4 / Framework 5.3.16 as well as newest versions Spring Boot 2.6.5 / Framework 5.3.17  We had an issue on DST switch on **Sunday, March 27, 2022** We're using a simple `TaskScheduler` bean and a method annotated with `@Scheduler(cron = ""0 30 2 * * ?"")`  The execution was just skipped when time was jumping from 2am to 3am. I've tried to...  - add the time zone to the taskScheduler ```     @Bean     public TaskScheduler taskScheduler(final TaskSchedulerBuilder taskSchedulerBuilder)     {         return taskSchedulerBuilder             .poolSize(10)             .customizers(taskScheduler -> taskScheduler.setClock(Clock.system(ZoneId.of(""Europe/Zurich""))))             .build();     } ``` -  add zone property to `@Scheduled` ```     @Scheduled(cron = ""0 30 2 * * ?"", zone = ""Europe/Zurich"")     public void run() { ... } ```  Both didn't work - tried it by resetting system time to March 27, 2022 - 01:59:30am.  During debugging I found `CronTrigger.nextExecutionTime()` always returning `2022-03-28T02:30:00+02:00` Is there anything else I have to configure so that the execution is not just skipped? Or do I need a custom handling for this?  I've checked documentation as well as previous issues / fixes and couldn't find any specifics on how to properly handle this scenario where an execution falls into the ""skipped"" time frame between 2am ... 3am  I've also tried it with the newest versions Spring Boot 2.6.5 / Framework 5.3.17 (because [this](https://github.com/spring-projects/spring-framework/issues/28095) was fixed) and resetting the time of my machine to March 27, 01:59:30am - the execution was skipped again","closed","in: core,","mf81bln","2022-03-29T12:05:48Z","2022-04-06T14:34:07Z"
"","28544","Always return a new instance of an empty BufferedReader","In our Spring boot application we're using the MockHttpServletRequest in our unit tests. Sometimes the content of the mocked request is null. In this case, when getting the reader, we're getting an instance of a StringReader for an empty string. The read method immediately returns -1 which means there is no content. So far this is the correct behaviour.  A problem occurs when you're creating multiple instances of the MockHttpServletRequest with its content set to null. When getting the reader I would expect getting a new reader instance for each mocked request. This is not the case, since if the content is null, a reader instance stored in a static variable will be returned. This is a problem because once reader is used for the first mocked request, it cannot be used for the second mocked request because the stream used by the reader is already closed.  To fix this issue I'm returning a new reader instance instead of using a static variable to always return the same instance. A unit test was added to reproduce the issue and to assert the fix is working as expected.","closed","status: waiting-for-triage,","ghost","2022-05-31T12:33:36Z","2022-06-29T17:56:39Z"
"","27962","Spring Actuator Env Endpoint does not validate request body","In our project, we are using Spring Boot Actuator (version 2.6.2) as well as Spring Cloud (2021.0.0) on Spring Boot Version 2.6.2.  My current objective is to implement a config editor, which enables the users of our product to manipulate our custom spring properties (properties in classes with @ConfigurationProperties) during runtime.   I'm currently somehow achieving this goal using a combined approach. This approach consists of sending a POST request to the /actuator/env endpoint (that's why Spring Cloud is a dependency of our project) with a valid HTTP request body as well as writing to an external application.yaml file, which stores these config overrides, in case the spring container has to restart (as all calls to /actuator/env only manipulate the Spring environment).   Lets say I have this configuraiton bean: ``` @Getter @Setter @Component @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS, value = ""prototype"") @ConfigurationProperties(prefix=""custom"") public class MyConfigurationClass {      String myProperty = ""Hello World"";  } ```  When I make a HTTP POST request to /actuator/env, my request body looks like the following: ``` {    ""name"": ""custom.my-property"",    ""value"": ""Hello"" } ```  This works fine as long the the value in the value property matches the type of the property, which is defined in the configuration bean. But let's say, the type of the property custom.my-property is of type int (or any other type), like this:  ``` @Getter @Setter @Component @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS, value = ""prototype"") @ConfigurationProperties(prefix=""custom"") public class MyConfigurationClass {      int myProperty = 12345;  } ```  When I now send my HTTP POST request with value = ""Hello World"", the problems (and potential bugs or things to improve) arise.   The /actuator/env endpoint seems to not make any validation of the request body. It looks like it changes the spring environment, but then spring cannot bind the new value to the configuration bean (ovioulsy, because a string cannot be bound to an integer). An exception occurs, and the response of the /actuatur/env endpoint contains the following:  ``` {     ""timestamp"": 1642671307254,     ""status"": 500,     ""error"": ""Internal Server Error"",     ""trace"": ""org.springframework.boot.context.properties.ConfigurationPropertiesBindException: Error creating bean with name 'scopedTarget.myConfigurationClass': Could not bind properties to 'MyConfigurationClass' : prefix=custom, ignoreInvalidFields=false, ignoreUnknownFields=true; nested exception is org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'custom.my-property' to int\r\n\tat org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.bind(ConfigurationPropertiesBindingPostProcessor.java:92)\r\n\tat org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.postProcessBeforeInitialization(ConfigurationPropertiesBindingPostProcessor.java:78)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:440)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:620)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:353)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)\r\n\tat org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1154)\r\n\tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:94)\r\n\tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:83)\r\n\tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:138)\r\n\tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:51)\r\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:176)\r\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:169)\r\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:143)\r\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:421)\r\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:378)\r\n\tat org.springframework.cloud.context.environment.EnvironmentManager.publish(EnvironmentManager.java:104)\r\n\tat org.springframework.cloud.context.environment.EnvironmentManager.setProperty(EnvironmentManager.java:92)\r\n\tat org.springframework.cloud.context.environment.WritableEnvironmentEndpointWebExtension.write(WritableEnvironmentEndpointWebExtension.java:47)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:282)\r\n\tat org.springframework.boot.actuate.endpoint.invoke.reflect.ReflectiveOperationInvoker.invoke(ReflectiveOperationInvoker.java:74)\r\n\tat org.springframework.boot.actuate.endpoint.annotation.AbstractDiscoveredOperation.invoke(AbstractDiscoveredOperation.java:60)\r\n\tat org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$ServletWebOperationAdapter.handle(AbstractWebMvcEndpointHandlerMapping.java:336)\r\n\tat org.springframework.boot.actuate.endpoint.web.servlet.AbstractWebMvcEndpointHandlerMapping$OperationHandler.handle(AbstractWebMvcEndpointHandlerMapping.java:421)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:150)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:117)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\r\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963)\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:681)\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:764)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327)\r\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:115)\r\n\tat org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:81)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:122)\r\n\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:116)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126)\r\n\tat org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:109)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter.doFilterInternal(BearerTokenAuthenticationFilter.java:137)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103)\r\n\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:91)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)\r\n\tat org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110)\r\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)\r\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211)\r\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183)\r\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:354)\r\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:267)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:96)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:540)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:382)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:895)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1732)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\r\n\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\nCaused by: org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'custom.my-property' to int\r\n\tat org.springframework.boot.context.properties.bind.Binder.handleBindError(Binder.java:384)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:344)\r\n\tat org.springframework.boot.context.properties.bind.Binder.lambda$bindDataObject$4(Binder.java:469)\r\n\tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:95)\r\n\tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:83)\r\n\tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:59)\r\n\tat org.springframework.boot.context.properties.bind.Binder.lambda$bindDataObject$5(Binder.java:473)\r\n\tat org.springframework.boot.context.properties.bind.Binder$Context.withIncreasedDepth(Binder.java:587)\r\n\tat org.springframework.boot.context.properties.bind.Binder$Context.withDataObject(Binder.java:573)\r\n\tat org.springframework.boot.context.properties.bind.Binder$Context.access$300(Binder.java:534)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bindDataObject(Binder.java:471)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bindObject(Binder.java:411)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:340)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:329)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:259)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:246)\r\n\tat org.springframework.boot.context.properties.ConfigurationPropertiesBinder.bind(ConfigurationPropertiesBinder.java:95)\r\n\tat org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.bind(ConfigurationPropertiesBindingPostProcessor.java:89)\r\n\t... 124 more\r\nCaused by: org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [int] for value 'test'; nested exception is java.lang.NumberFormatException: For input string: \""test\""\r\n\tat org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:47)\r\n\tat org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192)\r\n\tat org.springframework.boot.context.properties.bind.BindConverter.convert(BindConverter.java:109)\r\n\tat org.springframework.boot.context.properties.bind.BindConverter.convert(BindConverter.java:100)\r\n\tat org.springframework.boot.context.properties.bind.BindConverter.convert(BindConverter.java:92)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bindProperty(Binder.java:456)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bindObject(Binder.java:400)\r\n\tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:340)\r\n\t... 140 more\r\nCaused by: java.lang.NumberFormatException: For input string: \""test\""\r\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\r\n\tat java.base/java.lang.Integer.parseInt(Integer.java:668)\r\n\tat java.base/java.lang.Integer.valueOf(Integer.java:999)\r\n\tat org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:211)\r\n\tat org.springframework.core.convert.support.StringToNumberConverterFactory$StringToNumber.convert(StringToNumberConverterFactory.java:64)\r\n\tat org.springframework.core.convert.support.StringToNumberConverterFactory$StringToNumber.convert(StringToNumberConverterFactory.java:50)\r\n\tat org.springframework.core.convert.support.GenericConversionService$ConverterFactoryAdapter.convert(GenericConversionService.java:437)\r\n\tat org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:41)\r\n\t... 147 more\r\n"",     ""message"": ""Error creating bean with name 'scopedTarget.myConfigurationClass': Could not bind properties to 'MyConfigurationClass' : prefix=custom, ignoreInvalidFields=false, ignoreUnknownFields=true; nested exception is org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'custom.my-property' to int"",     ""path"": ""/actuator/env"" } ```  You would think now that the spring environment did not change because of that exception. But that is not the case. When I now request the value of the property custom.my-property (e.g. using springEnvironment.getProperty(""custom.my.property""), then the spring property holds the new value (""Hello""). I didn't check yet what happened to the configuration bean, whether it still holds the old (correct) int value or not.   And now it gets even crazier: When I send a second POST request (again with a String and not an integer) to /actuator/env, no exception occurs. It seems like Spring doesn't even try to bind the value anymore to the Configuraiton bean. But when I send a third request to /actuator/env, now with a correct integer value, then the exception occurs again. So to me it looks like Spring changes the data type internally somehow. At least some kind of magic happens that I don't understand.   Now the point ist: Shouldn't there be at least some validaiton at /actuator/env when this endpoint recieves POST requests? Some validation based on the configuration bean? And what about that strange ""type-alternating"" behaviour I described in the previous paragraph?","closed","for: external-project,","Walnussbaer","2022-01-20T09:46:54Z","2022-01-20T11:30:55Z"
"","28442","Add native hints for core annotations","In order to support native applications we need [hints for our core annotations](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-native-configuration/src/main/java/org/springframework/core/annotation/CoreAnnotationHints.java).","closed","theme: aot,","philwebb","2022-05-10T23:13:49Z","2022-05-11T00:10:27Z"
"","28160","Introduce RuntimeHintsRegistrar","In order to provide the possibility for registering `RuntimeHints`, the proposal is to introduce a `RuntimeHintsRegistrar` abstraction designed to address the same needs than [`BeanFactoryNativeConfigurationProcessor`](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-aot/src/main/java/org/springframework/aot/context/bootstrap/generator/infrastructure/nativex/BeanFactoryNativeConfigurationProcessor.java) and [`BeanNativeConfigurationProcessor`](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-aot/src/main/java/org/springframework/aot/context/bootstrap/generator/infrastructure/nativex/BeanNativeConfigurationProcessor.java) in Spring Native. It could even be used initially to register static hints as done with `@NativeHint` annotations.  ``` package org.springframework.beans.factory.hint;  public interface RuntimeHintsRegistrar {  	void registerHints(RuntimeHints hints, ListableBeanFactory beanFactory);  	default void ifPresent(String className, Runnable runnable) { 		if (ClassUtils.isPresent(className, null)) { 			runnable.run(); 		} 	} } ```    The `registerIfPresent` method is designed to provide a more discoverable mechanism to prevent `ClassNotFoundException` errors than inner classes.  Since they are designed to be used only AOT, `spring.factories` is not a good fit here, so implementations could be registered via a `META-INF/spring/org.springframework.beans.factory.hint.RuntimeHintsRegistrar.imports` file with the same format than [`org.springframework.boot.autoconfigure.AutoConfiguration.imports`]( https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports).","closed","theme: aot,","sdeleuze","2022-03-11T08:09:33Z","2022-04-14T11:42:54Z"
"","28891","Make BootstrapUtils.resolveTestContextBootstrapper() public","In order to create a `TestContextBootstrapper` outside the `org.springframework.test.context` package using the default lookup mechanisms, we need to make `BootstrapUtils.resolveTestContextBootstrapper()` public.  For example, this is required by #28204.","closed","type: enhancement,","sbrannen","2022-07-30T07:54:24Z","2022-07-30T08:16:28Z"
"","28624","Replace build-time initialization by constant field evaluation at build-time","In order to compile to native images and to provide a reasonable footprint, we are currently forced to initialize classes containing `ClassUtils#isPresent` checks at build time. A meaningful concrete example of that requirement is provided by Spring MVC support that does not compile unless a few classes are initialized at build time, see 2b76a12b86a62cc46886e1b7f0e52ea9d256f899.  The drawback is that this build time init of `WebMvcConfigurationSupport` and `RestTemplate` forces to initialize transitively all classes used in static fields/blocks at build time as well : `ClassUtils`, `SpringProperties`, `ConcurrentReferenceHashMap`. Worse : for other classes with similar pattern, if they contain a static loggers, this will force to initialize Logback at build time which is a dead end in term of compatibility as shown multiple times in Spring Native.  We are working on a middle-long term solution with GraalVM to replace build time init by another mechanism, less viral, with less compatibility issues. But for time being, we need to find a solution to this issue.  A pragmatic solution would be isolate classpath checks in a per module (`spring-core`, `spring-web`) class that would be itself init at build time but with no other purpose, removing the risk of viral expension of the classes init at build time. If we take the `WebMvcConfigurationSupport` use case, we would have something like:  ```java public abstract class ClasspathUtils {      private static final boolean romePresent;     private static final boolean jaxb2Present;     private static final boolean jackson2Present;      static {         // ...     }      public static boolean isRomePresent() { ... }     public static boolean isJaxb2Present() { ... }     public static boolean isJackson2Present() { ... }     // ... } ``` Bonus point, I think I like the fact that we provide reusable methods for classpath checks without arbitrary `String` parameter. Implementation would potentially even not use `ClassUtils` to limit the classes init at build time (not sure what is would use instead, to be discussed, not a blocking point).  Any thoughts @jhoeller @snicoll @bclozel?","closed","theme: aot,","sdeleuze","2022-06-14T14:03:33Z","2022-06-24T11:56:52Z"
"","28040","Upgrade to Dokka 1.6.10","In order to avoid `GC overhead limit exceeded` errors, see [this related comment](https://github.com/Kotlin/dokka/issues/1405#issuecomment-1022089083).","closed","type: task,","sdeleuze","2022-02-11T16:36:25Z","2022-02-11T17:26:14Z"
"","28244","Initialize NativeDetector at build time","In order to allow code removal with constructs like `if (NativeDetector.inNativeImage()) { ... } else { ... }`, `NativeDetector` needs to be initialized at build time. `-H:+InlineBeforeAnalysis` is enabled by default as of GraalVM 21.3 so no further configuration is needed.  Since build time initialization is not necessarily something we want to expose in public APIs, embedding a `spring-core/src/main/resources/META-INF/native-image/org.springframework/spring-core/native-image.properties` file for that purpose is the solution chosen for now.","closed","theme: aot,","sdeleuze","2022-03-29T06:47:07Z","2022-03-29T06:56:54Z"
"","28785","Make isConnected() in WebSocketConnectionManager public","In my case, I was creating a ReconnectTask to connect to my WebSocket server. Here I noticed that the method start() or startInternal() in the abstract class ConnectionManagerSupport always sets the boolean running to true. And it does this even if the connection could not be established. This means that it is not possible to add a retry-handling if the method start() or startInternal() can successfully establish the connection to the server.  But to be able to check yourself if the connection was successfully established you need access to the method isConnected().  But if there is another way to enable retry-handling for the connection to the server, an answer would help me.","open","type: enhancement,","npriebe","2022-07-11T13:29:46Z","2022-08-01T09:57:23Z"
"","28485","Do you consider using annotations to register web interceptors","In most scenarios in spring, declarative development is used. Do you consider using annotations to register interceptors, such as  ![image](https://user-images.githubusercontent.com/96010787/169226582-18a3f7a2-c66d-4f41-9264-c313c263ee85.png)","closed","in: web,","sleeprite","2022-05-19T06:36:38Z","2022-05-20T11:21:01Z"
"","28506","Support module path scanning for ""classpath*:"" resource prefix","In light of the findings from investigating #21515, we should introduce implicit support for scanning the module path whenever the `classpath*:` resource prefix is used.  This should allow existing applications relying on `classpath*:` semantics to work when migrating to the Java module system (for use cases not already supported by `ClassLoader`-based class path scanning).  For example, `@ComponentScan` should effectively work the same when an application is deployed on the class path or module path.","closed","type: enhancement,","sbrannen","2022-05-23T16:50:34Z","2022-05-25T13:07:11Z"
"","28762","Missing destroy-method warning intentional?","In latest Spring 6 milestones there's a warning logged now any time a default-destroy-method is set and the method is missing from any beans (one logged per bean):  e.g.: ```java 11:13:42.928 - WARN [org.springframework.beans.factory.support.DefaultListableBeanFactory:591] - Destruction of bean with name 'net.shibboleth.idp.saml.attribute.transcoding.AbstractSAML2AttributeTranscoder.NamingFunction#71a3a190' threw an exception java.lang.NullPointerException: Cannot invoke ""java.lang.reflect.Method.getParameterCount()"" because ""destroyMethod"" is null ```  I don't think Spring 5 or earlier has been logging this, and before we rototilled a lot of bean files I wanted to make sure this change was intentional and going to stay. It's certainly not wrong, just somewhat inconvenient for a lot of existing files.  I did note an old (like 2009) issue filed and fixed that mentions a similar NPE and perhaps had been ""fixed"", suggesting maybe this is not intentional.","open","status: waiting-for-triage,","scantor","2022-07-05T15:19:50Z","2022-07-05T15:20:22Z"
"","28778","Spring JDBC does not recognize LocalDate and LocalDateTime in javaType to sqlType Mapping","In class, StatementCreatorUtils, spring jdbc does not recognize LocalDate and LocalDateTime in javaTypeToSqlTypeMap and as a result they get categorized as UNKOWN_TYPE.  LocalDate and LocalDateTime have been available for years and we should try to include them in the framework.","closed","type: enhancement,","DhavalShewale","2022-07-08T14:32:43Z","2022-07-13T09:20:52Z"
"","28267","blacklist ""module"" property for ""class"" to mitigate Spring4Shell","In CachedIntrospectionResults there area there is a small snippet that blacklists 2 properties  				if (Class.class == beanClass && 						(""classLoader"".equals(pd.getName()) ||  ""protectionDomain"".equals(pd.getName()))) { 					// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those 					continue; 				}  btw - Looks like comment is no longer valid as ""exploiters"" are to one that ""needs to bind to those - so its not nobody ;) Exploit is using Java9+ class.module property to access classloader instances (tomcat specific ones). I think that ""module"" should be blacklisted as well here. Code would be compatible backwards.","closed","status: invalid,","Antoniossss","2022-04-01T06:49:30Z","2022-04-01T07:06:54Z"
"","28477","Allow changes to `org.springframework.web` log category at runtime","In a Spring Boot application using the `spring-boot-starter-actuator` loggers endpoint, setting the `web` log group, or any of it's individual member loggers, to `debug` level doesn't have any effect for RestTemplate logging.  We would like to be able to use the loggers endpoint to change the [web log group][0] logger levels on a deployed application in order to see web related debug logging.  It appears HttpAccessor is using an `org.springframework.core.log.CompositeLog` which initializes at application startup to current log levels, so adjusting the log levels through the actuator loggers endpoint doesn't have the desired effect.  # Steps to duplicate:  Create a Spring Boot application using spring-initializr with `spring-boot-starter-web` and `spring-boot-starter-actuator`. I am using Spring Boot 2.6.7  In application.properties, set:  ```properties logging.level.web=debug ```  ## Application code  ```java @SpringBootApplication @RestController public class DemoApplication {    private final RestTemplate restTemplate;    public DemoApplication(RestTemplateBuilder builder) {     this.restTemplate = builder.build();   }    @GetMapping   public String doSomething() {     return restTemplate.getForEntity(""https://httpbin.org/get"", String.class).getBody();   }    public static void main(String[] args) {     SpringApplication.run(DemoApplication.class, args);   }  } ```  ## Startup the application and execute:  ```shell curl --location --request GET 'localhost:8080/' ```  You should see the `[RestTemplate]` related logging in the application console.  Now comment out the logger line in `application.properties` and **restart** the application.  ## Now set the logger level after application startup using the actuators endpoint  ```shell curl --location --request POST 'http://localhost:8080/actuator/loggers/web' \ --header 'Content-Type: application/json' \ --data-raw '{   ""configuredLevel"": ""DEBUG"" }' ```  ## Call the endpoint again  ```shell curl --location --request GET 'localhost:8080/' ```  ## Outcome  No `[RestTemplate]` related logging occurs.  [0]: https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging.log-groups","closed","type: enhancement,","edwardsre","2022-05-18T21:07:04Z","2022-06-08T09:44:50Z"
"","28470","Introduce a way to indicate that an annotation needs to be visible at runtime","In a native image, an annotation will have no attributes until a dedicated hint is added, i.e.  ```json {     ""name"": ""org.springframework.core.annotation.Order"",     ""allDeclaredMethods"": true } ```  Without the above, the `value` attribute of Order is not available. Creating a process that handles all `org.springframework` annotations comes to mind, but there are a number of annotations that are build specific and should not be included. This includes anything configuration-class parsing related (such as `@Configuration`, `@Bean`, etc) and anything that has an explicit AOT handling that makes the annotation irrelevant at runtime.  Two ways comes to mind:  * Meta-annotate the annotation to indicate it does not have to be visible at runtime. * Create a contract that contributions could implement to indicate the annotations that they handle.","closed","theme: aot,","snicoll","2022-05-17T07:27:32Z","2022-06-08T12:01:21Z"
"","28322","Avoid duplicate application listeners (proxy vs. proxy target)","In `AbstractApplicationEventMulticaster.retrieveApplicationListeners`, despite best efforts to avoid it, unwrapped proxies (singleton targets) can end up in the list of programmatically registered listeners. In order to avoid duplicates, we need to find and replace them by their proxy counterparts, because if both a proxy and its target end up in `allListeners`, listeners will fire twice.  Fixes #28283.","open","in: core,","kriegaex","2022-04-11T07:53:12Z","2022-04-25T09:59:31Z"
"","28823","Allow empty path in MockMvc","In #24556 the use of a path without a leading slash was disallowed to avoid ambiguity between a path without a leading slash and a URL with a host but without a scheme. We could however allow an empty path which does not have the same issue.   This has come up after #28552, which turned off trailing slash support by default, and that in turn means that by default empty mappings only match to an empty input path.","closed","type: enhancement,","rstoyanchev","2022-07-14T11:36:51Z","2022-07-14T11:51:53Z"
"","27994","Improve SimpleJdbcCall for Oracle database","Improves SimpleJdbcCall when targeting the Oracle database:  - Improve support of Oracle PL/SQL packages for Spring JDBC: Oracle database stored procedures or functions can be overloaded. Hence, the possibility to find several matching signatures by just using the schema name, catalog name and procedure/function name is real. This PR adds columns data type checking to properly find the desired stored procedure or function.  - Ease debugging for DBMS_ packages if SYS not specified: explicitly checks the catalog name being used and if starting with DBMS_% and no matching signature was found then report in the log it could be useful to use SYS as the schema name","open","in: data,","loiclefevre","2022-02-01T21:41:00Z","2022-02-25T10:06:52Z"
"","28083","Private init/destroy method may be invoked twice","Imagine, you have a bean with an `init` method, annotated with `@PostConstruct` and a configuration class, referencing the same `init` method on its own.  ```java public class MyBean {      @PostConstruct     public void init() {         ...     }  } ```  ```java @Configuration public class MyConfiguration {      @Bean(initMethod = ""init"")     public MyBean myBean() {         return new MyBean();     } } ```  The `init` method will be invoked only once (what is pretty well).   This is true for all method modifiers except `private`. As soon as you change the method modifier to `private` the  `init` method is invoked twice.   ```diff public class MyBean {      @PostConstruct -    public void init() { +    private void init() {         ...     } } ```","closed","in: core,","levitin","2022-02-20T13:37:03Z","2022-03-01T16:16:06Z"
"","28005","Spring AOP support for prototype-scoped advice","If we use prototype-scoped aspect and use `args` pointcut expression, it will throw warning `no match for this type name: ss [Xlint:invalidAbsoluteTypeName]`，the arg havn't be binding.  Code like bellow:  ```java @Aspect(""perthis(execution(* com.tom.test.demo..*(..)))"") @Component @Scope(""prototype"") public class AspectJ {      @Before(""execution(* com.tom.test.demo..*(..)) && args(ss)"")     public  void pointCut(JoinPoint joinPoint,String ss) {         System.out.println(""????????????????????????"");     } } ```  This will throw exception   ``` Caused by: java.lang.IllegalArgumentException: warning no match for this type name: ss [Xlint:invalidAbsoluteTypeName] ```  If we use the follow code it will run well，but advise can't obtain parameter  ```java @Aspect(""perthis(execution(* com.tom.test.demo..*(..)))"") @Component @Scope(""prototype"") public class AspectJ {      @Before(""execution(* com.tom.test.demo..*(..)) && args(java.lang.String)"")     public  void pointCut(JoinPoint joinPoint) {         System.out.println(""????????????????????????"");     } } ```  Is this a bug, or is it meant to work so?","open","status: feedback-provided,","ZhongGuoDragon","2022-02-04T06:30:27Z","2022-03-04T17:53:03Z"
"","28407","spring-projects/spring-framework Spring AOP support for prototype-scoped advice","if we use prototype aspect expression, and we need args type is String,but we can input other type class,the aspect method is work. code like this:  ``` @Aspect(""perthis(execution(* com.tom.test.demo..*(..)))"") @Component @Scope(value = ""prototype"") //@Aspect("""") //@Component ////@Scope(value = ""prototype"") public class AspectJ2 {     private int num = 0;      @Before(""execution(* com.tom.test.demo..*(..)) && args(java.lang.String)"")     public  void pointCut(JoinPoint joinPoint) {         System.out.println(""????????????????????????"");         for (int i = 0; i < joinPoint.getArgs().length; i++) {             System.out.println(joinPoint.getArgs()[i].getClass());             System.out.println(joinPoint.getArgs()[i]);         }         System.out.println(""????????????????????????"");     } } ```  ``` package com.tom.test.demo;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component;  import java.util.ArrayList; import java.util.List;   @Component() public class Child extends Father{      public String  setStrings(Object object) {         return ""sssss"";     } } ```  ``` Child second = (Child) context.getBean(""child""); second.setStrings(""abcdefg""); second.setStrings(11111111); ```  the console will output:  > ???????????????????????? > class java.lang.String > abcdefg > ???????????????????????? > ???????????????????????? > class java.lang.Integer > 11111111 > ????????????????????????   i see the code   ``` package org.springframework.aop.aspectj.annotation;  public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut, 			Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory, 			MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {  		this.declaredPointcut = declaredPointcut; 		this.declaringClass = aspectJAdviceMethod.getDeclaringClass(); 		this.methodName = aspectJAdviceMethod.getName(); 		this.parameterTypes = aspectJAdviceMethod.getParameterTypes(); 		this.aspectJAdviceMethod = aspectJAdviceMethod; 		this.aspectJAdvisorFactory = aspectJAdvisorFactory; 		this.aspectInstanceFactory = aspectInstanceFactory; 		this.declarationOrder = declarationOrder; 		this.aspectName = aspectName;  		if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) { 			// Static part of the pointcut is a lazy type. 			Pointcut preInstantiationPointcut = Pointcuts.union( 					aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);  			// Make it dynamic: must mutate from pre-instantiation to post-instantiation state. 			// If it's not a dynamic pointcut, it may be optimized out 			// by the Spring AOP infrastructure after the first evaluation. 			this.pointcut = new PerTargetInstantiationModelPointcut( 					this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory); 			this.lazy = true; 		} 		else { 			// A singleton aspect. 			this.pointcut = this.declaredPointcut; 			this.lazy = false; 			this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut); 		} 	} } ```  this kind AspectJ will obtain PerTargetInstantiationModelPointcut and it's dynamic-match method is ` boolean matches(Method method, Class targetClass)` not `boolean matches(Method method, Class targetClass, Object... args)` so, it lost dynamic judge,so we can pass the AspectJ with a Integer or Other args,beacuse it only calculation static-match method, the  Child.setStrings(Object object) will pass any object.  ``` private static final class PerTargetInstantiationModelPointcut extends DynamicMethodMatcherPointcut {  		@Override 		public boolean matches(Method method, Class targetClass, Object... args) { 			// you can see this.declaredPointcut.matches(method, targetClass)) is not dynamic 			return (isAspectMaterialized() && this.declaredPointcut.matches(method, targetClass)); 		}  } ```","open","status: waiting-for-triage,","ZhongGuoDragon","2022-05-02T13:20:46Z","2022-05-02T13:25:17Z"
"","28312","GraalVM reflect config uses wrong format for inner classes","If we have a reflection hint for an inner class, GraalVM expects us to use a `$` to separate the parent from the inner class. Unfortunately, the serializer uses a `.` (canonical name).","closed","theme: aot,","snicoll","2022-04-10T08:01:25Z","2022-04-11T18:53:14Z"
"","28913","Native reflection configuration should consider `beanClass` attribute of bean definitions","If the `beanClass` attribute of a bean definition is configured, it should be considered when scanning for necessary reflection information, ultimately ending up in `reflect-config.json`. Currently, code that sets this attribute on a bean definition has to manually register the required property backing methods for reflection.","open","theme: aot,","odrotbohm","2022-08-02T12:31:45Z","2022-08-02T14:05:55Z"
"","28048","`ArrayToCollectionConverter` should default to `List` if target type is `Collection`","If one asks `ArrayToCollectionConverter` to convert an array to a `Collection` the delegating call to `CollectionFactory` results in a `LinkedHashSet` being used as conversion target.  I think it makes sense to rather default to a `List` based implementation in that particular case, as arrays naturally allow duplicates and retain order and handing a `Collection` as conversion target kind of indicates no preference in whether to retain those semantics or rather drop duplicates.","open","type: enhancement,","odrotbohm","2022-02-14T17:13:08Z","2022-06-14T20:42:46Z"
"","28122","Support constructor dependency injection by parameter name","If initializing bean via constructor dependency injection, Spring will do the candidates look-up by parameter type (essentially via `BeanFactoryUtils#beanNamesForTypeIncludingAncestors`) which is really slow if application getting huge. We are searching an approach to tell Spring to look-up candidates by constructor's parameter name.  I've read the code in `ConstructorResolver` but cannot find a way to achieve constructor dependency injection by parameter name. By the way there is a similar question on Stack Overflow: [Spring autowire by name constructor arguments](https://stackoverflow.com/questions/25161074/spring-autowire-by-name-constructor-arguments), there is just a work-around but not solution.  Can Spring support this feature if parameter name is available in runtime?  **Affects:** \","open","in: core,","alaneuler","2022-03-02T03:25:58Z","2022-03-02T10:18:04Z"
"","28483","The problem that field must be all capitalized when use Constants","If I use the construction method of Constants, the key in the fieldcache attribute is the attribute name and is not capitalized, but when I use the asxxxx method, the parameter code will be capitalized, resulting in no corresponding value ![image](https://user-images.githubusercontent.com/38170277/169243636-c8c8dacf-9412-4bec-bd4f-a0abde907008.png) ![image](https://user-images.githubusercontent.com/38170277/169243746-8d92d0c4-461e-480b-9154-bfc2385a5692.png) Why not capitalize when put？ Although the Java specification constants should be all capitalized, this is not mandatory. It is better if they are also capitalized when put！","open","status: waiting-for-triage,","wrj15034011352","2022-05-19T08:07:14Z","2022-05-19T08:10:21Z"
"","28062","List supported media types in HttpMediaTypeNotSupportedException when given invalid input media types","If I pass an unknown value in the `Content-Type` header (like e.g. `This string`) the `getSupportedMediaTypes()` returns falsely an empty list. If I don't pass this header (in case it is needed) the method works fine. Same when I pass a known value like e.g. `application/xml`. Can you fix that, please?","open","type: enhancement,","dirweis","2022-02-16T14:39:35Z","2022-02-16T15:36:22Z"
"","28073","Introduce configuration to disable @Scheduled tasks","If an application defines a `@Scheduled(fixedRateString = ""PT6H"")` tasks, then this task will be running on any `@SpringBootTest` `junit` test that does not explicit mock the bean containing the scheduled task.  ``` @Service public class SchedulerService {     @Scheduled(fixedRateString = ""PT6H"")     public void runOnStartup() {     } } ```  This gets tedious if there are many more `@Scheduled` tasks in the application that launch on startup by usage of `fixedRate` or `fixedRateString`.  It would be great if there could be a possibility to completely deactivate the execution of `@Scheduled` tasks in junit.  Just like it is possible to deactivate any `@Cacheable` annotation by simply setting `spring.cache.type=none` dring junit tests.  Something like: `spring.enable.scheduling=false` (default: true)","open","type: enhancement,","membersound","2022-02-17T10:45:00Z","2022-02-21T17:21:50Z"
"","28655","Add automatic hint for autowired field support","If a field is flagged with `@Autowired` the container uses reflection to set the value. A hint should have been generated automatically for this but it looks like that's not the case at the moment.","closed","theme: aot,","snicoll","2022-06-19T08:47:09Z","2022-06-20T09:25:54Z"
"","28915","Different order of invocations for ImportAware and EmbeddedValueResolverAware with AOT-optimized contexts","If a configuration class implements `ImportAware` and `EmbeddedValueResolverAware`, the `setEmbeddedValueResolver` method is invoked first, and then `setImportMetadata` is second.  When the application is compiled to native or running in AOT mode, the order of the method invocation switches, causing the `setImportMetadata` to be invoked first.  This is causing some problems [here](https://github.com/spring-projects/spring-session/blob/cc4a15db79fd49dc8e7172da4e072bf4c2c869bd/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/server/RedisWebSessionConfiguration.java#L153) in Spring Session  **Sample** https://github.com/marcusdacoregio/embedded-value-resolver-aware-native  When running in the JVM: ``` 2022-08-02T11:09:00.042-03:00  INFO 94512 --- [           main] com.example.MyConfig                     : Setting resolver org.springframework.beans.factory.config.EmbeddedValueResolver@7a138fc5 2022-08-02T11:09:00.043-03:00  INFO 94512 --- [           main] com.example.MyConfig                     : Setting import metadata org.springframework.beans.factory.config.EmbeddedValueResolver@7a138fc5 ```  When running native or AOT-optimized (notice that resolver is null): ``` 2022-08-02T11:07:41.389-03:00  INFO 94483 --- [           main] com.example.MyConfig                     : Setting import metadata null 2022-08-02T11:07:41.389-03:00  INFO 94483 --- [           main] com.example.MyConfig                     : Setting resolver org.springframework.beans.factory.config.EmbeddedValueResolver@68d0f8c8 ```","open","theme: aot,","marcusdacoregio","2022-08-02T14:10:52Z","2022-08-02T15:19:18Z"
"","28148","Add support for contributing runtime hints for generated code","If a component wishes to contribute hints for generated code, it can use `TypeReference.of` taking a `String` but we could just as well offer a way to create a type reference using a `ClassName`.","closed","theme: aot,","snicoll","2022-03-09T09:50:00Z","2022-03-09T10:19:01Z"
"","28700","Better documentation of HTTP streaming responses with Webflux & Reactor Netty","I've tried Stackoverflow for this but didn't receive an answer. I open this issue for two reasons - to ask whether what I try to do is possible (and how?), and to raise the fact that there is a lack of documentation for Webflux's HTTP streaming. I think the answer to this basic question should be added to [the documentation of HTTP streaming ](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs-streaming) with Webflux (a use case that fits Webflux very well).  Currently, Webflux doesn't include an example for HTTP streaming, and on the internet that's pretty easy to find simple streaming use cases of returning `String`/ POJOs. It's hard to find examples for returning bytes. My use case is that I want to create a Webflux server that has a route that receives some parameters, sends a request to another server that **streams** a `.zip` file, and streams its response to the user. The third-party streaming API works properly, but I'm not sure how can I return its response to the user with Webflux and Reactor Netty.  I've tried: ```java @GetMapping(value = ""/zip/stream"") public WebClient.ResponseSpec getZipStream(@RequestParam String myParam) {     Mono requestBody = getRequestBody(myParam);     return WebClient.create(appConfig.getRemoteApiUrl())             .post().uri(""/download"")             .body(BodyInserters.fromProducer(requestBody, ZipRemoteEntry.class))             .accept(MediaType.APPLICATION_OCTET_STREAM)             .retrieve(); } ```  Which (with justification) results: ``` org.springframework.core.codec.CodecException: Type definition error: [simple type, class org.springframework.web.reactive.function.client.DefaultWebClient$DefaultResponseSpec]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.springframework.web.reactive.function.client.DefaultWebClient$DefaultResponseSpec and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) ```  I've also tried that with `DataBuffer` (that has a [built-in codec](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#codecs)): ```java @GetMapping(value = ""/zip/stream"") public Flux getZipStream(@RequestParam String myParam) {     Mono requestBody = getRequestBody(myParam);     return WebClient.create(appConfig.getRemoteApiUrl())             .post().uri(""/download"")             .body(BodyInserters.fromProducer(requestBody, ZipRemoteEntry.class))             .accept(MediaType.APPLICATION_OCTET_STREAM)             .retrieve()             .bodyToFlux(DataBuffer.class); } ```  That resulted (same when using `ByteBuffer` or `ByteBufFlux`): ``` 2022-06-21 21:17:46.000 ERROR 32492 --- [ctor-http-nio-2] a.w.r.e.AbstractErrorWebExceptionHandler : [dc0db90c-1]  500 Server Error for HTTP GET ""/zip/stream?myParam=--""  org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://my-test-server/download 	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:196) ~[spring-webflux-5.3.18.jar:5.3.18] 	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  ```  That also makes sense, since I didn't really use Netty properly (I haven't closed the buffer since I'm not sure how to do this with Reactor Netty & Webflux).  I'd like to know what is the correct way of streaming data like zip. I know I probably need to stream `DataBuffer` or `ByteBuffer` kind of object, but I didn't manage to find how to do that with Reactor Netty and Webflux.","closed","for: stackoverflow,","almogtavor","2022-06-24T13:10:23Z","2022-06-24T13:54:14Z"
"","28908","Fix broken kdoc-api links in kotlin.adoc","I've read [6.0.0.M4 docs](https://docs.spring.io/spring-framework/docs/6.0.0-M4/reference/html/languages.html) and found broken links about kdoc-api. It seems to have broken since [5.3.10](https://docs.spring.io/spring-framework/docs/5.3.10/reference/html/languages.html).","open","status: waiting-for-triage,","chanhyeong","2022-08-02T05:44:16Z","2022-08-02T05:45:45Z"
"","28466","Provide guidance on using @Nested within test classes with complex inheritance and annotation arrangements","I've provided a minimal JUnit Jupiter test `ConcreteServiceTest` reproducing the problem. Please check the code first. The issue is that the mock is not reset so the second test fails since there are 2 calls instead of the expected 1. The use case has a common base service and similarly base test class.  Some observations:  - If the `@Import(ConcreteService.class)` is moved on top of the base class the tests pass. - If the tests are flattened (not using `@Nested` test class) then the tests pass. - `@AfterEach void clearMocks() { reset(dependency); }` would make the tests pass as well. I've chosen this as the simplest workaround for the time being (assuming the issue will be fixed and then the method will be simply deleted instead of altering the structure of my code).  Spring Boot version: 2.6.2  ```java import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.RepeatedTest; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.context.annotation.Import; import org.springframework.test.context.junit.jupiter.SpringExtension;  import static org.mockito.Mockito.verify;  @Import(ConcreteService.class) class ConcreteServiceTest extends BaseServiceTest { }  @ExtendWith(SpringExtension.class) abstract class BaseServiceTest {      @MockBean     private Runnable dependency;     @Autowired     private BaseService service;      @Nested     class Suite {          @RepeatedTest(2)         void test() {             service.serve();              verify(dependency).run();         }     } }  class ConcreteService extends BaseService { }  abstract class BaseService {      @Autowired     private Runnable dependency;      public void serve() {         dependency.run();     } } ```","open","type: documentation,","GeorgiPetkov","2022-04-09T19:05:27Z","2022-06-27T16:24:22Z"
"","28564","JsonView regression","I've just upgraded to Spring Boot 2.5.12 and I noticed a regression in the @JsonView annotation support. Previously, it used to work by annotating the whole class, while after the upgrade I had to explicitly annotate the individual methods, since on a class level it gets somehow ignored.  See the demo app I've created here   https://github.com/gkgeorgiev/spring-jsonview-bug  Thanks!","open","status: waiting-for-triage,","gkgeorgiev","2022-06-03T16:51:44Z","2022-06-03T16:55:18Z"
"","28643","Introduce lenient parsing in DataSize regarding whitespace","I've just helped a user correct a configuration mistake where they'd tried to configure a `DataSize` with a string of `2KB `. This resulted in a conversion failure due to the trailing whitespace as neither `StringToDataSizeConverter` nor `DataSize.parse` trims the input. By contrast other areas of Framework such as `CustomBooleanEditor` do trim before attempting conversion.  Could the various property editors and converters be updated to consistently trim whitespace when it's irrelevant to the target type?","closed","type: enhancement,","wilkinsona","2022-06-16T20:09:18Z","2022-07-04T17:37:15Z"
"","28767","RuntimeHintsUtils#registerAnnotation fails to register SynthesizedAnnotation proxy","I've encountered a use-case in which `RuntimeHintsUtils.registerAnnotation` isn't enough to work with the annotation in a native setting. I'm using this code:  ```java RuntimeHintsUtils.registerAnnotation(hints, Endpoint.class); ```  where `Endpoint` is `org.springframework.boot.actuate.endpoint.annotation.Endpoint`:  ```java @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Reflective public @interface Endpoint {  	String id() default """";  	boolean enableByDefault() default true;  } ```  There are no `@AliasFor` annotations used, so `RuntimeHintsUtils.registerAnnotation` won't register a proxy for `Endpoint` and `SynthesizedAnnotation`.  But if `Endpoint` [is now used in this code](https://github.com/spring-projects/spring-boot/blob/4fd2e0c91619dc51a69328df5e5195d86d9503ac/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/annotation/EndpointDiscoverer.java#L130):  ```java String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(this.applicationContext, Endpoint.class); ```  it fails with  ``` Caused by: com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces [interface org.springframework.boot.actuate.endpoint.annotation.Endpoint, interface org.springframework.core.annotation.SynthesizedAnnotation] not found. Generating proxy classes at runtime is not supported. Proxy classes need to be defined at image build time by specifying the list of interfaces that they implement. To define proxy classes use -H:DynamicProxyConfigurationFiles= and -H:DynamicProxyConfigurationResources= options. 	at com.oracle.svm.core.util.VMError.unsupportedFeature(VMError.java:89) ~[na:na] 	at com.oracle.svm.reflect.proxy.DynamicProxySupport.getProxyClass(DynamicProxySupport.java:158) ~[na:na] 	at java.lang.reflect.Proxy.getProxyConstructor(Proxy.java:48) ~[actuator-aot:na] 	at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:1037) ~[actuator-aot:na] 	at org.springframework.core.annotation.SynthesizedMergedAnnotationInvocationHandler.createProxy(SynthesizedMergedAnnotationInvocationHandler.java:305) ~[na:na] 	at org.springframework.core.annotation.TypeMappedAnnotation.createSynthesizedAnnotation(TypeMappedAnnotation.java:333) ~[na:na] 	at org.springframework.core.annotation.AbstractMergedAnnotation.synthesize(AbstractMergedAnnotation.java:210) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.core.annotation.AbstractMergedAnnotation.synthesize(AbstractMergedAnnotation.java:200) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAnnotationOnBean(DefaultListableBeanFactory.java:733) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAnnotationOnBean(DefaultListableBeanFactory.java:723) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForAnnotation(DefaultListableBeanFactory.java:693) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.getBeanNamesForAnnotation(AbstractApplicationContext.java:1301) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(BeanFactoryUtils.java:285) ~[na:na] 	at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.createEndpointBeans(EndpointDiscoverer.java:130) ~[actuator-aot:3.0.0-SNAPSHOT] 	at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.discoverEndpoints(EndpointDiscoverer.java:123) ~[actuator-aot:3.0.0-SNAPSHOT] 	at org.springframework.boot.actuate.endpoint.annotation.EndpointDiscoverer.getEndpoints(EndpointDiscoverer.java:117) ~[actuator-aot:3.0.0-SNAPSHOT] 	at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration$WebMvcServletEndpointManagementContextConfiguration.servletEndpointRegistrar(ServletEndpointManagementContextConfiguration.java:61) ~[actuator-aot:0.0.1-SNAPSHOT] 	at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration_WebMvcServletEndpointManagementContextConfiguration__BeanDefinitions.lambda$getServletEndpointRegistrarInstance$0(ServletEndpointManagementContextConfiguration_WebMvcServletEndpointManagementContextConfiguration__BeanDefinitions.java:45) ~[na:na] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:63) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:51) ~[actuator-aot:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:156) ~[na:na] 	at org.springframework.boot.actuate.autoconfigure.endpoint.web.ServletEndpointManagementContextConfiguration_WebMvcServletEndpointManagementContextConfiguration__BeanDefinitions.getServletEndpointRegistrarInstance(ServletEndpointManagementContextConfiguration_WebMvcServletEndpointManagementContextConfiguration__BeanDefinitions.java:45) ~[na:na] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1224) ~[actuator-aot:6.0.0-SNAPSHOT] 	... 50 common frames omitted ```  It seems like `@AliasFor` isn't the only thing which should trigger proxy creation.  At the moment I'm working around this with:  ```java hints.proxies().registerJdkProxy(Endpoint.class, SynthesizedAnnotation.class); ```","closed","theme: aot,","mhalbritter","2022-07-06T11:51:58Z","2022-07-29T11:39:25Z"
"","27999","Content Negotiation with media type parameters: Method producing exact match of Access content type is not called.","I'm working on an API that produces `application/hal+json` documents that use the media type `profile` parameter to support versioning.  The structure of the controller looks like this: ```kotlin @RestController @RequestMapping(""/hal-documents"") class MyController {     @GetMapping(produces = [""application/hal+json;charset=UTF-8""])     fun getWithoutProfile() : ResponseEntity {...}      @GetMapping(produces = [""""""application/hal+json;profile=""my-resource-v1""""""""])     fun getV1() : ResponseEntity {...}      @GetMapping(produces = [""""""application/hal+json;profile=""my-resource-v2""""""""])     fun getV2() : ResponseEntity {...} } ``` If I execute a request, which `Accept`-Header exactly matches the media type produced by `getV1`, the method is not being called. Instead, the request is being routed to `getWithoutProfile`.  This seems to be wrong. I would expect that the best matching method is being called. Routing works correctly if the `charset` parameter is removed from the `getWithoutProfile` method.  **Affects:** 5.3.15","closed","status: declined,","thake","2022-02-03T10:42:44Z","2022-02-14T11:52:36Z"
"","28730","MockHttpServletResponse addHeader does not allow Comment part with Set-Cookie header","I'm using the following dependency for using `MockHttpServletResponse` for unit tests.  ```xml  	org.springframework 	spring-test 	6.0.0-M4 	test  ```  Please see below test case where it shows that `addHeader/getHeader` methods from `MockHttpServletResponse` object do not return the same value; particularly the `Comment` part is stripped out.  I tried adding the same in Jetty container, and Jetty does not seem to strip the comment part.  Also note that other header names like `Set-CookieTest` preserve the `Comment` part which seems to indicate that it only strips when encountering the `Set-Cookie` header name.  ```java     @Test     void addHeader() throws Exception {         MockHttpServletResponse servletResponse = new MockHttpServletResponse();         servletResponse.addHeader(""Set-Cookie"", ""NOT_SAFE=;Domain=mydomain.com;Comment=COOKIECLEANER;Path=/;Expires=Thu, 01 Jan 1970 00:00:00 GMT"");         System.out.println(""MockHttpServletResponse: "" + servletResponse.getHeader(""Set-Cookie""));     } ```  Output:  `MockHttpServletResponse: NOT_SAFE=; Path=/; Domain=mydomain.com; Expires=Thu, 1 Jan 1970 00:00:00 GMT`","closed","type: bug,","charlesk40","2022-06-29T19:05:25Z","2022-06-30T16:21:15Z"
"","28220","@RequestParam with defaultValue of empty string on String parameter gives null but not empty String","I'm using a @RequestParam on a String parameter, gives `defaultValue = """"`. When I call the api without this parameter, I suppose to get an empty value of String """" but got null in my case.  Example that creates the bug:  ``` @GetMapping public String search(@RequestParam(defaultValue = """") String email) {     System.out.println(""Email should be an empty string if not provided: "" + email);     return email; } ``` When I call this api with no parameter, I got ""null"" in my console rather than """" (empty String value).","closed","in: web,","Adamatoma","2022-03-23T06:22:29Z","2022-05-09T10:35:23Z"
"","28703","`GenericApplicationContext` does not honor `ProtocolResolver` when a resource loader is set via `setResourceLoader()`","I'm trying to intercept certain URL patterns to resolve into the correct `UrlResource`, but the application context does not honour custom protocol resolvers.  In pseudocode:  ```java GenericApplicationContext applicationContext = new GenericApplicationContext(); applicationContext.setResourceLoader(someResourceLoader); applicationContext.addProtocolResolver(new CustomUrlResolver()); applicationContext.getResource(""http://some.custom.url/""); // never resolved via CustomUrlResolver ```  The `CustomUrlResolver` resolver is never invoked because `someResourceLoader` takes precedence in `getResource`. Unfortunately, there's no way to work around this issue by adding a delegating resource loader, since there's no accessor for the resource loader.  I believe that the `setResourceLoader(...)` call is done somewhere in Spring Boot.  I had to do `setResourceLoader(null)`. This is likely going to break things.","closed","in: core,","arteymix","2022-06-24T17:53:23Z","2022-06-27T16:20:17Z"
"","28042","Support parse placeholder in beanName","I'm not sure if there is a more elegant way to deal with it. If this proposal can be adopted, I hope you can give me more advice I can confirm that the following problems exist `     ` bean name=${bean.name:product} Instead of product or bean.name=xxxx  I would like to be able to support placeholder resolution beanname  fixes #27224","open","in: core,","a364176773","2022-02-11T17:45:04Z","2022-04-25T09:37:46Z"
"","28035","gradle resolves spring-boot-starter external dependency differently depending on gradle's version","I'm not certain whether this problem is caused by spring or gradle or my local environment.  **Summary**: Webflux App runs on different server(tomcat, netty) by gradle's version   My spring webflux project has dependencies like this: ``` plugins { 	id 'org.springframework.boot' version '2.3.3.RELEASE' 	id 'io.spring.dependency-management' version '1.0.10.RELEASE' 	id 'java' }  ...  dependencies {  	implementation 'org.springframework.boot:spring-boot-starter-validation' 	implementation 'org.springframework.boot:spring-boot-starter-webflux' 	implementation 'org.springframework.boot:spring-boot-starter-actuator' 	implementation 'net.rakugakibox.spring.boot:logback-access-spring-boot-starter:2.7.1'   	 	... } ```  and gradle-wrapper.properties: ``` distributionUrl=https\://services.gradle.org/distributions/gradle-6.3-all.zip distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStorePath=wrapper/dists zipStoreBase=GRADLE_USER_HOME ```  Under this dependencies and gradlew settings, spring boot run Netty server as default as I expected. The problem occured when I changed `gradle-wrapper.properties` files like this(I just updated version):  ``` distributionUrl=https\://services.gradle.org/distributions/gradle-7.4-all.zip distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists zipStorePath=wrapper/dists zipStoreBase=GRADLE_USER_HOME ```  Now my spring boot project has dependency `org.springframework.boot:spring-boot-starter-tomcat:2.3.3.RELEASE` (It also has dependency on `org.springframework.boot:spring-boot-starter-reactor-netty:2.3.3.RELEASE` still)  I guess `org.springframework.boot:spring-boot-starter-tomcat:2.3.3.RELEASE` comes from `net.rakugakibox.spring.boot:logback-access-spring-boot-starter:2.7.1`'s dependency.  Now the application runs server **not on Netty, but on Tomcat**.  Where does the issue lies? and How can I fix this issue? Thank you.","closed","for: external-project,","emiatej9","2022-02-11T05:33:18Z","2022-02-11T07:15:16Z"
"","27971","Spring AOP cannot generate proxy for lambda on Java 16+","I'm migrating to Java 17 and found an issue with proxy generation for 'lambda beans'.  - Spring Boot: 2.6.3 - Maven: 3.8.4 - Java: ``` openjdk version ""17.0.2"" 2022-01-18 LTS OpenJDK Runtime Environment Corretto-17.0.2.8.1 (build 17.0.2+8-LTS) OpenJDK 64-Bit Server VM Corretto-17.0.2.8.1 (build 17.0.2+8-LTS, mixed mode, sharing) ```  Spring AOP cannot generate a proxy for beans like:  ```java     @Bean     public Supplier stringSupplier() {         return () -> ""lambda supplier value"";     } ```  Errors: ``` Caused by: org.springframework.aop.framework.AopConfigException:  Could not generate CGLIB subclass of class com.example.issue.aopissue.service.IssueConfiguration$$Lambda$638/0x0000000800e796e0:  Common causes of this problem include using a final class or a non-visible class;  nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.reflect.InaccessibleObjectException-- >Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)  throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @5ecddf8f  ```  But if I use class implementation it works fine:  ```java public class TestSupplierService implements Supplier {      @Override     public String get() {         return ""class supplier value"";     } } ```  I prepared demo project [aop-issue](https://github.com/Ferioney/aop-issue) to show the issue:  - [Application Configuration](https://github.com/Ferioney/aop-issue/blob/main/src/main/java/com/example/issue/aopissue/service/IssueConfiguration.java) - [Aspect Configuration](https://github.com/Ferioney/aop-issue/blob/main/src/main/java/com/example/issue/aopissue/aspect/AspectConfig.java) - [Test with lambda bean, context doesn't start](https://github.com/Ferioney/aop-issue/blob/main/src/test/java/com/example/issue/aopissue/AopLambdaImplementedTests.java) - [Test with clas implementation, works as expected](https://github.com/Ferioney/aop-issue/blob/main/src/test/java/com/example/issue/aopissue/AopClassImplementedTests.java)","closed","type: enhancement,","Ferioney","2022-01-24T16:40:26Z","2022-02-09T09:02:04Z"
"","28768","spring-modules-jbpm31 0.8 version compatible with Spring 5.3.20","I'm migrating from Spring 3 to Spring 5, I getting the following exception  Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springmodules.workflow.jbpm31.LocalJbpmConfigurationFactoryBean]: Constructor threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/beans/factory/access/BeanFactoryLocator  One of the classes in spring-modules-jbpm31 jar is referring to BeanFactoryLocator which is removed in Spring 5.   Is there any alternative for spring-modules-jbpm31 which is compatible with Spring 5?   Any input related to fixing this would be helpful.   Thanks in Advance","open","status: waiting-for-triage,","kawinprabhakaran","2022-07-06T13:08:54Z","2022-07-07T12:51:33Z"
"","28053","Add RequestAttributes setter to WebTestClient","I'm migrating a few tests from `MockMvc` to `WebTestClient`.  Unfortunately the following cannot be refactored, as there is no `RequestAttribute` setter in `WebTestClient`.  ```java @Test public void test() { 	String body = mvc.perform(MockMvcRequestBuilders.get(""/error?format=csv"") 			.requestAttr(RequestDispatcher.ERROR_EXCEPTION, new RestClientException(""junit"")) 			.requestAttr(RequestDispatcher.ERROR_MESSAGE, ""csv error"")) 			.andReturn() 			.getResponse() 			.getContentAsString();  	assertEquals(""csv error"", body); } ```  with application.properties: ``` spring.mvc.contentnegotiation.media-types.csv=text/plain ```  Would be great if `RequestAttribute` could also be set in `WebTestClient`!","closed","status: declined,","membersound","2022-02-15T13:25:36Z","2022-02-16T12:22:25Z"
"","28292","Fix CVE-2022-22965 in 4.3.x","I would like to contribute and fix CVE-2022-22965 for 4.3.x.  Is this possible (branch allows committing, etc) ? If yes, what is the detailed procedure in order to get a new jar?","closed","status: declined,","adrianmarinescu1","2022-04-06T13:51:32Z","2022-04-06T13:55:02Z"
"","27911","Introduce YamlBeanDefinitionReader","I would like to add YAML support to the bean definition reader like Kubernetes resource list to upgrade readability of bean definitions.","closed","in: core,","strongfist","2022-01-10T14:39:35Z","2022-01-14T17:11:16Z"
"","28191","Dependency Injection into WebMVC controller is dependent on named objects too tightly in testing environment","I will be straightforward, honestly not sure where to post this exactly but this was probably the weirdest bug we ever had. A few lines of code say more than a thousand words: This is from a university project where we develop a web application for students to track exams and vacation time during a specific timeframe. Its shortened to relevant parts.  ```java @Controller @Secured(""ROLE_STUDENT"") public class StudentController {   private final ApplicationService applicationService;   public StudentController(ApplicationService applicationService) {     this.applicationService = applicationService;   }    @PostMapping(""/klausuren"")   public String insertKlausur(KlausurInputDTO klausur) {     applicationService.insertKlausur(klausur);     return ""redirect:/klausuranmeldung"";   } }   ```` This works just fine in the normal runtime environment outside of testing. The KlausurInputDTO is simply a record with a few attributes which will be infered and then injected through the spring framework from the POST request payload. Testing this method results in the following code (again shortened to relevant bits): ```java @WebMvcTest @AutoConfigureMockMvc public class StudentControllerTest {   @Autowired   MockMvc mvc;   @MockBean   ApplicationService appService;      @Test   @WithMockUser(""Test"")   @DisplayName(""Controller calls insertKlausur"")   void test_7() throws Exception {     KlausurInputDTO klausurInputDTO = KlausurInputDTOTestData.build(K123_PRAESENZ_12_30_TO_14_30);     RequestBuilder builder = MockMvcRequestBuilders.post(""/klausuren"")         .flashAttr(""klausur"", klausurInputDTO)         .with(csrf());     mvc.perform(builder);     verify(appService, times(1)).insertKlausur(klausurInputDTO);   } } ```  The test results in an error 400 - Bad request. The bug in this code exists in the naming of the KlausurInputDTO object, during a test environment we somehow need to have the name of the object be the same as its datatype. therefore the fixed code would be (relevant parts only): ```java   @PostMapping(""/klausuren"")   public String insertKlausur(KlausurInputDTO klausurInputDTO) {     applicationService.insertKlausur(klausurInputDTO);     return ""redirect:/klausuranmeldung"";   }  ``` and  ```java   void test_7() throws Exception {     KlausurInputDTO klausurInputDTO = KlausurInputDTOTestData.build(K123_PRAESENZ_12_30_TO_14_30);     RequestBuilder builder = MockMvcRequestBuilders.post(""/klausuren"")         .flashAttr(""klausurInputDTO"", klausurInputDTO)         .with(csrf());     mvc.perform(builder);     verify(appService, times(1)).insertKlausur(klausurInputDTO);   } ``` this binds the naming of the object incredibly tightly and makes for quite an obscure bug.  This issue only arises while using the testing environment and not when actually running the application normally. lastly here is the build.gradle with the dependency stuff (once again shortened): ``` plugins {     id 'org.springframework.boot' version '2.6.4'     id 'io.spring.dependency-management' version '1.0.11.RELEASE'     id 'java'     id ""com.github.spotbugs"" version ""4.7.9""     id ""checkstyle"" }    dependencies {     implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'     implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'     implementation 'org.springframework.boot:spring-boot-starter-security'     implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'     implementation 'org.springframework.boot:spring-boot-starter-validation'     implementation 'org.springframework.boot:spring-boot-starter-web'     implementation 'org.flywaydb:flyway-core'     implementation 'org.springframework.session:spring-session-core'     implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity5'     implementation 'com.github.hazendaz.jsoup:jsoup:1.15.1'     implementation 'com.google.guava:guava:31.1-jre'     developmentOnly 'org.springframework.boot:spring-boot-devtools'     runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'     runtimeOnly 'com.h2database:h2'     compileOnly 'com.github.spotbugs:spotbugs-annotations:4.6.0'      testImplementation 'org.springframework.boot:spring-boot-starter-test'     testImplementation 'org.springframework.security:spring-security-test'     testImplementation 'com.tngtech.archunit:archunit-junit5-engine:0.22.0' } ```","closed","for: stackoverflow,","Daniel-Mueller96","2022-03-16T19:54:53Z","2022-03-17T15:42:01Z"
"","28308","The task ':spring-core:cglibRepackJar'  Execution failed !","I was downloaded the source spring-framework-5.3.x and follow the build and export to eclipse seteps，there are no error in sts4，but when i execute the gradle task，it executed failed.That's all the logs:  ``` Working Directory: F:\00OpenSource\SourceCode\spring-framework-5.3.x Gradle user home: E:\gradle_user_home Gradle Distribution: Gradle wrapper from target build Gradle Version: 7.2 Java Home: D:\Program Files\sts-4.12.0.RELEASE\plugins\org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_16.0.2.v20210721-1149\jre JVM Arguments: None Program Arguments: None Build Scans Enabled: false Offline Mode Enabled: false Gradle Tasks: api  > Task :buildSrc:compileJava UP-TO-DATE > Task :buildSrc:compileGroovy NO-SOURCE > Task :buildSrc:pluginDescriptors UP-TO-DATE > Task :buildSrc:processResources UP-TO-DATE > Task :buildSrc:classes UP-TO-DATE > Task :buildSrc:jar UP-TO-DATE > Task :buildSrc:assemble UP-TO-DATE > Task :buildSrc:pluginUnderTestMetadata UP-TO-DATE > Task :buildSrc:compileTestJava NO-SOURCE > Task :buildSrc:compileTestGroovy NO-SOURCE > Task :buildSrc:processTestResources NO-SOURCE > Task :buildSrc:testClasses UP-TO-DATE > Task :buildSrc:test NO-SOURCE > Task :buildSrc:validatePlugins UP-TO-DATE > Task :buildSrc:check UP-TO-DATE > Task :buildSrc:build UP-TO-DATE fatal: not a git repository (or any of the parent directories): .git > Task :spring-aop:processResources UP-TO-DATE > Task :spring-beans:processResources UP-TO-DATE > Task :spring-aspects:processResources UP-TO-DATE > Task :spring-core:cglibRepackJar FAILED > Task :spring-context:processResources UP-TO-DATE > Task :spring-expression:processResources UP-TO-DATE > Task :spring-context-support:processResources UP-TO-DATE > Task :spring-jdbc:processResources UP-TO-DATE > Task :spring-instrument:compileJava FROM-CACHE > Task :spring-context-indexer:compileJava FROM-CACHE > Task :spring-jcl:compileJava FROM-CACHE  FAILURE: Build failed with an exception.  * What went wrong: Execution failed for task ':spring-core:cglibRepackJar'. > Failed to load cache entry for task ':spring-core:cglibRepackJar'  * Try: Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.  * Get more help at https://help.gradle.org  BUILD FAILED in 5s 17 actionable tasks: 1 executed, 3 from cache, 13 up-to-date Build scan background action failed. org.gradle.process.internal.ExecException: Process 'command 'git'' finished with non-zero exit value 128 	at org.gradle.process.internal.DefaultExecHandle$ExecResultImpl.assertNormalExitValue(DefaultExecHandle.java:414) 	at org.gradle.process.internal.DefaultExecAction.execute(DefaultExecAction.java:38) 	at org.gradle.process.internal.DefaultExecActionFactory.exec(DefaultExecActionFactory.java:205) 	at io.spring.ge.conventions.gradle.WorkingDirectoryProcessOperations.exec(WorkingDirectoryProcessOperations.java:45) 	at io.spring.ge.conventions.gradle.ProcessOperationsProcessRunner.run(ProcessOperationsProcessRunner.java:40) 	at io.spring.ge.conventions.gradle.BuildScanConventions.run(BuildScanConventions.java:195) 	at io.spring.ge.conventions.gradle.BuildScanConventions.addGitMetadata(BuildScanConventions.java:139) 	at com.gradle.enterprise.gradleplugin.internal.extension.b$4.run(SourceFile:177) 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630) 	at java.base/java.lang.Thread.run(Thread.java:831) ```  A build scan was not published as you have not authenticated with server 'ge.spring.io'.","closed","status: invalid,","JamesLiuft","2022-04-08T02:49:31Z","2022-04-08T07:06:49Z"
"","28362","Add interoperability with InputStream/OutputStream with WebClient","I wanted to suggest better interoperability of the Spring `WebClient` and `InputStream` and `OutputStream` APIs. While I understand the asynchronous nature of the client, it is also suggested as a replacement for the synchronous`RestTemplate` and still many uses of the client will be synchronous to a blocked `Mono`. In this context, it can make sense to use the Java IO API for streams which is compatible to many existing libraries for IO. In my case, this would also offer a simple starting point for migrating from `RestTemplate` and other HTTP APIs.  The idea would be to use the client as follows:  ```java WebClient webClient = WebClient.builder().build(); String result; try (InputStream input = webClient.post().uri(""http://localhost:8080/hello/world"")     .body(BodyInserters.fromOutputStream(out -> out.write(""Hello!"".getBytes(StandardCharsets.UTF_8))))     .retrieve()     .bodyToMono(InputStream.class)     .block()) {   result = new String(input.readAllBytes()); } ```  This is still work in progress, I am not overly familiar with the Reactor API, but the idea was that the streams would be read or written asynchronously while consuming them. This might also become a much more relevant approach once project Loom makes blocking a thread a more feasible approach where this simple approach might become preferable in some cases.  Would you consider such an addition?","open","status: feedback-provided,","raphw","2022-04-20T20:37:46Z","2022-05-19T21:10:23Z"
"","28698","When I use exchangeToMono I get ""Only one connection receive subscriber allowed."" An error occurs.","I want to log the responsebody of the webclient.  My exchangeFilter ```             next.exchange()                 .map { response ->                     response.mutate()                         .body { dataBuffer ->                             dataBuffer.map {                                 Channels.newChannel(responseBodyBaos).write(it.asByteBuffer().asReadOnlyBuffer())                                 it                             }.doOnComplete {                                 traceLog()                         }.build() ```  My webclient. it works. ```               webClient()                     .get()                     .uri(uri)                     .exchange()                     .flatMap {                         when {                             it.statusCode().value() == 500 ->                                 it.bodyToMono(Void::class.java).then(Mono.error(RuntimeException(""api status: ${it.statusCode()}"")))                             else ->                                 it.bodyToMono(String::class.java)                         } ```  However, while upgrading the spring boot version to 2.2.6 -> 2.4.0, I found that the exchange method was deprecated.  ```               webClient()                     .get()                     .uri(uri)                     .exchangeToMono {                         when {                             it.statusCode().value() == 500 ->                                 it.bodyToMono(Void::class.java).then(Mono.error(RuntimeException(""api status: ${it.statusCode()}"")))                             else ->                                 it.bodyToMono(String::class.java)                         } ```  So, when I change the exchange method to the exchangeToMono method, an error occurs when the http status is 500.  ``` java.lang.IllegalStateException: Only one connection receive subscriber allowed. ```  Any idea how to solve this problem?","open","status: waiting-for-triage,","KimSeongIl","2022-06-24T09:22:24Z","2022-06-24T09:25:19Z"
"","28682","Optionals are not unwraped if using @CacheResult for caching","I wand to cache the result of a method which returns an Optional.   When i used the Spring @Cachable annotation, the optional result is saved unwrapped in the cache. ```java @Cacheable public Optional get(String key) // Cache contains only the string ```  But if im using the @CacheResult the Optional itself is stored in the cache. ```java @CacheResult public Optional get(String key) // Cache contains the optional ```  Im not sure if this is an expeced behavior or a bug.  I attached a simple example projekt.  [caching-example-project.zip](https://github.com/spring-projects/spring-framework/files/8965013/caching-example-project.zip)","open","status: waiting-for-triage,","ugrave","2022-06-23T07:36:36Z","2022-06-23T07:40:24Z"
"","28903","Use Jakarta EE XML namespaces instead of Java EE","I used Jakarta EE 9 namespaces here, which should be the new baseline.","open","status: waiting-for-triage,","vpavic","2022-08-01T10:14:38Z","2022-08-01T10:15:47Z"
"","28462","Spring rsocket not works properly in request Channel mode after version 2.5 of the spring framework","I use the Spring rsocket  and mongo gridfs for backend and rsocket-js in browser . At first The spring works properly in requestchannel mode , but after version 2.5 of the spring boot not works properly . for uploading first media has been broken to many chunks . per chunk has 8kb size then i send per chunk by Flowable .the first chunk has been sent by javascript and backend receive it , but the second chunk has not been received by the spring . this problem has been created after version 2.5 of the spring","open","status: feedback-provided,","kasra-haghpanah","2022-05-15T10:20:51Z","2022-05-15T14:00:16Z"
"","28177","How could @Caching version be bound to JPA entity version(optimistic lock)?","I use spring @Version for optimistic lock, and I use @Caching to cache the jpa entity. the version in database was auto incremented when the transaction was committed, but the version in cache was not incremented. How could I keep them consistent whenever the transaction is committed or rollback?","closed","for: stackoverflow,","nianxiaoyi","2022-03-14T10:36:35Z","2022-03-15T07:31:23Z"
"","28169","@ComponentScan doesn't work inside @Import in Spring","I use spring 5.2.8 and I have three annotation configs:      @Configuration     @ComponentScan(basePackageClasses = {         Foo.class     })     public class AConfig {           @Bean          public Something something() {..}     }          @Configuration     @ComponentScan(basePackageClasses = {         Bar.class     })     public class BConfig {}          @Configuration     @Import({ AConfig.class, BConfig.class })     public class MainConfig {}  This is the way I start my spring context:      ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class);  The problem with such configuration is that spring doesn't see/initialize/scan beans in the packages of base package classes. In log I see only      [TRACE] org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader - Registering bean definition for @Bean   Is this a bug or expected behavior?","closed","status: invalid,","PashaTurok","2022-03-11T22:53:50Z","2022-03-12T12:42:07Z"
"","27939","WebClient corrupts binary data when trying to upload many files","I use `WebClient` to upload binary files. When there are only a few of them everything works great, but when there are more (e.g. several hundred), `WebClient` sometimes corrupts binary data. I described the problem in more detail in [this question](https://stackoverflow.com/questions/70700268/spring-webclient-corrupts-binary-data) on StackOverflow. I also created a [repository](https://github.com/karolkrasnowski/web-client-file-upload) containing tests that illustrate this issue. I don't know what is the reason for this behavior but it doesn't seem entirely deterministic.  My use case is that I am sending binary files from one service (let's call it `A`) to another (let's call it `B`).  This is how I read these binary files in the service `B`: ```java @RestController class FilesController {      @PostMapping(value = ""/files"")     Mono> uploadFiles(@RequestBody Flux parts) {         return parts                 .filter(FilePart.class::isInstance)                 .map(FilePart.class::cast)                 .flatMap(part -> DataBufferUtils.join(part.content())                         .map(buffer -> {                             byte[] data = new byte[buffer.readableByteCount()];                             buffer.read(data);                             DataBufferUtils.release(buffer);                             return Base64.getEncoder().encodeToString(data);                         })                 )                 .collectList();     } } ```  And this is how I send these files in the service `A` (I wrote some tests to better illustrate the issue). ```java public class BinaryUploadTest {      private final List sentBytes = new CopyOnWriteArrayList<>();      @BeforeEach     void before() {         sentBytes.clear();     }      /**      * this test passes all the time      */     @Test     void shouldUpload5Files() {         // given         MultiValueMap> body = buildResources(5);          // when         List receivedBytes = sendPostRequest(body);          // then         assertEquals(sentBytes, receivedBytes);     }      /**      * this test fails most of the time      */     @Test     void shouldUpload1000Files() {         // given         MultiValueMap> body = buildResources(1000);          // when         List receivedBytes = sendPostRequest(body);          // then         assertEquals(sentBytes, receivedBytes);     }      private List sendPostRequest(MultiValueMap> body) {         return WebClient.builder().build().post()                 .uri(""http://localhost:8080/files"")                 .contentType(MediaType.MULTIPART_FORM_DATA)                 .body(BodyInserters.fromMultipartData(body))                 .retrieve()                 .bodyToMono(new ParameterizedTypeReference>() {                 })                 .block();     }      private MultiValueMap> buildResources(int numberOfResources) {         MultipartBodyBuilder builder = new MultipartBodyBuilder();         for (int i = 0; i < numberOfResources; i++) {             builder.part(""item-"" + i, buildResource(i));         }         return builder.build();     }      private ByteArrayResource buildResource(int index) {         byte[] bytes = randomBytes();         sentBytes.add(Base64.getEncoder().encodeToString(bytes)); // keeps track of what has been sent         return new ByteArrayResource(bytes) {             @Override             public String getFilename() {                 return ""filename-"" + index;             }         };     }      private byte[] randomBytes() {         byte[] bytes = new byte[ThreadLocalRandom.current().nextInt(16, 32)];         ThreadLocalRandom.current().nextBytes(bytes);         return bytes;     } } ``` As you can see, the only difference between these two tests is the number of files uploaded. The first test always works, and the second one doesn't work most of the time. When I was analyzing why these bytes do not match, I noticed that sometimes a few extra bytes appear at the end (something like padding).  Interestingly, when I use `WebTestClient`, the same problem does not occur, as shown in [this test](https://github.com/karolkrasnowski/web-client-file-upload/blob/main/src/test/java/com/example/binaryupload/BinaryFilesUploadIntegrationTest.java).","closed","type: bug,","karolkrasnowski","2022-01-16T12:48:37Z","2022-01-28T15:14:56Z"
"","27931","Provide a placeholder replacing ResourceTransformer","I use `` to host Asciidoctor-generated HTML content in few webapps. Those webapps share source code, but are differently configured and deployed to different contexts on an Apache Tomcat 8.5 instance. The documentation must be able to reference configuration parameters for documentation purpose. Since this is statically generated, I cannot inject parameters, for obvious reasons. Those HTML files contain a `${name}` placeholder and with the following snippet the interpolation happens.  ```java import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets; import java.util.Properties;  import javax.servlet.http.HttpServletRequest;  import org.apache.commons.text.StringSubstitutor; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.context.EnvironmentAware; import org.springframework.core.env.Environment; import org.springframework.core.io.Resource; import org.springframework.util.FileCopyUtils; import org.springframework.util.StringUtils; import org.springframework.web.servlet.resource.ResourceTransformer; import org.springframework.web.servlet.resource.ResourceTransformerChain; import org.springframework.web.servlet.resource.TransformedResource;  public class PropertiesResourceTransformer implements ResourceTransformer, EnvironmentAware {      private static final Logger logger = LoggerFactory             .getLogger(PropertiesResourceTransformer.class);      private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;      Environment environment;      Properties properties;      public void setEnvironment(Environment environment) {         this.environment = environment;     }      public void setProperties(Properties properties) {         this.properties = properties;     }      public Resource transform(HttpServletRequest request, Resource resource,             ResourceTransformerChain transformerChain) throws IOException {          resource = transformerChain.transform(request, resource);          String filename = resource.getFilename();         if (!""html"".equals(StringUtils.getFilenameExtension(filename))) {             return resource;         }          logger.trace(""Transforming resource: {}"", resource);          byte[] bytes = FileCopyUtils.copyToByteArray(resource.getInputStream());         String content = new String(bytes, DEFAULT_CHARSET);          content = environment.resolvePlaceholders(content);         content = StringSubstitutor.replace(content, properties);          return new TransformedResource(resource, content.getBytes(DEFAULT_CHARSET));     }  } ````  followed by: ```xml 	 		 			 				classpath:app.properties 				classpath:app-custom.properties 			 		 		 	  	 		 			 				 			 		 	 ```  I am not 100% happy with mine because I need to inject my `Properties` object directly and cannot totally rely on `Environment`, maybe that's just my lack of knowledge how to do it right. Please add such a resource tranformer upstream, I guess many would require something like this. Feel free to reuse and modify my code for upstream.  I am on Spring Framework 5.3.14.","closed","type: enhancement,","michael-o","2022-01-13T17:48:40Z","2022-01-18T10:02:51Z"
"","27930","Provide a context URL aware ResourceTransformer","I use `` to host Asciidoctor-generated HTML content in few webapps. Those webapps are deployed to different contexts on an Apache Tomcat 8.5 instance. The documentation must be able to reference the entire URL for documentation purpose. Since this is statically generated, I cannot inject the webapp context URL, for obvious reasons. Those HTML files contain a `{contextUrl}` placeholder and with the following snippet the interpolation happens.  ```java import java.io.IOException; import java.nio.charset.Charset; import java.nio.charset.StandardCharsets;  import javax.servlet.http.HttpServletRequest;  import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.io.Resource; import org.springframework.util.FileCopyUtils; import org.springframework.util.StringUtils; import org.springframework.web.servlet.resource.ResourceTransformer; import org.springframework.web.servlet.resource.ResourceTransformerChain; import org.springframework.web.servlet.resource.TransformedResource; import org.springframework.web.servlet.support.ServletUriComponentsBuilder;  public class ContextUrlResourceTransformer implements ResourceTransformer {  	private static final Logger logger = LoggerFactory 			.getLogger(ContextUrlResourceTransformer.class);  	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;  	private final Collection extensions;  	public ContextUrlResourceTransformer() { 		this.extensions = new HashSet<>(); 		extensions.add(""html""); 		extensions.add(""yaml""); 	}  	@Override 	public Resource transform(HttpServletRequest request, Resource resource, 			ResourceTransformerChain transformerChain) throws IOException {  		resource = transformerChain.transform(request, resource);  		String filename = resource.getFilename(); 		if (!extensions.contains(StringUtils.getFilenameExtension(filename))) { 			return resource; 		}  		logger.trace(""Transforming: {}"", resource);  		byte[] bytes = FileCopyUtils.copyToByteArray(resource.getInputStream()); 		String content = new String(bytes, DEFAULT_CHARSET);  		if (!content.contains(""{contextUrl}"")) { 			logger.trace(""No {contextUrl} placeholders found.""); 			return resource; 		}  		ServletUriComponentsBuilder builder = ServletUriComponentsBuilder.fromContextPath(request);  		String contextUrl = builder.build().toUriString(); 		content = content.replace(""{contextUrl}"", contextUrl);  		return new TransformedResource(resource, content.getBytes(DEFAULT_CHARSET)); 	} ````  followed by: ```xml 	 		 			 				 			 		 	 ```  This is conceptually similar to the `CssLinkResourceTransformer`, but for suited for general text formats. Please add such a resource tranformer upstream, I guess many would require something like this. Feel free to reuse and modify my code for upstream.  I am on Spring Framework 5.3.14.","closed","type: enhancement,","michael-o","2022-01-13T17:23:32Z","2022-01-18T11:31:26Z"
"","28127","Return empty LinkedHashMap instead of `Collections.emptyMap()` in PathVariableMapMethodArgumentResolver","I think it would be better that return empty `LinkedHashMap` instead of `Collections.emptyMap()` in `PathVariableMapMethodArgumentResolver`, because they do't have same support for `put` operation.  And I think that the supported operatioin of `Map` annotated with `@PathVariable` should not be changed according the value(empty or not).","closed","status: declined,","dugenkui03","2022-03-02T18:27:38Z","2022-03-03T06:49:11Z"
"","28899","spring start question","I think here no need to traverse no singleton bean names.  for (String beanName : beanNames) { 	Object singletonInstance = getSingleton(beanName); 	if (singletonInstance instanceof SmartInitializingSingleton) { 		StartupStep smartInitialize = this.getApplicationStartup().start(""spring.beans.smart-initialize"") 				.tag(""beanName"", beanName); 		SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; 		if (System.getSecurityManager() != null) { 			AccessController.doPrivileged((PrivilegedAction) () -> { 				smartSingleton.afterSingletonsInstantiated(); 				return null; 			}, getAccessControlContext()); 		} 		else { 			smartSingleton.afterSingletonsInstantiated(); 		} 		smartInitialize.end(); 	} }","closed","in: core,","shepherd819","2022-08-01T06:39:45Z","2022-08-01T06:55:08Z"
"","28573","Spring Boot WebSocket Broker does not sends CONNECTED frame","I recently faced and issue, unfortunately on production environment, when my Spring Boot Server was not sending response of CONNECT frame (i.e CONNECTED frame). It first started happening occasionally but later on all the CONNECT requests sent by the browser were not replied to.  ![image](https://user-images.githubusercontent.com/7993262/172199937-20f81942-d8b7-4af8-8777-094b2b59c537.png) On console I was able to see following log  ![image](https://user-images.githubusercontent.com/7993262/172200039-cea7d609-2e8f-4f8b-92e8-7507535e1838.png)  After some investigating, I found out that inboundChannel queue was holding many requests at that time. I believe this was the reason.  ```2022-06-01 18:22:59,943 INFO  Thread-id-74- springframework.web.socket.config.WebSocketMessageBrokerStats: WebSocketSession[130 current WS(129)-HttpStream(1)-HttpPoll(0), 225 total, 0 closed abnormally (0 connect failure, 0 send limit, 2 transport error)], stompSubProtocol[processed CONNECT(220)-CONNECTED(132)-DISCONNECT(0)], stompBrokerRelay[null], inboundChannel[pool size = 2, active threads = 2, queued tasks = 10774, completed tasks = 31806], outboundChannel[pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 570895], sockJsScheduler[pool size = 1, active threads = 1, queued tasks = 134, completed tasks = 1985]```  I was wondering what might be the cause of the issue, what can cause queuing in the inboundChannel queue?  here is my current STOMP config on my angular application.  ``` const config: StompJS.StompConfig = {       brokerURL: this.serverUrl,       connectHeaders: {         ccid: this.cookieService.get('ccid'),         username: `${this.globalContext.get('me')['username']}`,       },       debug: (str) => {         this.loggerService.log(this.sessionId, ' | ', str);       },       webSocketFactory: () => {         return new SockJS(this.serverUrl);       },       logRawCommunication: true,       reconnectDelay: 3000,       heartbeatIncoming: 100,       heartbeatOutgoing: 100,       discardWebsocketOnCommFailure: true,       connectionTimeout: 4000     }; ```","closed","for: stackoverflow,","daveRanjan","2022-06-06T16:08:04Z","2022-06-08T11:35:57Z"
"","28467","Scheduled method runs twice when setting cron to run every 59 seconds","I realized when I set a scheduled method to run every 59 seconds, it runs twice, in the 59th second of its current minute and the first second of the next minute.  The cron that was used: `*/59 * * * * *`  The sample code is so simple but for more clarity:   ```java @Component public class LogScheduler {      Logger logger = LoggerFactory.getLogger(LogScheduler.class);      @Scheduled(cron = ""${scheduler.logging.cron}"")     public void logMessage(){         logger.info(""some info"");     }  }  ```  The output:  ``` 2022-05-16 01:55:59.006  INFO 61503 --- [   scheduling-1] d.najmi.performantapp.task.LogScheduler  : some info 2022-05-16 01:56:00.004  INFO 61503 --- [   scheduling-1] d.najmi.performantapp.task.LogScheduler  : some info ```  For more information, I am using `Spring web flux(netty) version 2.6.7` on an arm64 machine.","closed","in: core,","amirnajmi","2022-05-15T23:00:53Z","2022-05-16T13:44:27Z"
"","27946","Large unnecessary memory allocation rate in Spring Boot 2.6.2 Web MVC","I noticed in Opsian Profiler, that somehow the `org.springframework.web.util.ServletRequestPathUtils#getParsedRequestPath` method in our services allocates memory everytime it is called. And it is called a lot. For high RPM simple services, the memory allocation from it can be as significant as 30% total of all memory allocations.  The source code of `ServletRequestPathUtils#getParsedRequestPath` is: ```java 	public static RequestPath getParsedRequestPath(ServletRequest request) { 		RequestPath path = (RequestPath) request.getAttribute(PATH_ATTRIBUTE); 		Assert.notNull(path, ""Expected parsed RequestPath in request attribute \"""" + PATH_ATTRIBUTE + ""\"".""); 		return path; 	} ``` I would assume, the author expected the `Expected parsed RequestPath in request attribute \"""" + PATH_ATTRIBUTE + ""\"".` to be compiled into a constant, however JD-GUI decompiler shows it still as: `Assert.notNull(path, ""Expected parsed RequestPath in request attribute \"""" + PATH_ATTRIBUTE + ""\""."");`  The problem arises, because `public static final String PATH_ATTRIBUTE = ServletRequestPathUtils.class.getName() + "".PATH"";` is not a compile time constant, but a runtime constant.  So at least one, new, relatively long, and unnecessary, String is allocated every time this method is called.  One Profiler sample stacktrace (there are other stack branches): ![image](https://user-images.githubusercontent.com/5344757/149939032-0766a5bd-2da4-4df0-88bc-04a4e0329ac4.png)  I have seen lots of effort put under making Spring Boot more memory (allocation) efficient, in last 2 years, thank you for that. But it seems like there is an opportunity to make it even better.  Versions: Spring Boot 2.6.2. Spring Web 5.3.14.","closed","type: task,","onukristo","2022-01-18T12:54:26Z","2022-02-14T15:23:59Z"
"","28180","ConfigurableBeanFactory.registerDependentBean() being ignored","I migrated a project to 5.3.16 (through Spring Boot 2.6.4) and I had a problem similar to #28002, which so far worked by using a PostProcessor hack. so I tried to reimplement it in the suggested way.   Even though the comments in the ticket state that the preferred form is `configurableBeanFactory.registerDependentBean(beanNameDependency, beanNameDepender)`, I can only make work my `postProcessBeanFactory()` with `configurableBeanFactory.getBeanDefinition(beanNameDepender).setDependsOn(beanNameDependency)`.   Is this expected? Shouldn't `registerDependentBean` work the same as `setDependsOn`? Is it really preferable?","open","in: core,","nightswimmings","2022-03-15T09:59:29Z","2022-04-25T09:43:04Z"
"","27901","Potential resource leak in HttpComponentsAsyncClientHttpResponse?","I know AsyncRestTemplate is deprecated, but by looking at the code of HttpComponentsAsyncClientHttpResponse: ```java 	@Override 	public InputStream getBody() throws IOException { 		HttpEntity entity = this.httpResponse.getEntity(); 		return (entity != null ? entity.getContent() : StreamUtils.emptyInput()); 	}  	@Override 	public void close() {         // HTTP responses returned by async HTTP client are not bound to an         // active connection and do not have to deallocate any resources... 	} ``` I see that the InputStream of the apache httpResponse is exposed as the inputStream of the ClientHttpResponse.  Apache HttpComponents's HttpEntity expects this inputStream to be closed by the consumer, but this expectation doesn't seem to match the contract of, for example, ResponseErrorHandler, implementations of which could handle errors without dealing with the content of the response. The `close()` of the ClientHttpResponses would do nothing and the underlying httpEntity would be ""unconsumed"". (Other implementations like OkHttp or Netty do actually close the internal resources)  I am not reproducing this as a specific bug, i'm investigating another issue and found this worth recording just in case something is not correct.","closed","status: feedback-provided,","flozano","2022-01-07T13:17:16Z","2022-02-01T13:05:14Z"
"","28209","Lambda proxy generation fix causes BeanNotOfRequiredTypeException","I hit the problem described in https://github.com/spring-projects/spring-framework/issues/27971.  Rather than just adding the `--add-opens java.base/java.lang=ALL-UNNAMED` to my Surefire  configuration, I decided to upgrade to Spring-Boot 2.6.4 (from 2.6.3) to take the fix that was described (because Spring-Boot 2.6.4 uses Spring framework version 5.3.16).  However, this led me to a different error, whereby we hit a `org.springframework.beans.factory.BeanNotOfRequiredTypeException` for the lambda bean, specifically:  `org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named 'defaultMyThing' is expected to be of type 'com.oliverlockwood.MyThing' but was actually of type 'jdk.proxy2.$Proxy142'`  At present, my not-so-pleasant options seem to come down to: - Run under Java 17, using `--add-opens` JVM argument, and get stuck on Spring Boot 2.6.3 (not great) - Run under Java 11 (not great), but be able to upgrade to Spring Boot 2.6.4 - Run under Java 17 and Spring Boot 2.6.4, but change the lambda beans to be explicit (not great).  I couldn't see a ticket representing this issue, and as Spring-Boot 2.6.4's only recently been released it is plausible that I might be the first person to hit this.","closed","in: core,","oliverlockwood","2022-03-21T16:45:43Z","2022-04-09T08:56:45Z"
"","28289","CVE-2020-36518 : Unable to resolve WhiteSource vulnerability for jackson-databind library","I have tried all the versions of jackson-databind (including version suggested on whitesource fix), but all the version for **jackson-databind** showing **vulnerability** on whitesource scan.  Below is the description of the issue and we can also see the WhiteSource Note :  ![jackson-databind](https://user-images.githubusercontent.com/47110184/161848317-35a462d4-b77b-4068-8db9-456ec64515eb.png)   Note: Tried to update the spring to latest version, issue still persist  Questions asked on StackOverflow: https://stackoverflow.com/questions/71512818/cve-2020-36518-unable-to-resolve-whitesource-vulnerability-for-jackson-databin","closed","for: stackoverflow,","brajeshjha","2022-04-05T21:03:07Z","2022-04-05T21:39:26Z"
"","28375","extra balnk space removed from 3 java file","I have removed 5 extra line breaks from 3 java files.   I have seen there are some extra line breaks in some java files between the import statement. I removed those and I think that will increase the code readability.   - 1st file ->   ![Screenshot_1](https://user-images.githubusercontent.com/97525250/165027798-f36869c6-5038-4a57-8357-bb992eeaef19.png)  - 2nd file ->  ![Screenshot_2](https://user-images.githubusercontent.com/97525250/165027828-5d86f061-a51e-41f5-9b9e-aa56568c81e4.png)  - 3rd file ->  ![Screenshot_3](https://user-images.githubusercontent.com/97525250/165027868-7c6b48aa-fcba-49f5-8536-68abca3007cb.png)  **Please let me know If I Should modify or change something!**","closed","status: declined,","nesarptr","2022-04-25T05:50:23Z","2022-04-26T04:31:57Z"
"","28514","Spring 5 backward compatible to spring 4","I have read below recommendation from one of the Spring Framework lead (**I hope this holds good for other versions as well**.) :-   _To a large degree, an upgrade from Spring Framework 3.2 (or earlier) to 4.0.1 should be as straightforward as a change of version numbers in your Maven POMs. Note that you may have to upgrade specific third-party dependencies to a recent enough version (e.g. Hibernate 3.6+, Quartz 1.8+, Jackson 1.8+, Tiles 2.2+), but other than that, you should be able to get all the benefits of the Spring 4 line with hopefully_","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-05-24T08:30:34Z","2022-06-06T11:57:39Z"
"","28591","Webflux support for decoding/parsing of ""multipart/related"" requests","I have queried support for the decoding/parsing of ""**multipart/related**"" requests on [Stack Overflow](https://stackoverflow.com/questions/72307771/spring-webflux-decoding-parsing-multipart-related-request-support) with no response in nearly 3 weeks.  I understand it may not be the best place to ask but perhaps I may get some clarification here (apologies in advance if not appropriate). On reviewing Spring WebFlux documentation for decoding/parsing multipart requests on a server, it seems that just ""_multipart/form-data_"" content is supported (see [webflux-multipart](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-multipart) and [webflux-codecs-multipart](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-codecs-multipart)). There appears to be no mention of ""**multipart/related**"" content. It is not clear if/how the decoding/parsing of ""multipart/related"" requests are supported when using spring-boot-starter-webflux.  - if supported, are there documented examples (annotated controller, required config etc) to reference?  - if not, is it planned in later releases?  (using spring-boot.version 2.6.3)","open","status: waiting-for-triage,","brianflan","2022-06-09T07:56:54Z","2022-06-09T08:05:33Z"
"","28335","Wrong type injected when @Autowire Map in TestNG with XML context definition","I have found something that might be related to ([27542](https://github.com/spring-projects/spring-framework/issues/27542)) or it is morelikely a separate bug regarding DI of Maps. I would surely like it to be fixed.  Spring: `5.3.18` (Spring Boot: `2.6.6`) TestNG: `7.5` Java: `11`  Demo: [Spring 5 + XML context + TestNG = wrong type injected: ServiceA3XmlTest.java](https://github.com/SpiReCZ/spring5-map-di-testng/blob/main/src/test/java/test/autowiremap/test/ServiceA3XmlTest.java)  `factoryGroupsA_fails` test fails because wrong type is injected. This happens in combination of using: - XML context definition - TestNG (... extends AbstractTestNGSpringContextTests)  In our Application we use bare Spring 5. Only thing that is different in the example test demo is that it uses Spring Boot (we don't in this case).   Expected type: `Map>` Injected type: `Map>>`  ServiceA3XmlTest.java: ```java package test.autowiremap.test;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.testng.AbstractTestNGSpringContextTests; import org.testng.annotations.Test; import test.autowiremap.service.MyServiceFactory;  import java.util.Map;  @Test @ContextConfiguration(locations = {""classpath:context.xml""}) public class ServiceA3XmlTest extends AbstractTestNGSpringContextTests {     @Autowired     @Qualifier(""xmlFactoryMap"")     private Map> factoryGroupsXml;     @Autowired     @Qualifier(""xmlFactoryMap"")     private Object factoryGroupsXmlObject;      @Test     public void factoryGroupsA_fails() {         // Throws NullPointerException due to different data type         MyServiceFactory myServiceFactory = factoryGroupsXml.get(""xmlGroup"").get(""xmlFactory"");         System.out.println(myServiceFactory);     }      @Test     public void factoryGroupsA_working() {         var factoryGroupsXmlObject = (Map>) this.factoryGroupsXmlObject;         MyServiceFactory myServiceFactory = factoryGroupsXmlObject.get(""xmlGroup"").get(""xmlFactory"");         System.out.println(myServiceFactory);     } } ```  `factoryGroupsA_working` test shows how to evade this issue.   Test Demo: [Test results in CI](https://github.com/SpiReCZ/spring5-map-di-testng/runs/6012862035?check_suite_focus=true) ``` Error:  Failures:  Error:    ServiceA3XmlTest>AbstractTestNGSpringContextTests.run:184->factoryGroupsA_fails:25 NullPointer ```","open","status: waiting-for-triage,","SpiReCZ","2022-04-13T18:23:32Z","2022-04-13T18:39:47Z"
"","28239","while uploading file getting error Invalid CSRF Token 'null' was found on the request parameter '_csrf' or header 'X-CSRF-TOKEN'.","i have enabled csrf and send token  `` and still its not working and i have send csrf token from onceperfilter too still it is getting null ```                 CsrfToken token = (CsrfToken) request.getAttribute(""_csrf""); 	        response.setHeader(""X-CSRF-HEADER"", token.getHeaderName()); 	        response.setHeader(""X-CSRF-PARAM"", token.getParameterName()); 	        response.setHeader(""X-CSRF-TOKEN"", token.getToken()); ``` Any leads will be appreciated  Thanks in advance","closed","for: stackoverflow,","nikhilpatiltest","2022-03-27T08:25:45Z","2022-03-27T09:53:26Z"
"","28686","Async can't be used in EndpointInterceptor","I have a web service, and want to log the SOAP request and response messages. I am attempting to do this in a EndpointInterceptor.  When using a custom logger, which logs messages asynchronously, all async call stop being asynchronous when added to the interceptor.  Here is a small project to demonstrate the issue: https://github.com/scolem/retailerInterface. By adding and removing the injected AsyncService in WSSoapMessageLogger, the tests will either pass or fail.","closed","status: invalid,","scolem","2022-06-23T14:00:28Z","2022-07-01T08:11:15Z"
"","28290","Loosing Kotlin coroutine context when using @Transactional annotation","I have a simple test class as following ```kotlin @OptIn(ExperimentalCoroutinesApi::class) @DataR2dbcTest @Import(TransactionLogTest.TestService::class) class TransactionLogTest(     @Autowired private val testService: TestService, ) {     @Test     fun `test log`() = runTest {         withContext(MDCContext(mapOf(""key"" to ""value""))) {             assertThat(MDC.get(""key"")).isEqualTo(""value"")             testService.doSomething()         }     }      open class TestService {         @Transactional         open suspend fun doSomething() {             assertThat(MDC.get(""key"")).isEqualTo(""value"")         }     } } ```  The assertion in the `doSomething` function will fail which indicates the Kotlin coroutines context is not propagated correctly to the called suspend function.  I investigated further and I think I found the root cause. In `org.springframework.transaction.interceptor.TransactionAspectSupport`  the code snippet from `invokeWithinTransaction` method as following uses `CoroutinesUtils.invokeSuspendingFunction` to execute the wrapped method  ```kotlin 	InvocationCallback callback = invocation; 	if (corInv != null) { 		callback = () -> CoroutinesUtils.invokeSuspendingFunction(method, corInv.getTarget(), corInv.getArguments()); 	} ``` However `CoroutinesUtils.invokeSuspendingFunction` doesn't care about the current continuation/context but create a new one by `MonoKt.mono` call as following ```java 	public static Publisher invokeSuspendingFunction(Method method, Object target, Object... args) { 		KFunction function = Objects.requireNonNull(ReflectJvmMapping.getKotlinFunction(method)); 		KClassifier classifier = function.getReturnType().getClassifier(); 		Mono mono = MonoKt.mono(Dispatchers.getUnconfined(), (scope, continuation) -> 					KCallables.callSuspend(function, getSuspendedFunctionArgs(target, args), continuation)) 				.filter(result -> !Objects.equals(result, Unit.INSTANCE)) 				.onErrorMap(InvocationTargetException.class, InvocationTargetException::getTargetException); 		if (classifier != null && classifier.equals(JvmClassMappingKt.getKotlinClass(Flow.class))) { 			return mono.flatMapMany(CoroutinesUtils::asFlux); 		} 		return mono; 	} ``` I am not sure what should be a proper fix for this but potentially we can pass the actual continuation or extract it from the `args` and use that instead of the new one from `MonoKt.mono`","open","in: kotlin,","huynguyentuong","2022-04-06T03:53:38Z","2022-04-25T09:59:59Z"
"","28502","javax.persistence.TransactionRequiredException: no transaction is in progress","I have 1 problem:  When I use EntityManager to add multiple records to the database at the same time then an error occurs   ``` sh javax.persistence.TransactionRequiredException: no transaction is in progress ```  I declared EntityManager as follows: ```java     @PersistenceContext(unitName = ""persistenceUnit"")     public EntityManager em; ```  The process of adding data to the database from my list is like this:  ```java @Transactional     public  Boolean bulkSave(List entities) {         boolean flag = false;         int i = 0;         try {             for (T t : entities) {                 em.merge(t);                 i++;                 if (i % batchSize == 0 || i == entities.size()) {                     // Flush a batch of inserts and release memory.                     logger.info(String.format(""FLUSH : %s"", i));                     em.flush();                     em.clear();                     flag = true;                 }             }         } catch (Exception e) {             e.printStackTrace();         }          logger.info(""--END--"");         return flag;     } ```  and error: ```sh javax.persistence.TransactionRequiredException: no transaction is in progress 	at org.hibernate.jpa.spi.AbstractEntityManagerImpl.checkTransactionNeeded(AbstractEntityManagerImpl.java:1171) 	at org.hibernate.jpa.spi.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:1332) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:366) 	at com.sun.proxy.$Proxy122.flush(Unknown Source) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:241) 	at com.sun.proxy.$Proxy108.flush(Unknown Source) 	at com.osp.chonso.services.BaseService.bulkSave(BaseService.java:232) 	at com.osp.chonso.services.DwMsisdnToShopcodeServiceImpl.importFile(DwMsisdnToShopcodeServiceImpl.java:95) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317) 	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:198) 	at com.sun.proxy.$Proxy112.importFile(Unknown Source) 	at com.osp.chonso.controller.DwMsisdnToShopcodeController.importData(DwMsisdnToShopcodeController.java:72) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:219) 	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132) 	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:745) 	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:686) 	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:925) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:838) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:681) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:103) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:45) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter(BasicAuthenticationFilter.java:150) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:199) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:110) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) 	at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:687) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360) 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:890) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1743) 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) 	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) 	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) 	at java.lang.Thread.run(Thread.java:750) ```  Can anyone help me explain why?","closed","status: waiting-for-triage,","hungnvd59","2022-05-23T02:32:33Z","2022-05-23T03:36:36Z"
"","28701","RuntimeHints missing for WebFlux","I had to add these hints to get WebFlux with Netty running, using the spring-native sample `webflux-netty` on [this branch](https://github.com/mhalbritter/spring-native/tree/mh/netty):  ```         hints.resources().registerPattern(""org/springframework/http/codec/CodecConfigurer.properties"");         hints.reflection().registerType(DefaultClientCodecConfigurer.class, hint -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));         hints.reflection().registerType(DefaultServerCodecConfigurer.class, hint -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));         RuntimeHintsUtils.registerAnnotation(hints, RequestMapping.class); ```  I only did the minimal possible work that the sample passes, so I guess this is far from being complete.","closed","theme: aot,","mhalbritter","2022-06-24T14:06:55Z","2022-06-30T08:04:20Z"
"","28422","Fix BindingResult error when ModelAttribute has custom name in WebFlux","I guess this part of the code is trying to get the `ModelAttribute` annotation from the `BindingResult` parameter itself instead of the previous one as it should be. This is causing `ann` variable to be always `null` and therefore ignoring the value of the `@ModelAttribute` annotation.","closed","type: bug,","bougar","2022-05-05T22:06:10Z","2022-05-07T14:33:53Z"
"","28173","@Lazy injection point is resolved from BeanFactory for every invocation on proxy","I found that, when I use `@Lazy` on `@Resource` fields, Spring injects a lazy proxy.  The lazy proxy's `TargetSource` is not static, so every time I invoke a method on the lazy proxy, it calls `beanFactory.resolveDependency()` to resolve the target object.  **Why doesn't Spring set the lazy proxy's `TargetSource` to static?**  If so, it will be faster when invoking the lazy proxy's methods.  For example, in `CommonAnnotationBeanPostProcessor`:  ```java protected Object buildLazyResourceProxy(final LookupElement element, final @Nullable String requestingBeanName) {     TargetSource ts = new TargetSource() {         @Override         public Class getTargetClass() {             return element.lookupType;         }         @Override         public boolean isStatic() {             // this place: why not use ""true""？             return false;         }         @Override         public Object getTarget() {             return getResource(element, requestingBeanName);         }         @Override         public void releaseTarget(Object target) {         }     };  // ...  }  ```","closed","in: core,","kevin-wang001","2022-03-13T05:04:05Z","2022-03-15T13:33:30Z"
"","28527","Made BeanPropertySqlParameterSource.beanWrapper protected","I found BeanPropertySqlParameterSource useful for use but it still supports java 1.3 java types. Today its normal to use for temporal fields from `java.time` package. But `BeanPropertySqlParameterSource` know nothing how to handle that and no way to plug that functionality into.  ```java @Override 	public int getSqlType(String paramName) { 		int sqlType = super.getSqlType(paramName); 		if (sqlType != TYPE_UNKNOWN) { 			return sqlType; 		} 		Class propType = this.beanWrapper.getPropertyType(paramName); 		return StatementCreatorUtils.javaTypeToSqlParameterType(propType); 	} ``` `this.beanWrapper` is private so extending `BeanPropertySqlParameterSource` will give useless object and `StatementCreatorUtils.javaTypeToSqlParameterType` stuck in old java.  Making `BeanPropertySqlParameterSource.beanWrapper` protected will allow to override this class and manipulate with custom types of bean, including ones from `java.time`.","open","status: waiting-for-triage,","msangel","2022-05-26T11:05:01Z","2022-05-26T11:05:19Z"
"","28077","Missing documentation on WebClient retry functionality","I don't know if I'm looking in the wrong place, but I cannot find a single paragraph [in the WebClient docs](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client) mentioning the retry functionality.   While there are some examples in the community, I have not been able to find any examples on how to handle retries for `WebClientRequestException` which I believe was introduced 5.3, and related exceptions like `ReadTimeoutException`.   I have posted [a question related to this on stackoverflow](https://stackoverflow.com/questions/71180105/how-to-retry-on-response-timeout-with-spring-webclient), but I think it's an issue that there are no official docs whatsoever related to retry (unless I'm looking in the wrong place...)","closed","","dan-lind","2022-02-19T08:15:37Z","2022-02-19T15:42:14Z"
"","28193","Polish LocalEntityManagerFactoryBean","I delete 'else' statement and changed it to make it more readable","closed","status: declined,","ShinDongHun1","2022-03-17T15:08:03Z","2022-03-17T15:33:53Z"
"","28882","About the change in the advice order in Spring AOP","I created a Maven project to test the AOP notification order, but I find that when the version of Spring-context in the pom. xml file is 5.2.13-RELEASE and 5.2.5-RELEASE, I get different results. I wonder if this is a bug or if it was intentionally changed.  What if it was intentionally changed?  Could you please tell me the reason? Please check the attached picture ![issue picture](https://user-images.githubusercontent.com/108821901/181455367-69d72556-48dd-4391-92bb-53e3da1c3239.jpg)   [aoptestone.zip](https://github.com/spring-projects/spring-framework/files/9206985/aoptestone.zip)","open","status: waiting-for-triage,","zhujiuchao","2022-07-28T08:13:24Z","2022-07-28T08:15:49Z"
"","28041","Support * is equivalent to /*","I believe most business developers think * is equivalent to /*  fixes #28017","open","for: merge-with-amendments,","a364176773","2022-02-11T17:39:10Z","2022-02-12T07:55:27Z"
"","27966","CronExpression doesn't handle Quartz weekday of month expressions correctly","I believe a found a bug in how `CronExpression` handles Quartz [weekday of month](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) expressions.  The cron expression `0 0 0 1W * ?` to my understanding should match the weekday  (Monday-Friday)  that is closest to the first day of a month. For example 2021-08-01 is a Sunday, so `#next` should to my understanding produce 2021-08-02 the first weekday on the month of August in the year 2021. However it produces 2021-09-01.  In addition the Quartz documentation says:  > However if you specify “1W” as the value for day-of-month, and the 1st is a Saturday, the trigger will fire on Monday the 3rd, as it will not ‘jump’ over the boundary of a month’s days.  If we check this very specific scenario with 2022-01-01 which is a Saturday we would expect `#next` to produce 2022-01-03 but it produces 2022-02-01, ""jumping"" over the boundary of a month’s days.  Here are two tests for these scenarios  ```java class WeekdayOfMonthQuartzExpressionTests {    @Test   void firstWeekdayOfMonth_fromSaturday() {     CronExpression firstWeekdayOfMonth = CronExpression.parse(""0 0 0 1W * ?"");     LocalDate saturday = LocalDate.of(2022, 1, 1);     assertSame(DayOfWeek.SATURDAY, saturday.getDayOfWeek());     LocalDate monday = LocalDate.of(2022, 1, 3);     assertSame(DayOfWeek.MONDAY, monday.getDayOfWeek());     assertEquals(monday.atStartOfDay(), firstWeekdayOfMonth.next(saturday.atStartOfDay()));   }    @Test   void firstWeekdayOfMonth_fromSunday() {     CronExpression firstWeekdayOfMonth = CronExpression.parse(""0 0 0 1W * ?"");     LocalDate sunday = LocalDate.of(2021, 8, 1);     assertSame(DayOfWeek.SUNDAY, sunday.getDayOfWeek());     LocalDate monday = LocalDate.of(2021, 8, 2);     assertSame(DayOfWeek.MONDAY, monday.getDayOfWeek());     assertEquals(monday.atStartOfDay(), firstWeekdayOfMonth.next(sunday.atStartOfDay()));   }  }  ```  I tested with Spring 5.3.15.","closed","in: core,","marschall","2022-01-21T14:49:59Z","2022-02-02T20:31:21Z"
"","28046","@DynamicPropertySource as a class-level annotation with possibility to pass a target implementation as attribute","I am using currently TestContainers singleton pattern in order to reuse my db across all JVM tests and I ended up using an enum for it. So I was wondering if it was possible to extend the @DynamicPropertySource so it can be used at class level on something like this:  ``` @DynamicPropertySource(TestContainers.POSTGRES) public class MyFlowIT { ... }  ```  The updated annotation's ""values""/default  property (or a new explicit one) would have to be a new interface close to something like `Consumer`, since the very same consumer is illegal as an annotation attribute according to spec.  That would allow us to save from having to define the following in each test,  ```     @DynamicPropertySource     static void postgresProperties(DynamicPropertyRegistry registry) {         TestContainers.POSTGRES.registerProperties(registry);     } ```      For instance, what about accepting an interface like:  ``` interface DynamicPropertyRegistrable {     public void registerProperties(DynamicPropertyRegistry dynamicPropertyRegistry) ;  }    ```   Then the enum would be something like:  ``` public enum TestContainers implements DynamicPropertyRegistrable {      POSTGRES (""POSTGRES"", new PostgresInitializer()),     KAFKA (""KAFKA"", new KafkaInitializer()),     ACTIVEMQ (""ACTIVEMQ"", new ActiveMQInitializer()),     OPENSEARCH(""OPENSEARCH"", new OpenSearchInitialiser());          @Override     public void registerProperties(DynamicPropertyRegistry dynamicPropertyRegistry) {         this.propertyRegistrar.forEach((property,supplier) -> dynamicPropertyRegistry.add(property, supplier));     } (...) ```  Then we could use it as @DynamicPropertySource(TestContainers.POSTGRES). I would really love to save me from defining the register section at the beginning of each of my 300 ITs and annotation composition is less problematic and more elegant than abstracting in parents expressly. With my suggested way, we could also include the db setup as part of a meta-annotation with other annotations. Wouldn't rock something like this?:     ``` @IntegrationTest    public class MyFlowIT { ... } ```  where my custom annotation would be something like:  ``` @DynamicPropertySource(TestContainers.POSTGRES)  @TestInstance(LifeCycle.PER_CLASS) @Sql(scripts = ""/db/scenarios/common/CleanDB.sql"", executionPhase = AFTER_TEST_METHOD) @SqlMergeMode(SqlMergeMode.MergeMode.MERGE)  @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface IntegrationTest {} ```","closed","status: invalid,","nightswimmings","2022-02-13T22:14:03Z","2022-02-14T17:39:44Z"
"","28430","Scheduled task was not triggered after DST","I am using a scheduled task with annotation: `@Scheduled(cron = ""0 30 0 * * ?"", zone = ""Europe/Bratislava"")`  This task was successfully triggered every day, but after the Daylight saving time (DST) change, the task did not start on 2022/03/28 at 0.30 AM. The day after (2022/03/29), task was triggered again and continue triggering every day according to cron expression.  Other scheduled task used in application ran properly with annotation below: `@Scheduled(cron = ""0 0/5 * * * *"", zone = ""Europe/Bratislava"")`  Annotation is used from dependency org.springframework:spring-context:5.3.10  I am struggling to find out why scheduled task did not run. Does anyone know the answer, please?","closed","in: core,","ifc0","2022-05-09T10:39:28Z","2022-05-23T13:10:25Z"
"","28861","Unnamed module issue with using AOP with Java 9 modules","I am trying to use AOP with Java 9 modules. On application startup I get this issue. I tried with Spring version: 5.3.1 8 and 5.3.22  Seems like AOP is not yet Java 9 module compatible.  Caused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class com.sachin.controllers.TestControllers: Common causes of this problem include using a final class or a non-visible class; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalAccessError-->superinterface check failed: class com.sachin.controllers.TestControllers$$EnhancerBySpringCGLIB$$48d20b1a (in module bnpl.web) cannot access class org.springframework.aop.framework.Advised (in unnamed module @0x163e4e87) because module bnpl.web does not read unnamed module @0x163e4e87 	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:209) ~[spring-aop-5.3.22.jar:5.3.22] 	at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110) ~[spring-aop-5.3.22.jar:5.3.22] 	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:480) ~[spring-aop-5.3.22.jar:5.3.22] 	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:344) ~[spring-aop-5.3.22.jar:5.3.22] 	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:293) ~[spring-aop-5.3.22.jar:5.3.22] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:455) ~[spring-beans-5.3.22.jar:?] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1808) ~[spring-beans-5.3.22.jar:?] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:620) ~[spring-beans-5.3.22.jar:?]","closed","in: core,","SachinSharmaa","2022-07-23T09:43:58Z","2022-07-27T13:50:57Z"
"","28909","connectionTimeOut and readTimeout not working on UrlResource","I am trying to terminate a connection if no data is being received or server is just keeping the connection open for a url by setting value for connectionTimeout and readTimeout but it is not working.  Spring boot version 2.7.1  Here is the link to SO [https://stackoverflow.com/questions/73165245/setting-connectiontimeout-and-readtimeout-not-working-on-urlresource](https://stackoverflow.com/questions/73165245/setting-connectiontimeout-and-readtimeout-not-working-on-urlresource)  Below code reproduces the issue.   ``` try {   URL url = new URL(""http://httpstat.us/200?sleep=20000"");   UrlResource urlResource = new UrlResource(url) {  @Override     protected void customizeConnection(HttpURLConnection connection) throws IOException {       super.customizeConnection(connection);       connection.setConnectTimeout(4000);       connection.setReadTimeout(2000);     }   };    InputStream inputStream = urlResource.getInputStream();   InputStreamReader isr = new InputStreamReader(inputStream,       StandardCharsets.UTF_8);   BufferedReader br = new BufferedReader(isr);   br.lines().forEach(line -> System.out.println(line)); } catch (MalformedURLException e) {   e.printStackTrace(); } catch (IOException e) {   System.out.println(""IO exception"");   e.printStackTrace(); } ```  Expected:- both connectionTimeout and readTimeout should work as per given value and terminate the connection if time exceeds the timeout value","open","status: waiting-for-triage,","pinkeshsagar-harptec","2022-08-02T06:21:17Z","2022-08-02T14:55:04Z"
"","28881","Unnamed module issue when using FailureAnalyzer with JPMS","I am trying to make `FailureAnalyzer` working with Java Platform Module System (JPMS) on JDK 11.  `FailureAnalyzer` is working great when there is not `module-info.java`, in contrary when this file exists I've got this stacktrace:   ``` Caused by: java.lang.IllegalAccessException: module com.example.failureanalyzer does not open com.example.failureanalyzer to unnamed module @3b74ac8 	at java.base/java.lang.invoke.MethodHandles.privateLookupIn(MethodHandles.java:202) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na] 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:506) ~[spring-core-5.3.21.jar:5.3.21] 	... 27 common frames omitted ```  Here is the content of `module-info.java`:  ``` module com.example.failureanalyzer {     requires spring.context;     requires spring.beans;     requires spring.boot.autoconfigure;     requires spring.boot; } ```","open","status: waiting-for-triage,","eallais","2022-07-27T15:34:31Z","2022-07-27T16:07:42Z"
"","28706","Add prefix or suffix to the GET,PUT,POST,DELETE mappings in controller at method level using custom annotation","I am trying to add a prefix or suffix in the controller at the method level on top of GET, POST, PUT, DELETE mappings.  Controller class      @RestController     @RequestMapping(""/something"")     public class SomeController {     @PutMapping(""/some/path/"")     public ResponseEntity> someMethod() {     ....     }     ...     } So, basically, the above request URL should be something like : **http://localhost:8080/something/some/path/**  Now, I just want to add some prefix or suffix whatever is feasible to the request URL which will be something like : **http://localhost:8080/read/something/some/path/** or **http://localhost:8080/something/some/path/read/** the extra ""/read"" which needs to be added to the request URL as a prefix or suffix. I can do this directly by adding this to the PutMapping value, but I want to decorate it somewhat using annotation like **@Read**  So, the updated Controller class will be like       @RestController     @RequestMapping(""/something"")     public class SomeController {     @Read     @PutMapping(""/some/path/"")     public ResponseEntity> someMethod() {     ....     }     ...     } and the same way updated request URL will be like : **http://localhost:8080/read/something/some/path/**  I am unable to find a better way to do this. Till now I have only achieved adding a class-level prefix using custom annotation.  Can anyone please help with the above requirement.? Thank you !!  I am also curious to know whether is achievable or not even?","closed","for: stackoverflow,","pawank0411","2022-06-26T17:42:49Z","2022-06-26T21:34:02Z"
"","28566","Api for Group Video call using webRTC","I am creating video chat application by using webrtc and firebase. There seems to be an existing provision of  video call one to one. But I am facing issue in group chat.   How can we group chat using webRTC and firebase in Reactjs or Nextjs? Will I create own stun server for better security and scalability. If Yes which one is best stun server or turn server?  Also,  I was wondering if you could Video call people who are on different pages of the same website without having to be on the specific 'video call page' only?  What is the way to allow incoming calls even when you are not joined in a group? I believe it must be a group request (Sending a request to join from Person A to Person B). Is this possible using WebRTC?","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-06-05T10:18:31Z","2022-06-06T12:03:21Z"
"","28729","Class Proxy not working with native-image","I am adding support for the `@PreAuthorize`, `@PreFilter`, `@PostAuthorize`, and `@PostFilter` annotations from Spring Security.  The hints are being added using a `PrePostSecuredBeanRegistrationAotProcessor` and `PrePostSecuredBeanRegistrationAotContribution`, which can be seen [here](https://github.com/marcusdacoregio/spring-native/blob/security-method/samples/security-method/src/main/java/com/example/methodsecurity/PrePostSecuredBeanRegistrationAotProcessor.java), that's pretty much what [we had before](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-aot/src/main/java/org/springframework/security/PrePostSecuredNativeConfigurationProcessor.java) in the native repository.   However, the application fails when running on native with the following stacktrace:  ``` org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named 'greetingServiceImpl' is expected to be of type 'com.example.methodsecurity.GreetingService' but was actually of type 'jdk.proxy4.$Proxy235'         at org.springframework.beans.factory.support.DefaultListableBeanFactory.checkBeanNotOfRequiredType(DefaultListableBeanFactory.java:1800) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1777) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1340) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1294) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArgument(AutowiredInstantiationArgumentsResolver.java:302) ~[na:na]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolveArguments(AutowiredInstantiationArgumentsResolver.java:232) ~[na:na]         at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:154) ~[na:na]         at com.example.methodsecurity.MainController__BeanDefinitions.getMainControllerInstance(MainController__BeanDefinitions.java:30) ~[na:na]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[security-method:6.0.0-SNAPSHOT]         at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[security-method:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:729) ~[security-method:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:428) ~[security-method:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[security-method:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[security-method:3.0.0-SNAPSHOT]         at org.springframework.boot.SpringApplication.run(SpringApplication.java:1290) ~[security-method:3.0.0-SNAPSHOT]         at com.example.methodsecurity.MethodSecurityApplication.main(MethodSecurityApplication.java:19) ~[security-method:0.0.1-SNAPSHOT] ```  It runs fine in AOT only.  **To Reproduce:**  Run the `build.sh` script from [this sample](https://github.com/marcusdacoregio/spring-native/tree/security-method/samples/security-method).","closed","theme: aot,","marcusdacoregio","2022-06-29T17:40:51Z","2022-08-01T12:33:56Z"
"","28314","repo.spring.io，The website is not accessible","https://repo.spring.io，The website is not accessible。 [ERROR]     Non-resolvable parent POM for com.example:demo:0.0.1-SNAPSHOT: Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom:3.0.0-M2 from/to spring-milestones (https://repo.spring.io/milestone): Transfer failed for https://repo.spring.io/milestone/org/springframework/boot/spring-boot-starter-parent/3.0.0-M2/spring-boot-starter-parent-3.0.0-M2.pom 504 Gateway Time-out。","closed","status: invalid,","renpengben","2022-04-10T13:13:16Z","2022-04-10T16:33:34Z"
"","28313","repo.spring.io is down","https://repo.spring.io/ returns 504  builds using dependancies from it stopped working","closed","status: invalid,","walec51","2022-04-10T11:45:23Z","2022-04-10T12:30:54Z"
"","27951","Conversion failed through explicit converter though bypassed internally","https://github.com/spring-projects/spring-framework/blob/e565d2cabb01539933195b0d1bc3b55992fb9c84/spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java#L133  I defined a UUID converter file implementing Converter interface. And it works expected, for a particular use case I am able to throw an exception. However internally this exception is by passed in the selected code and implicit conversion is applied which is incorrect.","open","status: feedback-provided,","joshibhu","2022-01-19T08:46:44Z","2022-01-19T16:47:57Z"
"","28707","I need a little help with use of CronExpression.","https://github.com/spring-projects/spring-framework/blob/730d6c95fcb8352d1d81079904deeb6518e90454/spring-context/src/main/java/org/springframework/scheduling/support/BitsCronField.java#L155  I need to manually generate CronExpression，ex. ""0 */10 * * * ?""  What I want is the correct answer for the time expression. But the time I got min was always ""0,10,20,30..."" because the baseline time is not included in the ValueRange construction.I have a headache and need help. ty","closed","status: feedback-provided,","LGtaer","2022-06-27T03:42:22Z","2022-06-27T13:45:27Z"
"","28633","Support adding rather than replacing modules in Jackson2ObjectMapperBuilder","https://github.com/spring-projects/spring-framework/blob/67b1420b32cadef349bb60490b6e07cc5f882ecc/spring-web/src/main/java/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.java#L570-L574  Currently the `Jackson2ObjectMapperBuilderCustomizer` is only able to replace the modules that should be installed; however, it is possible to define multiple Spring Boot `Jackson2ObjectMapperBuilderCustomizer` beans that could each wish to add a Jackson module. However the later customizers will always remove the modules configured by the previous instance. It isn't possible to get the current list of modules either and extend that.  We wish to separate our customizers by their related modules/source libraries (api-docs, error-handling, ..., and the application itself).  So it would be nice if there was a `addModules(toInstall)` method that would add the modules to the list instead of replacing it.  Most of the other methods such as `serializers(JsonSerializer...)` already work like that:  https://github.com/spring-projects/spring-framework/blob/67b1420b32cadef349bb60490b6e07cc5f882ecc/spring-web/src/main/java/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.java#L354-L363  Thanks for your awesome work.","closed","type: enhancement,","AQS-DTheuke","2022-06-15T13:08:07Z","2022-07-13T18:24:45Z"
"","27924","The range requests are not working with FileSystemResource in body","https://github.com/spring-projects/spring-framework/blob/1984cfe9d79e8a34955a393ef9d71a2a3d11a87c/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java#L196-L213  Debugged through the code.  What I observed was in the lines   ```java body = HttpRange.toResourceRegions(httpRanges, resource); valueType = body.getClass(); ```  `valueType` is always an `Arraylist` since the return type of the `toResourceRegions` is a `List`.  This is causing the later logic related to message converters based on `valueType` to fail.  In the end we get the exception as below:  ``` org.springframework.http.converter.HttpMessageNotWritableException: No converter for [class java.util.ArrayList] with preset Content-Type 'application/vnd.ncr.connections.cs.car.v1+zip'  org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:312) ```","closed","status: invalid,","ab185034","2022-01-12T14:02:06Z","2022-01-13T13:33:39Z"
"","28258","DataSourceUtils discards IllegalStateException stacktrace","https://github.com/spring-projects/spring-framework/blob/03e695ad5ff998d8da9b89d163ec4f04747bd570/spring-jdbc/src/main/java/org/springframework/jdbc/datasource/DataSourceUtils.java#L86  I'm unsure why `SQLException` is retained as a cause but `IllegalStateException` is discarded. It makes things like this very hard to debug: ``` org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection: Session/EntityManager is closed     at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:86)     at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:330)     at org.springframework.boot.actuate.jdbc.DataSourceHealthIndicator.getProduct(DataSourceHealthIndicator.java:122)     at org.springframework.boot.actuate.jdbc.DataSourceHealthIndicator.doDataSourceHealthCheck(DataSourceHealthIndicator.java:105)     ... ```","closed","status: superseded,","OrangeDog","2022-03-31T09:23:05Z","2022-06-23T07:04:00Z"
"","28489","I need help","https://github.com/spring-projects/spring-framework/blob/03e695ad5ff998d8da9b89d163ec4f04747bd570/spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.java#L289-L292","closed","status: invalid,","dAVIDKOFRON-HURTHEAD-DESTROYED-FROMHACK","2022-05-20T01:09:02Z","2022-05-20T05:18:43Z"
"","28589","Fix Kotlin example for dependency injection with static factory method","https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-some-examples  kotlin changed to:  ```kotlin class ExampleBean private constructor() {     companion object {         // a static factory method; the arguments to this method can be         // considered the dependencies of the bean that is returned,         // regardless of how those arguments are actually used.         @JvmStatic         fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean {             val eb = ExampleBean (...)             // some other operations...             return eb         }     } } ```","closed","in: kotlin,","SchroedingersGitHub","2022-06-09T03:10:09Z","2022-06-09T12:00:08Z"
"","28628","Fix Kotlin example for @ComponentScan basePackages attribute","https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-scanning-filters  kotlin to:  ```kotlin  @Configuration @ComponentScan(basePackages = [""org.example""],         includeFilters = [Filter(type = FilterType.REGEX, pattern = ["".*Stub.*Repository""])],         excludeFilters = [Filter(Repository::class)]) class AppConfig {     // ... }  ```","closed","in: kotlin,","SchroedingersGitHub","2022-06-15T04:34:35Z","2022-06-15T09:28:42Z"
"","28590","Fix Kotlin example for  @Required","https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation  ```kotlin class SimpleMovieLister {     lateinit var movieFinder: MovieFinder              @Required               set     // ... } ```","closed","in: kotlin,","SchroedingersGitHub","2022-06-09T03:13:20Z","2022-06-15T08:27:32Z"
"","28399","Fix Kotlin example for static factory method","https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class-static-factory-method  kotlin changed to:   ```kotlin class ClientService private constructor() {     companion object {         private val clientService = ClientService()         @JvmStatic         fun createInstance() = clientService     } } ```","closed","in: core,","SchroedingersGitHub","2022-04-29T22:30:09Z","2022-05-11T15:35:43Z"
"","28680","Fix Kotlin example for defines a custom @Production","https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles-java  ```kotlin @Target(AnnotationTarget.CLASS) @Retention(AnnotationRetention.RUNTIME) @Profile(""production"") annotation class Production ```","closed","in: kotlin,","SchroedingersGitHub","2022-06-23T02:55:05Z","2022-07-13T08:14:50Z"
"","28604","Document need for `kotlin-spring` plugin regarding `open` keyword","https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation-primary  kotlin to   ```kotlin @Configuration open class MovieConfiguration {      @Bean     @Primary     open fun firstMovieCatalog(): MovieCatalog { ... }      @Bean     open fun secondMovieCatalog(): MovieCatalog { ... }      // ... } ```","open","in: kotlin,","SchroedingersGitHub","2022-06-10T10:19:36Z","2022-06-15T09:05:50Z"
"","28020","Upgrade to Gradle 7.4","https://docs.gradle.org/7.4/release-notes.html","closed","type: task,","sbrannen","2022-02-08T15:26:13Z","2022-02-08T15:27:51Z"
"","28713","Support to guarantee transactions by using @EventListener and ReactiveTransactionManager","Hi. If you register ReactiveTransactionManager as Spring Bean and use @Transactional annotation, you can guarantee transaction.   However, when using @EventListener or @TransactionalEventListener together, transaction cannot be guaranteed.  Do you have any plans to support this?","closed","status: duplicate,","pkgonan","2022-06-27T16:46:22Z","2022-06-28T11:06:09Z"
"","28072","configurationClasses has no useful data","Hi,The beandifinition scanned by componentscan should not be placed in the configurationClasses container, because the loadBeanDefinitions method does not do any processing for this part of the data.","closed","in: core,","Evanhelovex","2022-02-18T07:10:42Z","2022-02-19T08:33:26Z"
"","28192","Received status code 401 from server: Unauthorized","Hi, thank you for reading  my dev environment is spring-framework-5.0.19 , java8.  when i import the project into idea and run build , i got the error 'Could not HEAD 'https://repo.spring.io/libs- release/io/netty/netty-bom/4.1.39.Final/netty-bom-4.1.39.Final.pom''. how could i resolve this error?  thanks again","closed","for: stackoverflow,","qianxifu","2022-03-17T02:50:03Z","2022-03-17T08:00:26Z"
"","28004","Polish reference docs (core)","Hi, team!  Just minor reference docs polishing to make it best documentation ever ;)","closed","type: documentation,","An1s9n","2022-02-04T05:25:59Z","2022-02-04T08:25:18Z"
"","28240","Make use of new HtmlUnit API for access request parameters","Hi, i'm the maintainer of HtmlUnit and i like to finally fix the issues #25768 and https://github.com/HtmlUnit/htmlunit/issues/223.  Did some analysis during the last day's - sorry for the long text here but i like to make my view on this clear and hopefully we can discuss and find a good solution. Did my analysis based on the sample here - https://github.com/thuri/htmlunit-test-project/tree/JQueryAjax  Lets start with the WebRequest class from HtmlUnit: * this is more or less an internal class * the api of that class is really **bad designed** ** parameter and body are exclusive - you can only have one ** the usage of the class requires some internal knowledge of how the request got filled ** many more  **Now the problem** - from my point of view: org.springframework.test.web.servlet.htmlunit.HtmlUnitRequestBuilder.params(MockHttpServletRequest, UriComponents) only takes parts of the (internal) logic of WebRequest into account; at the moment only the url and the parameters are checked when reading the parameters. There are more cases where the parameters are url-encoded in the body - these cases are the reason for the misbehavior.  **Possible solutions** Option 1: To fix the problem we can improve the HtmlUnitRequestBuilder.params implementation to reflect the whole functionality used by HtmlUnit But i think this is not really maintainable - every time HtmlUnit changes parts of the internal magic here you have to fix something.  **Option 2** (my preferred one): We agree on a more stable interface for WebRequest that hides the internal parameter handling and always returns all the parameter (key value pairs) like e.g. the servlet api does. HtmlUnitRequestBuilder can use this method and gets always all params.  I have already prototyped this solution (breaking HtmlUnits backwardcomatibility) by changing the com.gargoylesoftware.htmlunit.WebRequest.getRequestParameters() method in the way described above (the impl is available as 2.61.0-SNAPSHOT). This fixes the problems but introduces a new one because the url paramters are doubled now (because HtmlUnitRequestBuilder.params(MockHttpServletRequest, UriComponents) handles this params already).  Because of this i like to get some feedback from you how we should proceed here.  Or to summarize * i like to change HtmlUnit WebRequest to provide an API that returns always all request parameters (at best without breaking backward compatibility) * you change the impl of HtmlUnitRequestBuilder.params() to use only this method  Many thanks     Ronald     (rbri at rbri.de)","open","type: enhancement,","rbri","2022-03-27T10:15:57Z","2022-07-28T14:22:15Z"
"","28637","Inject @PathVariable variables in argument DTO","Hi, I have this code in one of my controllers:  ```java   @PutMapping(""{id}"")   public EntityDTO update(@PathVariable(""id"") String id, @RequestBody EntityDTO entityDTO) {     entityDTO.setId(id);     Entity entity = entityMapper.map(entityDTO);     Entity updated = entityService.save(entity);     return entityDTOMapper.map(updated);   } ```  I want to avoid the `entityDTO.setId(id);` line and add the `id` to the `entityDTO` in an cleaner way, but I didn't find a suitable approach in Spring.  Using an argument resolver is a mess for such a simple task, but maybe it can be achieved injecting the `id` in `entityDTO` in the following way:  ```java public class EntityDTO {    @PathVariable(""id"")   private String id;   ... } ```  Validation stuff should occur once the DTO is constructed.  I did a lot of research, and I found a lot of users wanting this feature or facing this problem of packaging the whole thing (body + query parameters) in a DTO before mapping to entity.","open","in: web,","italktothewind","2022-06-16T06:03:59Z","2022-06-17T07:26:05Z"
"","28452","SPEL: In the map, variables are used as keys to obtain value, and unexpected results occur","Hi, engineers. When I use thymeleaf, I intend to use variables as keys in the map to obtain value, but by default, it seems to use variable names as strings.  The key source code is as follows: ```java class Node {     public Map mapStr;     public String s1;     {         mapStr = new HashMap<>();         mapStr.put(""1"", ""1"");         mapStr.put(""s1"", ""s1"");         s1 = ""1"";     } } SpelExpressionParser parser = new SpelExpressionParser(); System.out.println(""mapStr===>"" + parser.parseExpression(""mapStr"").getValue(new Node(), Map.class)); System.out.println(""s1===>"" + parser.parseExpression(""s1"").getValue(new Node(), String.class)); System.out.println(""mapStr[s1]===>"" + parser.parseExpression(""mapStr[s1]"").getValue(new Node(), String.class)); System.out.println(""mapStr[''+s1]===>"" + parser.parseExpression(""mapStr[''+s1]"").getValue(new Node(), String.class)); ```  The output results are as follows: ```java mapStr===>{1=1, s1=s1} s1===>1 mapStr[s1]===>s1    //In my opinion, the result here should be 1 mapStr[''+s1]===>1 ```  How to deal with this situation? It has bothered me for a week","closed","in: core,","liuhanguang123","2022-05-12T07:24:40Z","2022-05-16T10:39:10Z"
"","28378","Move class Operation into package org.springframework.expression.spel.ast, class SpringVersion into package org.springframework.lang.","Hi, @snicoll  @poutsma   **_Issue Description_**  Package **_org.springframework.expression_**, **_org.springframework.core_** are a promiscuous package, and groups together miscellaneous functionalities that might be useful to different subsystems. The package structure violates the “high cohesion and low coupling” design rules. I found that Class **_Operation_**, **_SpringVersion_** is not used by classes in their package. The project has grown larger, leading to becoming increasingly hard to maintain. During the development process, one groups together classes (that often co-change) with similar responsibilities in one package to facilitate maintenance, which prevents a change that causes other packages to be modified. For example, if one modifies package **_org.springframework.expression_** (i.e., package rename), resulting in multiple classes of package **_org.springframework.expression.spel.ast_** to be changed.  Location: The source file can be found at path File  spring-expression/src/main/java/org/springframework/expression/Operation.java spring-core/src/main/java/org/springframework/core/SpringVersion.java  **Refactoring suggestions**  I suggest to move class **_Operation_** into package **_org.springframework.expression.spel.ast_**, class **_SpringVersion_** into package **_org.springframework.lang_**.","closed","in: core,","EscortSC","2022-04-25T13:58:39Z","2022-04-28T14:34:30Z"
"","28022","spring.components not generated using ant ivy.xml","Hi,   I want to implement sprint-context-indexer in my project, and I'm using ant ivy.xml. I've added the dependency, but the spring.components is not  automatically generated for some reason.  Dependency:   ` `  Does anyone know what is the problem, and possible solution? Thanks!","closed","for: stackoverflow,","marjanovicstefan","2022-02-09T11:14:20Z","2022-02-09T13:17:07Z"
"","28299","Clarify recommendation on self injecting for legitimate use cases (e.g. @Transactional re-entrant calls)","Hi, It is becoming harder and harder to use self-injection:    - Spring boot 2.6 forbids it by default: https://github.com/spring-projects/spring-boot/issues/27652   - spring boot 2.6.4 broke @SpyBean: https://github.com/spring-projects/spring-boot/issues/30575  There are probably more small issues like this. However, unlike more general dependency cycles, self-injection seems to be considered a legitimate strategy for some use cases  (e.g. `@Transactional`, `@Cacheable`  re-entrant calls ) by many.  https://github.com/spring-projects/spring-boot/issues/27652#issuecomment-1090771850 recommended to raise an issue to the framework team.   Is there an official documented strategy and list of legitimate use cases for self-injection ? https://github.com/spring-projects/spring-framework/issues/27534#issuecomment-938632203 for example recommends `@Lazy`. Or are there other implementation strategies that can be used to replace self-injection in these use cases? My personal interest is purely reentrant calls from service beans on `@Transactional` methods.   This issue could be used to track documentation fixes to clarify these common use cases.  Thanks in advance","open","in: core,","jonenst","2022-04-07T13:17:38Z","2022-06-07T21:26:12Z"
"","28548","Spring web socket stomp client NumberFormateException for RabbitMQ stomp pluging","Hi, I have bee  doing R&D on where to open issue regarding spring websocket web stomp client configured with rabbitmq web stomp but could not find so posting here in hope to get any help on my issue. Issue : My spring boot application is trying to connect to rabbitMQ stomp server on default port **61613**  but throwing an exception **java.lang.NumberFormatException: For input string: ""tcp://10.37.216.254:61613""** which i'm unable to understand why this is being thrown.  My java application and RMQ is deployed on kubernetes cluster. Posting below code snippets and full logs.  ```java public void configureMessageBroker(MessageBrokerRegistry config) {          System.out.println(""****RelayHost: "" + rabbitMqHost + "" RelayPort: "" + rabbitMqPort);         /**          * Destination for sending and receiving messages          */         config.enableStompBrokerRelay(""/topic"", ""/queue"")                 .setRelayHost(""rabbitmq"")//rabbitmq.switch.svc.cluster.local                 .setRelayPort(61613)                 .setClientLogin(""root"")                 .setClientPasscode(""password"");          config.setApplicationDestinationPrefixes(""/app"");         config.setUserDestinationPrefix(""/chat"");      } ```     **logs**  ``` Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'brokerMessagingTemplate' defined in class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class]: Unsatisfied dependency expressed through method 'brokerMessagingTemplate' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'brokerChannel' defined in class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class]: Unsatisfied dependency expressed through method 'brokerChannel' parameter 2; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'brokerChannelExecutor' defined in class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.core.task.TaskExecutor]: Factory method 'brokerChannelExecutor' threw exception; nested exception is java.lang.NumberFormatException: For input string: ""tcp://10.37.216.254:61613""         at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:800) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:541) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.12.jar!/:5.3.12]         ... 28 common frames omitted Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'brokerChannel' defined in class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class]: Unsatisfied dependency expressed through method 'brokerChannel' parameter 2; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'brokerChannelExecutor' defined in class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.core.task.TaskExecutor]: Factory method 'brokerChannelExecutor' threw exception; nested exception is java.lang.NumberFormatException: For input string: ""tcp://10.37.216.254:61613""         at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:800) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:541) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791) ~[spring-beans-5.3.12.jar!/:5.3.12]         ... 41 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'brokerChannelExecutor' defined in class path resource [org/springframework/web/socket/config/annotation/DelegatingWebSocketMessageBrokerConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.core.task.TaskExecutor]: Factory method 'brokerChannelExecutor' threw exception; nested exception is java.lang.NumberFormatException: For input string: ""tcp://10.37.216.254:61613""         at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:658) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:638) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1352) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1195) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:582) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:887) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:791) ~[spring-beans-5.3.12.jar!/:5.3.12]         ... 55 common frames omitted Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.core.task.TaskExecutor]: Factory method 'brokerChannelExecutor' threw exception; nested exception is java.lang.NumberFormatException: For input string: ""tcp://10.37.216.254:61613""         at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:185) ~[spring-beans-5.3.12.jar!/:5.3.12]         at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:653) ~[spring-beans-5.3.12.jar!/:5.3.12]         ... 69 common frames omitted Caused by: java.lang.NumberFormatException: For input string: ""tcp://10.37.216.254:61613""         at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) ~[na:1.8.0_212]         at java.lang.Integer.parseInt(Integer.java:580) ~[na:1.8.0_212]         at java.lang.Integer.parseInt(Integer.java:615) ~[na:1.8.0_212]         at com.community.chat.config.WebSocketConfig.configureMessageBroker(WebSocketConfig.java:51) ~[classes!/:0.0.1-SNAPSHOT]         at org.springframework.web.socket.config.annotation.DelegatingWebSocketMessageBrokerConfiguration.configureMessageBroker(DelegatingWebSocketMessageBrokerConfiguration.java:113) ~[spring-websocket-5.3.12.jar!/:5.3.12]         at org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration.getBrokerRegistry(AbstractMessageBrokerConfiguration.java:267) ~[spring-messaging-5.3.12.jar!/:5.3.12]         at org.springframework.messaging.simp.config.AbstractMessageBrokerConfiguration.brokerChannelExecutor(AbstractMessageBrokerConfiguration.java:241) ~[spring-messaging-5.3.12.jar!/:5.3.12]         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_212]         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_212]         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_212]         at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_212]         at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.3.12.jar!/:5.3.12]         ... 70 common frames omitted ```","closed","status: invalid,","Nomi67","2022-05-31T20:34:13Z","2022-06-01T08:39:47Z"
"","28071","Support profile for custom properties/yaml","Hi, Can spring provide profile support for custom properties/yaml (i.e not application.yaml, nor application.properties).  That is, spring would AUTO append the active profile when searching for the custom properties. E.g abc-dev.properties or abc-yaml   When there is no profile added, it would just search for abc.properties or abc.yaml (as an example).","closed","for: stackoverflow,","hanct","2022-02-18T06:37:08Z","2022-02-18T08:15:18Z"
"","28603","Fix code sample for nested router functions","Hi, About nested Routes in Web on Reactive Docs , https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#nested-routes  says  `path(""/person"", builder -> ...  .POST(""/person"", ...)).build();`   it means that API will be  `POST ""/person/person""`, however this example is how to construct nest path without duplication so I think it is not RESTful.    Is this intentional? if not, how about to update like ``` java RouterFunction route = route()     .path(""/person"", builder -> builder          .GET(""/{id}"", accept(APPLICATION_JSON), handler::getPerson)         .GET(accept(APPLICATION_JSON), handler::listPeople)         .POST("""", handler::createPerson))     .build(); ```","closed","in: web,","daehwan2yo","2022-06-10T03:07:31Z","2022-06-10T11:40:35Z"
"","28727","AOT generated code leads to exception on startup: Object of class [java.lang.Boolean] must be an instance of boolean","Hi,  when running a Spring Boot project with the `starter-integration` in it in AOT mode, it crashes on startup with this exception:  ``` org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'errorChannel': Instantiation of supplied bean failed 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1234) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainFromSupplier(AbstractAutowireCapableBeanFactory.java:1209) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1156) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:566) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) ~[spring-context-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) ~[spring-context-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:729) ~[spring-boot-3.0.0-SNAPSHOT.jar!/:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:428) ~[spring-boot-3.0.0-SNAPSHOT.jar!/:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[spring-boot-3.0.0-SNAPSHOT.jar!/:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[spring-boot-3.0.0-SNAPSHOT.jar!/:3.0.0-SNAPSHOT] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1290) ~[spring-boot-3.0.0-SNAPSHOT.jar!/:3.0.0-SNAPSHOT] 	at com.example.integrationaot.IntegrationAotApplication.main(IntegrationAotApplication.java:10) ~[classes!/:0.0.1-SNAPSHOT] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na] 	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[integration-aot-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:95) ~[integration-aot-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] 	at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[integration-aot-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] 	at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:65) ~[integration-aot-0.0.1-SNAPSHOT.jar:0.0.1-SNAPSHOT] Caused by: java.lang.IllegalArgumentException: Object of class [java.lang.Boolean] must be an instance of boolean 	at org.springframework.util.Assert.instanceCheckFailed(Assert.java:702) ~[spring-core-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.util.Assert.isInstanceOf(Assert.java:602) ~[spring-core-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.util.Assert.isInstanceOf(Assert.java:633) ~[spring-core-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredArguments.get(AutowiredArguments.java:45) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.integration.channel.PublishSubscribeChannel__BeanDefinitions.lambda$getErrorChannelInstance$0(PublishSubscribeChannel__BeanDefinitions.java:31) ~[classes!/:0.0.1-SNAPSHOT] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:63) ~[spring-core-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.util.function.ThrowingFunction.apply(ThrowingFunction.java:51) ~[spring-core-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.beans.factory.aot.AutowiredInstantiationArgumentsResolver.resolve(AutowiredInstantiationArgumentsResolver.java:156) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	at org.springframework.integration.channel.PublishSubscribeChannel__BeanDefinitions.getErrorChannelInstance(PublishSubscribeChannel__BeanDefinitions.java:31) ~[classes!/:0.0.1-SNAPSHOT] 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.obtainInstanceFromSupplier(AbstractAutowireCapableBeanFactory.java:1223) ~[spring-beans-6.0.0-SNAPSHOT.jar!/:6.0.0-SNAPSHOT] 	... 25 common frames omitted ```  This looks like a bug in the AOT generated code (?).  Reproducer repo: https://github.com/mhalbritter/integration-aot","closed","theme: aot,","mhalbritter","2022-06-29T12:18:18Z","2022-06-29T15:04:03Z"
"","28723","Wrong schema used when calling a stored procedure through SimpleJdbcCall","Hi,  I have issues trying to call a stored procedure using postgresql database through a `SimpleJdbcCall`.  I set the current schema to use with the parameter `currentSchema` inside `jdbcUrl` parameter like this:  `jdbc:postgresql://localhost:5455/userdb?currentSchema=customschema`  ""Standard"" queries such as `jdbcTemplate.query(...)` use the correct schema which is `customschema`.  Though when I try to call a stored procedure through `SimpleJdbcCall`, it uses the default postgres schema `public`.  ```java new SimpleJdbcCall(jdbcTemplate).withFunctionName(""custom_stored_procedure_name"").execute(); ```  I know I can force the use of `customschema` on each call with `.withSchemaName(""customschema"")`, but I shouldn't need to do this.  While debugging, if I look at `jdbcTemplate.getDataSource().getConnection().getSchema()`, it returns the correct schema which is ""customschema"".","open","in: data,","hyukchan","2022-06-28T15:53:47Z","2022-07-01T17:03:18Z"
"","28070","PluggableSchemaResolver not pulling in all jars from classpath?","Hi,  I have an open issue with a spring5 app,  The only workaround I have found is to logically put spring-beans-5.3.13.jar first in the classpath. Any guidance is well appreciated, thank you.  the cfg.xml has standard definition at the top ```    ``` My classpath contains all the jars: `price_alerts/lib/spring-aop-5.3.13.jar:price_alerts/lib/spring-beans-5.3.13.jar:price_alerts/lib/spring-context-5.3.13.jar:price_alerts/lib/spring-core-5.3.13.jar:price_alerts/lib/spring-expression-5.3.13.jar:  but dies here because its trying to go the internet because it seemingly only searches  the first jar in the classpath spring-aop jar spring.schemas info and then goes to the internet, it never gets spring-beans-5.3.13.jar and looks in spring.schemas there.   ``` TRACE (2022-02-17 11:56:41,249) [main] (XmlBeanDefinitionReader) - Loading XML bean definitions from class path resource [cfg.xml] TRACE (2022-02-17 11:56:41,258) [main] (DefaultDocumentLoader) - Using JAXP provider [org.apache.xerces.jaxp.DocumentBuilderFactoryImpl] TRACE (2022-02-17 11:56:41,354) [main] (PluggableSchemaResolver) - Trying to resolve XML entity with public id [null] and system id [http://www.springframework.org/schema/beans/spring-beans-3.0.xsd] TRACE (2022-02-17 11:56:41,354) [main] (PluggableSchemaResolver) - Loading schema mappings from [META-INF/spring.schemas] TRACE (2022-02-17 11:56:41,367) [main] (PluggableSchemaResolver) - Loaded schema mappings: {https://www.springframework.org/schema/aop/spring-aop.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-4.3.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-3.1.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-3.0.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-3.1.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-4.3.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-2.0.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-4.1.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-4.1.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-2.0.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-2.5.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-3.0.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-3.2.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-3.2.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-4.2.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-2.5.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-4.2.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop-4.0.xsd=org/springframework/aop/config/spring-aop.xsd, http://www.springframework.org/schema/aop/spring-aop.xsd=org/springframework/aop/config/spring-aop.xsd, https://www.springframework.org/schema/aop/spring-aop-4.0.xsd=org/springframework/aop/config/spring-aop.xsd} DEBUG (2022-02-17 11:58:48,762) [main] (ResourceEntityResolver) - Could not resolve XML entity [http://www.springframework.org/schema/beans/spring-beans-3.0.xsd] through URL [https://www.springframework.org/schema/beans/spring-beans-3.0.xsd] java.net.ConnectException: Connection timed out (Connection timed out)         at java.net.PlainSocketImpl.socketConnect(Native Method) ~[?:?]         at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:412) ~[?:?]         at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:255) ~[?:?]         at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:237) ~[?:?]         at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) ~[?:?]         at java.net.Socket.connect(Socket.java:609) ~[?:?]         at sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:300) ~[?:?]         at sun.security.ssl.BaseSSLSocketImpl.connect(BaseSSLSocketImpl.java:173) ~[?:?]         at sun.net.NetworkClient.doConnect(NetworkClient.java:182) ~[?:?]         at sun.net.www.http.HttpClient.openServer(HttpClient.java:474) ~[?:?]         at sun.net.www.http.HttpClient.openServer(HttpClient.java:569) ~[?:?]         at sun.net.www.protocol.https.HttpsClient.(HttpsClient.java:266) ~[?:?]         at sun.net.www.protocol.https.HttpsClient.New(HttpsClient.java:373) ~[?:?]    ```","closed","","andre-fxcm","2022-02-18T02:37:14Z","2022-03-04T13:46:12Z"
"","28377","Slow SpEL performance due to method sorting in ReflectiveMethodResolver","Hi,  I am using Spring expression language (5.3.15). I found  following method does sorting on a list of methods  (ReflectiveMethodResolver).   public MethodExecutor resolve(EvaluationContext context, Object targetObject, String name, 			List argumentTypes) throws AccessException   I did some benchmarking and found it cost me  atleast 100 millisecond more .  Is it possible to make this sorting optional ? I am attaching the benchmark logs with and without sorting .   Do we really need the following code ? 			// Sort methods into a sensible order 	/*		if (methods.size() > 1) { 				methods.sort((m1, m2) -> { 					 if(m1==null ||m2==null) 					 { 						  						 System.out.println(""==================Some method came null  ""); 					 } 					int m1pl = m1.getParameterCount(); 					int m2pl = m2.getParameterCount(); 					// vararg methods go last 					if (m1pl == m2pl) { 						if (!m1.isVarArgs() && m2.isVarArgs()) { 							return -1; 						} 						else if (m1.isVarArgs() && !m2.isVarArgs()) { 							return 1; 						} 						else { 							return 0; 						} 					} 					return Integer.compare(m1pl, m2pl); 				}); 			}*/  Thanks, Aashish [translator-without-sorting.log](https://github.com/spring-projects/spring-framework/files/8555131/translator-without-sorting.log) [translatorwith-sorting-.log](https://github.com/spring-projects/spring-framework/files/8555134/translatorwith-sorting-.log)","open","in: core,","aashishin","2022-04-25T13:55:53Z","2022-04-26T07:27:46Z"
"","28388","Error creating bean with name DataSourceProperties due to AnnotationConfigApplicationContext has been closed already","Hi,  I am getting  below error while running a spring boot application:  2022-04-27 03:56:01.623 ERROR 11 --- [rule-executor-2] {} com.racv.common.utils.ExceptionUtil : Got error on app RefundApp -> Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaConfiguration': Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: **Error creating bean with name 'getDataSource' defined in class path** resource [com/racv/refundautomation/ApplicationConfiguration.class]: Initialization of bean failed; nested exception is **org.springframework.beans.factory.UnsatisfiedDependencyException:** Error creating bean with name 'org.springframework.boot.autoconfigure.jdbc.DataSourceInitializerInvoker': Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.boot.context.properties.ConfigurationPropertiesBindException: Error creating bean with name 'spring.datasource-org.springframework.boot.autoconfigure.jdbc.DataSourceProperties': Could not bind properties to 'DataSourceProperties' : prefix=spring.datasource, ignoreInvalidFields=false, ignoreUnknownFields=true; nested exception is java.lang.IllegalStateException: **org.springframework.context.annotation.AnnotationConfigApplicationContext**@224aed64 has been closed already on class -> RefundService at method -> saveFilteredRecords() on ruleNumber -> null  Could you please suggest a solution for this problem.","closed","status: waiting-for-triage,","NavyaSurendran","2022-04-27T04:34:15Z","2022-04-27T05:53:48Z"
"","28615","Non Singletons being included even with includeNonSingletons","Hi!  I have seen that [this verification](https://github.com/spring-projects/spring-framework/blob/v5.1.20.RELEASE/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultListableBeanFactory.java#L529) was removed.  I think that will result in beans being created even when you indicate that nonSingletons should not be included.  Can you verify if there is a reason [for not adding this change](https://github.com/fsgonz/spring-framework/commit/701b28d1230e830e17a1528fd244396706f1b1f5)?  This seems to be a bug introduced [here](https://github.com/spring-projects/spring-framework/commit/a0e462581fe1d27d5926809fbb21441a6685ef45#diff-7647ef528e5ffcfdb8ce8b88d189a906a1e7b46778323bc92cb9783a4991d5abR536)  Our app is failing because of this. I'll try to add a test but can you take a look at it meanwhile?","closed","status: superseded,","fsgonz","2022-06-13T21:42:21Z","2022-06-14T14:43:53Z"
"","28317","Can't compile old branch","Hi there,  I'm trying to compile an old branch and verify whether a code audit product works.  ``` git checkout v4.3.10.RELEASE ./gradlew build ```  And several packages are missing:  ``` * What went wrong: Execution failed for task ':spring-core:cglibRepackJar'. > Could not resolve all dependencies for configuration ':spring-core:jarjar'.    > Could not resolve com.googlecode.jarjar:jarjar:1.3.      Required by:          org.springframework:spring-core:4.3.10.RELEASE       > Could not resolve com.googlecode.jarjar:jarjar:1.3.          > Could not get resource 'https://repo.spring.io/libs-release/com/googlecode/jarjar/jarjar/1.3/jarjar-1.3.pom'.             > Could not GET 'https://repo.spring.io/libs-release/com/googlecode/jarjar/jarjar/1.3/jarjar-1.3.pom'. Received status code 401 from server: Unauthorized ```  Any suggestions?","closed","status: invalid,","CaledoniaProject","2022-04-11T03:11:59Z","2022-04-11T13:51:34Z"
"","28182","Need Spring Framwork version as per Compatiblility Matrix","Hi Team, Have one requirement to upgrade Spring Framwork version to compatible with Spring Boot 2.x  But here is my system's software/tool current version. 1. Spring Framework 4.1.5.RELEASE 2. Spring Boot 1.3.8.RELEASE 3. Oracle Java 8 4. IBM WebSphere 8.5.5.9  As part of future Roadmap we need to get rid of WebSphere & Use OpenJDK17 along with Spring Boot 2.x Can anyone suggest a compatible Spring Framework version that can work for Spring Boot 2.x + OpenJDK 17 + IBM Webspehere 8.5.5.9","closed","for: stackoverflow,","pardhukancharla","2022-03-15T15:02:53Z","2022-03-16T15:46:42Z"
"","28354","Spring Data MongoDB ThreadPool Bugs When Cluster works on nginx with springboot 2.6.4+","Hi All:   In project, I used the mongodb cluster repliset with nginx stream agent.  because of it, there are 4 available hosts (xxxx:30000,xxxx:30001,xxxx2:60000,xxxx2:60001)   when the program started, the springboot mongodb will check all those available hosts automatic (on my bootstrap.yml there are nginx agent hosts only) , after found some of these were nginx agent host, springboot mongodb will remove all these agent host on its connect pool ![yml](https://user-images.githubusercontent.com/95165616/163747386-5d010fa6-2116-4bf2-a2b2-0a10fc07b1dd.jpg)    but during on this, there is a exception throwed like this:  at com.mongodb.internal.connection.DefaultConnectionPool$BackgroundMaintenanceManager.start(DefaultConnectionPool.java:1433)  I check this code, find this error was throwed due to when springboot mongodb try to remove nginx agent host from a ScheduledThreadPoolExecutor and find that executor was already terminated.  when I switch springboot version to 2.6.3, it works fine. all version after 2.6.4 will make this error. and when I used springboot 2.6.4 but with spring-boot-starter-data-mongodb 2.6.3, it will make this error also. so I think some synchronized lock changed on 2.6.4 and make it happened.  plz check it, thanks very much. ![springboot bug](https://user-images.githubusercontent.com/95165616/163746139-86cc4444-3838-45ce-a891-7c65632525cb.jpg)","closed","for: external-project,","Qingyu-Limitless","2022-04-18T02:43:58Z","2022-06-29T14:36:07Z"
"","28611","java.lang.IllegalStateException with @NestedTestConfiguration","Hi  I tried to use `@NestedTestConfiguration` as described in the Spring documentation. So this is the original test class that works properly:  ```java @SpringJUnitConfig(AppConfig.class) @TestPropertySource(properties = { ""db.port=7000"", ""db.name=local"" }) public class ServerTest {  	@Nested 	@TestPropertySource(properties = ""db.port=8000"") 	public class ServerLoadConfiguration { ```  Then I want to override my Spring configuration in the inner class and I try to put `@NestedTestConfiguration(EnclosingConfiguration.OVERRIDE)` either on `ServerLoadConfiguration` class or `ServerTest` class, but in both cases I always get an exception:  ``` Caused by: java.lang.IllegalStateException: Neither GenericXmlContextLoader nor AnnotationConfigContextLoader was able to load an ApplicationContext from [MergedContextConfiguration@5ef6ae06 testClass = ServerTest.ServerLoadConfiguration, locations = '{}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{db.port=8000}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]]. 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:255) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:123) ```  Spring version: 6.0.0-M4","closed","status: invalid,","sergey-morenets","2022-06-13T07:20:18Z","2022-06-14T09:10:39Z"
"","28424","Add assertions to complete the test case of detectAllHandlerAdapters","Hey guys,  The test code in the case of detectAllHandlerAdapters was not completed. I would like to add 2 assertions, as the test case of notDetectAllHandlerAdapters did.","closed","status: declined,","nealshan","2022-05-08T03:24:02Z","2022-05-11T14:26:06Z"
"","28459","Add assertions to the test case of nullReturningBeanPostProcessor","Hey Guys,  I would like to update the test code of nullReturningBeanPostProcessor. 1. Remove the second bean BeanPostProcessor since it does not help to understand the test case. 2. Add an assertion to tell, if a BeanPostProcessor returns null, the existing bean will be returned.","closed","in: core,","nealshan","2022-05-14T12:47:35Z","2022-05-14T16:41:30Z"
"","28131","Add GraalVM native JSON configuration generation","Here is a PR intended to be a proposal to implement #27991.  The related commit implements 4 package private Jackson `JsonSerializer` for `JavaSerializationHints`, `ProxyHints`, `ReflectionHints` and `ResourceHints` to serialize GraalVM native JSON configuration as documented in https://www.graalvm.org/22.0/reference-manual/native-image/BuildConfiguration/.  It exposes the related functionality via `NativeConfigurationGenerator` which allows to generate the relevant files on the filesystem.  The generated `*-config.json` files has been validated working with GraalVM 22.0.  Looking forward to your feedback @jhoeller.","closed","theme: aot,","sdeleuze","2022-03-03T14:37:29Z","2022-03-16T15:27:26Z"
"","27950","Fix the ServletRequestPathUtils PATH_ATTRIBUTE is a runtime constant","Hello,this pull request is fix the problem https://github.com/spring-projects/spring-framework/issues/27946","closed","status: declined,","xixingya","2022-01-19T02:31:57Z","2022-02-14T15:23:13Z"
"","28094","CollectionFactory add createSingletonCollection method","Hello,this pr may solve this https://github.com/spring-projects/spring-framework/issues/28025 if I misundertand it please tell me, thank you!  why use Collectors can easily confuse the compiler","closed","status: declined,","xixingya","2022-02-22T11:47:49Z","2022-02-22T12:38:44Z"
"","28428","Documentation updated with instructions for STOMP Client","Hello, this pr may update the issue https://github.com/spring-projects/spring-framework/issues/28409","closed","status: declined,","xixingya","2022-05-09T02:43:11Z","2022-07-29T15:50:39Z"
"","28103","Invalid SockJS path","Hello, in our project I found strange behaviour with this DefaultSockJsService.   We using spring boot 2.5.5 and this dependencies:               org.springframework.boot             spring-boot-starter-websocket                               org.springframework.boot             spring-boot-starter-webflux                               org.springframework.boot             spring-boot-starter-reactor-netty           We received next exception:  DefaultSockJsService : Invalid SockJS path '/online-security-bundling/process' - required to have 3 path segments  We see this strange behaviour only on prod env in google cloud while receiving requests from google pub/sub. Maybe you know why it's hepenning?   https://github.com/spring-projects/spring-framework/blob/65394b00ea421a75318daef6d60378875868249a/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/handler/DefaultSockJsService.java#L43","closed","for: stackoverflow,","AliaksandrAkavity","2022-02-24T23:31:29Z","2022-02-25T10:45:26Z"
"","28327","Can I just upgrade the spring-framwork version to 5.3.18 to avoid the VULNERABILITY  CVE-2022-22965?","Hello, I read the spring webside that: ![image](https://user-images.githubusercontent.com/35129968/162900048-8f9febb3-c30d-4be0-964f-958f03710eb1.png) We can upgrade the srping framework version to fix this VULNERABILITY  CVE-2022-22965, So if I  used spring 5.3.16, spring boot 2.2.10.RELEASE, spring cloud 2.2.10.RELEASE to use spring-cloud-netflix-zuul,  I have to keep the spring boot and spring cloud old versions,  can I just upgrade the spring version to 5.3.18, but don't upgrade other components? https://stackoverflow.com/questions/71836505/can-i-just-upgrade-springframwork-to-5-3-18-to-avoid-cve-2022-22965","closed","for: stackoverflow,","wahahaLI","2022-04-12T07:06:40Z","2022-04-12T07:11:38Z"
"","28586","Using @Async with AspectJ mode not run in an asynchronous thread","Hello, I'm using SpringBoot Starter 2.7.0 and found an issue with the asynchronous call, I also notice a similar issue #20597. I set`@EnableAsync` with AspectJ mode, then I call a method with the `@Async` annotation, but the target method runs in the same thread, not asynchronously.  Here is my sample code  Configuration Class ```java @Configuration @EnableAsync(mode = AdviceMode.ASPECTJ) @EnableAspectJAutoProxy public class AsyncConfiguration {     @Bean     public TaskExecutor getExecutor() {         ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();         executor.setCorePoolSize(5);         executor.setMaxPoolSize(5);         executor.setThreadNamePrefix(""async-thread-"");         return executor;     } } ```  Callee Method ```java @Component public class HelloService {     @Async     public void sayHello() {         System.out.println(""Callee thread : "" + Thread.currentThread().getName());         System.out.println(""hello world"");     }  } ```  Caller Code (run in the main thread) ```java @Component public class Runner implements ApplicationRunner {     @Autowired     private HelloService service;     @Override     public void run(ApplicationArguments args) throws Exception {         System.out.println(""Caller thread : "" + Thread.currentThread().getName());         service.sayHello();     } }  ``` Print Result ``` Caller thread : main Callee thread : main hello world ```  From the result, it seems that the `sayHello` method does not run in an asynchronous thread.  Here is my pom.xml file, in which I have imported the AspectJ weaver lib.  ```xml               org.springframework.boot         spring-boot-starter                   org.springframework.boot         spring-boot-starter-aop                   org.springframework         spring-aspects                   org.aspectj         aspectjrt       ``` I don't know if I use it correctly. Thanks.","closed","for: stackoverflow,","bluelullaby","2022-06-08T16:41:31Z","2022-06-09T10:56:18Z"
"","28651","Alllow @Primary to specify a list of interface/class on which it applies to limit his scope","Hello,  First of all thanks for this magnificent framework.  Now let's get to the point with a sample. Let's say we have 3 interfaces First, Second and Third like below:  ``` public interface First {} public interface Second extends First {} public interface Third extends Second {} ```  And, at least for now, two implementations like below:  ``` @Component @Primary  public class FirstImpl implements First {}  @Component public class SecondImpl implements Second {} ```  Everything is perfect, i can bind both interfaces with their implementations :  ``` public SomeConstructor(First first) {} // OK, it works  public SomeOtherConstructor(Second second) {} // OK, it works  ```  But here comes the Third implementation :   ``` @Component public class ThirdImpl implements Third {} ```  And now the pain that may force us to fall back to qualifiers:  ``` public SomeConstructor(First first) {} // OK, it works  public SomeOtherConstructor(Second second) {} // KO, NoUniqueBeanDefinitionException,Third is a Second public SomeOtherOtherConstructor(Third third) {} // OK, it works ```   To solve this issue i would like to allow @Primary annotation to specify on which class or interface it applies then we could use it as follow:  ``` @Component @Primary  public class FirstImpl implements First {}  @Component @Primary(for = {Second.class}) public class SecondImpl implements Second {}  @Component @Primary(for = {Third.class}) public class ThirdImpl implements Third {} ```  Another use case would be to select primary interfaces on the same bean like:  ``` @Component @Primary(for = {Interface1.class, Interface3.class}) public class SomeImpl implements Interface1,Interface2,Interface3 {} ```  I hope it makes sense for who will read it","open","in: core,","treilhes","2022-06-18T09:30:38Z","2022-06-18T15:30:09Z"
"","28538","Bean definition contribution includes attributes that are not used at…","Hello! This commit fixes issue #28516 by removing mechanism for adding attributes to dynamically compiled beans. I think that attributes in compiled beans are not relevant, so this solution may do the thing. Other solution may be implementing filter to automatically filter attributes with ""PostProcessor"" string in it as they are used internally and don't really contribute in runtime. What do you think?","closed","status: declined,","rilmay","2022-05-29T12:41:43Z","2022-05-29T13:32:55Z"
"","28044","Fix CronExpression fails to calculate next execution on the day of daylight saving time","Hello!  This commit fixes an issue with CronExpression fails to calculate next execution on the day of daylight saving time.  See gh-28038","closed","in: core,","vikeychen","2022-02-12T11:15:35Z","2022-02-18T07:48:58Z"
"","28288","MultiValueMap key is always a String in argument passed to web controller handler method","Hello to everyone.  I am having a problem with `MultiValueMap`.  I am trying to get a `MultiValueMap` map as input of a `GET` request, but Spring gives me a `MultiValueMap` cast to `MultiValueMap` (idk how he does that).   So there is an inconsistency somehow, and every string passed as a parameter is used as key even if it isn't part of `MyEnum`.  For instance, if I try to get the values like `map.get(MyEnum.X)` it returns nothing, while if I do `map.get(MyEnum.X.toString())` it works.  The funny thing here is that `map.get()` wants a value of `MyEnum` and not a String...  In practice, if my enum is `{banana, apple, pear}` and I pass `strawberry=1` as a parameter in the request, the resulting map will be:  ``` {    strawberry; 1 } ```  even if strawberry is not part of the enum.  I fixed this by getting as input `MultiValueMap`, but I decided to report this issue anyway because the fact that an element that is not part of a given enum is used as key value looks suspicious and may lead to errors.","closed","in: web,","Andreus00","2022-04-04T14:14:50Z","2022-04-20T07:19:49Z"
"","28675","DefaultWebFilterChain is called twice by a long http request","Hello everyone,   we have a reactive spring boot application (2.7.0). We have a HTTP POST Request which upload up to 5 GB of data. We are seeing that AuthorizationWebFilter.java is called twice. First call before the request reaches our controller which seems correct, the second call ist just after the request leaves our controller. Which is bad as our oauth token is only 1h and the request can take 1h and 10 minutes to upload. Further debugging showed that DefaultWebFilterChain.java uses:   ``` @Override public Mono filter(ServerWebExchange exchange) {    return Mono.defer(() ->          this.currentFilter != null && this.chain != null ?                invokeFilter(this.currentFilter, this.chain, exchange) :                this.handler.handle(exchange)); } ```  Could it be that we are just executing the filters at the end and this is why we call it twice?     ``` Error has been observed at the following site(s): 	*__checkpoint ⇢ org.springframework.security.web.server.authorization.AuthorizationWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.web.server.authorization.ExceptionTranslationWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.web.server.authentication.logout.LogoutWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.web.server.savedrequest.ServerRequestCacheWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.web.server.context.SecurityContextServerWebExchangeWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.web.server.context.ReactorContextWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.web.server.header.HttpHeaderWriterWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.config.web.server.ServerHttpSecurity$ServerWebExchangeReactorContextWebFilter [DefaultWebFilterChain] 	*__checkpoint ⇢ org.springframework.security.web.server.WebFilterChainProxy [DefaultWebFilterChain] 	*__checkpoint ⇢ HTTP POST \""/api/v1/datasets/3ceebdac-4070-4fc2-a4d4-1d10c679aade/entries?filename=Archive.zip\"" [ExceptionHandlingWebHandler] ```","closed","status: invalid,","jomach","2022-06-22T08:54:54Z","2022-06-22T10:19:56Z"
"","28200","Why required request headers e.g. strings - are not treated as missing if they are blank?","Hello  When I read the below comments I understand that if a header is blank it is treated as missing regardless of thinking of the Key-Value concept.   For example, when we request a string header, even it is a blank string the controller does not respond as a bad request.     ` if the header is missing in the request`, maybe I am assuming for this condition that a blank string does not mean missing header? I wish we could somehow mention that regardless of the value it checks only the presence of the key of the header.  https://github.com/spring-projects/spring-framework/blob/0cbea295178543d515bc4ce80ec152a1f8ddb2bc/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestHeader.java#L63-L71   Disclosure: I am aware of Spring 5.3+, for type conversions it works very well, but in my case is without type conversion. i.e. requesting string header and no type conversion.","closed","","memoricab","2022-03-19T11:03:29Z","2022-05-09T10:25:24Z"
"","28626","Add ResourceHints registrar for classpath patterns","Having to scan locations is quite common. Rather than implementing that logic multiple times, this issue is about offering a basic implementation that can be customized with file names, locations, and file extensions.","closed","theme: aot,","snicoll","2022-06-14T16:10:14Z","2022-06-14T16:19:16Z"
"","28126","Refine runtime hint conditions","GraalVM conditional configuration [is only documented for reflection](https://www.graalvm.org/22.0/reference-manual/native-image/Reflection/#conditional-configuration) but it also applies to serialization, proxy and resources configurations. Since this mechanism allows to leverage GraalVM static analysis to reduce the memory footprint and image size, and for consistency, it would make sense to not only expose this capability in `ReflectionHints`, but also in `JavaSerializationHints`, `ProxyHints` and `ResourceHints`.","closed","theme: aot,","sdeleuze","2022-03-02T16:43:47Z","2022-06-02T09:46:58Z"
"","28115","Introduce AOT generated class proxies","GraalVM `native-image` only supports JDK dynamic proxies when [configured explicitly](https://www.graalvm.org/22.0/reference-manual/native-image/DynamicProxy/) on interfaces.  For proxies on classes, typically created at runtime with CGLIB on the JVM, there is a need to create such proxies Ahead-Of-Time. That's what @aclement did in Spring Native:  - Class proxies are configured by users via [AotProxyHint](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-native/src/main/java/org/springframework/nativex/hint/AotProxyHint.java) (annotation) or [NativeProxyEntry](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-aot/src/main/java/org/springframework/aot/context/bootstrap/generator/infrastructure/nativex/NativeProxyEntry.java) (programmatic) or inferred AOT by [AotProxyNativeConfigurationProcessor](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-aot/src/main/java/org/springframework/boot/context/AotProxyNativeConfigurationProcessor.java)  - [ConfigurationContributor#generateBuildTimeClassProxy](https://github.com/spring-projects-experimental/spring-native/blob/3da5059f3da7e4f26177a94a89366793a0c4a68a/spring-aot/src/main/java/org/springframework/aot/nativex/ConfigurationContributor.java#L176-L214) is generating the configured class proxies using the infrastructure located [here](https://github.com/spring-projects-experimental/spring-native/tree/main/spring-native/src/main/java/org/springframework/aop/framework).  - A [DefaultAopProxyFactory#createAopProxy substitution](https://github.com/spring-projects-experimental/spring-native/blob/main/spring-native/src/main/java/org/springframework/aop/framework/Target_DefaultAopProxyFactory.java) is using the AOT generated class proxy when needed.  Spring Framework 6 should provide similar support for AOT generated class proxies, potentially by:  - Leveraging [ClassProxyHint](https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/aot/hint/ClassProxyHint.java) to configure them  - Deciding how the creation of the proxy should be implemented  - Plug it into the AOT processing  - Implement proper inferring if possible  - Replace the substitution by proper handling in `DefaultAopProxyFactory` and/or other relevant classes","open","theme: aot,","sdeleuze","2022-02-28T18:10:01Z","2022-07-08T15:10:10Z"
"","28841","AOT-generated code does not consider by-type `RuntimeBeanReference`s","Given the following code to register a `BeanDefinition`:  ```java registry.registerBeanDefinition(""my-bean-consumer"", BeanDefinitionBuilder.rootBeanDefinition(BeanConsumer.class) 		.addConstructorArgValue(new RuntimeBeanReference(Bean.class)) 		.getBeanDefinition()); ```  then generating AOT code results in:  ```java Class beanType = BeanConsumer.class; RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType); beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, new RuntimeBeanReference(""com.example.demo.Bean"")); beanDefinition.setInstanceSupplier(InstanceSupplier.of(BeanConsumer__BeanDefinitions::getMybeanconsumerInstance)); ```  The constructor reference value now points to a bean named `com.example.demo.Bean` instead of using the type reference `com.example.demo.Bean`. Running that code leads to:  ``` BeanCreationException: Error creating bean with name 'my-bean-consumer': Cannot resolve reference to bean 'com.example.demo.Bean' while setting constructor argument ```  Additional code used to reproduce the issue:  ```java public class Bean { }  public class BeanConsumer {  	public BeanConsumer(Bean bean) { 	} }  public class ReproducerRegistrar implements ImportBeanDefinitionRegistrar {  	@Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) {  		registry.registerBeanDefinition(""my-bean"", BeanDefinitionBuilder.rootBeanDefinition(Bean.class) 				.getBeanDefinition());  		registry.registerBeanDefinition(""my-bean-consumer"", BeanDefinitionBuilder.rootBeanDefinition(BeanConsumer.class) 				.addConstructorArgValue(new RuntimeBeanReference(Bean.class)) 				.getBeanDefinition());  	} } ```","closed","theme: aot,","mp911de","2022-07-19T06:06:23Z","2022-07-19T16:03:44Z"
"","28153","BeanRegistrationBeanFactoryContribution should expect a RootBeanDefinition","Given the contract of `MergedBeanDefinitionPostProcessor` and the AOT equivalent, we can expect that bean definitions suitable for code generation are `RootBeanDefinition` instances.","closed","type: task,","snicoll","2022-03-10T10:49:43Z","2022-03-10T10:57:36Z"
"","28594","Support that the same RuntimeHintsRegistrar can be specified multiple times and invoked only once","Given the conditional nature of `@ImportRutimeHints`, we should make sure that several classes can defined it with the same processor and that doesn't mean it is invoked multiple times.  The javadoc should be updated accordingly?","closed","theme: aot,","snicoll","2022-06-09T09:17:04Z","2022-06-09T13:03:49Z"
"","28714","Replace java.util.Date and TimeUnit usage in scheduling with appropiate java.time classes","Given that a lot of times we get the values for Triggers and such from configs or other places that use java.time types, and the fact that they're the proper types to model this sort of thing, it would be nice to reduce usage of java.util.Date (since it's so prone to improper handling).","closed","type: enhancement,","desiderantes","2022-06-27T18:50:44Z","2022-07-08T16:59:57Z"
"","28264","注释文件","gg","closed","status: invalid,","lianyiwuming","2022-03-31T12:05:20Z","2022-03-31T12:11:26Z"
"","28196","Index 1 out of bounds for length 1 at abstract transaction aspect","Getting the below error during bean creation for a class annotated with @Transactional, and removing this class level @Transactional annotation resolves the issue.   Spring boot - 2.5.0 spring-framework - 5.3.7    nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cbdTemplateDAO': Invocation of init method failed; nested exception is java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:660) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1413) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:601) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:657) 	... 327 common frames omitted Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cdbnmsdaoimpl': Unsatisfied dependency expressed through field 'cdbSdwanDAO'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cbdSdwanDAO': Unsatisfied dependency expressed through field 'cdbTemplateDAO'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cbdTemplateDAO': Invocation of init method failed; nested exception is java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:660) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1413) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:601) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:657) 	... 341 common frames omitted Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cbdSdwanDAO': Unsatisfied dependency expressed through field 'cdbTemplateDAO'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cbdTemplateDAO': Invocation of init method failed; nested exception is java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:660) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640) 	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1413) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:601) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:657) 	... 355 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cbdTemplateDAO': Invocation of init method failed; nested exception is java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1 	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:160) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1778) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:602) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:524) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1380) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1300) 	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:657) 	... 369 common frames omitted Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1 	at com.versa.vnms.cdbadaptor.cdbdao.CDBTemplateDAO$AjcClosure13.run(CDBTemplateDAO.java:1) 	at org.springframework.transaction.aspectj.AbstractTransactionAspect.ajc$around$org_springframework_transaction_aspectj_AbstractTransactionAspect$1$2a73e96cproceed(AbstractTransactionAspect.aj:67) 	at org.springframework.transaction.aspectj.AbstractTransactionAspect$AbstractTransactionAspect$1.proceedWithInvocation(AbstractTransactionAspect.aj:73) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:388) 	at org.springframework.transaction.aspectj.AbstractTransactionAspect.ajc$around$org_springframework_transaction_aspectj_AbstractTransactionAspect$1$2a73e96c(AbstractTransactionAspect.aj:71) 	at com.versa.vnms.cdbadaptor.cdbdao.CDBTemplateDAO.init(CDBTemplateDAO.java:677) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:389) 	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:333) 	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:157) 	... 381 common frames omitted 	 	 	 Once this fails the complete dependent bean creation graph fails with this nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'cbdTemplateDAO': Invocation of init method failed; nested exception is java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1 **Related cause: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'camelContext': Requested bean is currently in creation: Is there an unresolvable circular reference? Related cause: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'threadPool' defined in class path resource [org/apache/camel/spring/boot/threadpool/CamelThreadPoolAutoConfiguration.class]: Unsatisfied dependency expressed through method 'threadPool' parameter 0; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'camelContext': Requested bean is currently in creation: Is there an unresolvable circular reference?**","closed","for: stackoverflow,","shrijasathya","2022-03-18T11:32:59Z","2022-03-18T12:13:30Z"
"","28513","Getting Internal Error 500 response in Spring 5 when url contains semicolon.","Getting Internal Error 500 response in Spring 5 when url contains semicolon. It was working fine with Spring 3.","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-05-24T08:24:00Z","2022-06-06T12:36:13Z"
"","28461","Use getHost instead of getContainerIpAddress in Redis examples","getContainerIpAddress is deprecated.","closed","type: documentation,","eddumelendez","2022-05-15T00:30:56Z","2022-05-15T13:12:30Z"
"","28757","Introduce StringUtils.trimAllWhitespace(CharSequence)","For use cases where we have a `CharSequence` instead of a `String`, we should introduce `StringUtils.trimAllWhitespace(CharSequence)` alongside the existing `StringUtils.trimAllWhitespace(String)` utility method.  This is an enhancement needed by #28643.","closed","type: enhancement,","sbrannen","2022-07-04T17:24:35Z","2022-07-04T17:37:15Z"
"","28065","Add support for refreshing an ApplicationContext for AOT processing","For us to be able to pre-process an `ApplicationContext` at build-time, we need a way to ""refresh"" it up to a point where it is ready to create bean instances, this includes:  * Prepare the `BeanFactory` * Invoke `BeanDefinitionRegistryPostProcessor` implementations * Invoke `MergedBeanDefinitionPostProcessor` implementations (note that these are special extensions of `BeanPostProcessor` that operates at the (merged) `BeanDefinition` level","closed","theme: aot,","snicoll","2022-02-17T08:15:07Z","2022-03-09T10:19:03Z"
"","28905","Deprecate methods in ContextLoader API in the TestContext framework","For Spring Framework 6.0 we have decided to deprecate the obsolete methods in the `ContextLoader` API in the _Spring TestContext Framework_ in favor of the methods in the `SmartContextLoader` API which has been available since Spring Framework 3.1.","closed","type: enhancement,","sbrannen","2022-08-01T14:59:09Z","2022-08-02T10:09:48Z"
"","27934","Utility classes can be instantiated by its subclasses","For now, there are many utility classes have the flaw that it can be instantiated by its subclasses. I've created a pull request #27933 to fix this issue, but you have closed it, and the reason is not acceptable. I think you should consider it over before make the final decision. Thanks!","closed","status: duplicate,","scruel","2022-01-14T10:41:26Z","2022-01-14T10:48:40Z"
"","28745","Simplify hint registration for Spring AOP proxies","For JDK dynamic proxies created by Spring's AOP support, `SpringProxy`, `Advised`, and `DecoratingProxy` will often be included in the interfaces that the proxy implements.  Here's an example taken from Spring Integration.  ```java proxyHints     .registerJdkProxy(RequestReplyExchanger.class, SpringProxy.class, Advised.class, DecoratingProxy.class)     .registerJdkProxy(AbstractReplyProducingMessageHandler.RequestHandler.class, SpringProxy.class, Advised.class, DecoratingProxy.class)     .registerJdkProxy(IntegrationFlow.class, SmartLifecycle.class, SpringProxy.class, Advised.class, DecoratingProxy.class); ```  We should investigate options for simplifying the proxy hint registration for Spring AOP proxies so that users are not required to specify `SpringProxy`, `Advised`, and `DecoratingProxy`.  One option would be to introduce a new `registerSpringJdkProxy(...)` method (or similar) in `ProxyHints` that automatically registers the required Spring AOP interfaces. Though, it is not always the case that all 3 of those interfaces are implemented by the proxy. So we could document that this particular `registerSpringJdkProxy(...)` variant always registers those 3 particular interfaces to cover common use cases and allow users to continue to use `registerJdkProxy(...)` when the additional Spring AOP interfaces differ from that common set of 3.","closed","theme: aot,","sbrannen","2022-07-02T11:18:52Z","2022-07-11T15:56:15Z"
"","28770","Support @Value on records.","For context see https://github.com/spring-projects/spring-boot/issues/31603  Basically, I want to be able to do this ``` 	@Component 	public record Test(@Value(""${username}"") String user) {} ``` right now that code fails, even tho the bean is created with the right value, because the AutowiredAnnotationBeanPostProcessor attempts to populate the record via field injection (even tho the values have already been set).","open","status: waiting-for-triage,","MiniDigger","2022-07-07T09:43:24Z","2022-07-07T10:00:03Z"
"","28416","Support multiple SpringFactoriesLoader files","For AOT we'd like to be able to load a `META-INF/spring/aot.factories` files rather than `META-INF/spring.factories`.","closed","type: enhancement,","philwebb","2022-05-05T06:18:07Z","2022-05-05T20:35:47Z"
"","28542","Fix typo in webflux.adoc","follwing -> following","closed","type: documentation,","eltociear","2022-05-31T05:24:17Z","2022-05-31T08:02:43Z"
"","28438","Update documentation for RFC 7807 support","Following the changes for #27052 and sub-tasks, we need an update in the reference documentation. In the mean time, the best alternative is the commit history for #27052 and sub-tasks, the Javadoc  on the added types, and the [sample project](https://github.com/rstoyanchev/sandbox-rfc7807).","closed","in: web,","rstoyanchev","2022-05-10T11:36:41Z","2022-07-13T12:12:28Z"
"","28753","Fix WebClientAdapter.createHttpServiceProxyFactory() example in ref docs","Following the changes applied to `HttpServiceProxyFactory` and `WebClientAdapter` in 48c1746 and b72ee5f, this PR applies fixes into HTTP Interface snippet in order to correctly initialize the client.","closed","in: web,","LucasManto","2022-07-03T20:08:56Z","2022-07-04T17:48:08Z"
"","28623","Add reflection hints for data binding in Web controllers","Follow-up of #28518.","closed","theme: aot,","sdeleuze","2022-06-14T13:40:00Z","2022-07-11T09:44:49Z"
"","28622","Add reflection hints for `HttpEntity` used in Web controllers","Follow-up of #28518.","closed","theme: aot,","sdeleuze","2022-06-14T13:37:40Z","2022-06-20T16:16:25Z"
"","28165","Harmonize invocation of init & destroy methods","Follow-up of #28151 and #28013. `InitDestroyAnnotationBeanPostProcessor` is now doing two different things, depending in which mode it runs.  With the regular runtime, a bean is scanned and its init & destroy methods are identified and registered in the bean definition as ""externally managed"". That means that the core container should not invoke them if they happen to be registered on the bean definition itself. When the post-processor runs, it invokes them.  With AOT, the first bit is done (as part of the `MergedBeanDefinitionPostProcessor` callback), and then we register the same methods on the bean definition but as ""regular methods"" this time, merging with the ones that would have been registered already. AOT does not contribute `InitDestroyAnnotationBeanPostProcessor` so it does not run and the core container invokes all the init/destroy methods.  While it wasn't possible to register multiple methods before #28013, we now have the capability to make sure the post-processor is invoking those methods consistently. One caveat is that the post processor keeps `Method` reference whereas the core container contains method names, assuming they're no arg methods. Another slightly weird behavior is that the `contribute` part of `InitDestroyAnnotationBeanPostProcessor` mutates the given `RootBeanDefinition` and returns a `null` contribution (as no code is really required since it instuments a regular feature of the bean definition).  This issue is about researching how we could make sure both processing are using the same path, ideally so that `InitDestroyAnnotationBeanPostProcessor` does not have to do anything AOT-related since invoking init & destroy methods is a core feature of the core container.","open","theme: aot,","snicoll","2022-03-11T15:50:45Z","2022-07-13T07:43:17Z"
"","28836","Avoid IllegalArgumentException when setting WebSocket error status","Fixing internal error, when the message of an exception doesn't contain any text.  In my application, this probably caused a memory leak. (Which I will retest with a fork, but it will take some time because the issue happened very infrequently)  This is how it looks in the log: ``` java.lang.IllegalArgumentException: Reason must not be empty 	at org.springframework.util.Assert.hasText(Assert.java:289) ~[spring-core-5.3.21.jar!/:5.3.21] 	at org.springframework.web.reactive.socket.CloseStatus.withReason(CloseStatus.java:184) ~[spring-webflux-5.3.21.jar!/:5.3.21] 	at org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.onError(AbstractListenerWebSocketSession.java:250) ~[spring-webflux-5.3.21.jar!/:5.3.21] 	at reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxDoFinally$DoFinallySubscriber.onError(FluxDoFinally.java:119) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:192) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:259) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onError(MonoIgnoreElements.java:84) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.checkTerminated(FluxFlatMap.java:842) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drainLoop(FluxFlatMap.java:608) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.drain(FluxFlatMap.java:588) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.innerError(FluxFlatMap.java:863) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxFlatMap$FlatMapInner.onError(FluxFlatMap.java:990) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onError(FluxPeekFuseable.java:903) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoSubscribeOn$SubscribeOnSubscriber.onError(MonoSubscribeOn.java:152) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.SinkEmptyMulticast$VoidInner.error(SinkEmptyMulticast.java:247) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.SinkEmptyMulticast.tryEmitError(SinkEmptyMulticast.java:88) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.SinkEmptySerialized.tryEmitError(SinkEmptySerialized.java:65) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.onError(AbstractListenerWebSocketSession.java:245) ~[spring-webflux-5.3.21.jar!/:5.3.21] 	at reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onError(MonoPeekTerminal.java:258) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoNext$NextSubscriber.onError(MonoNext.java:93) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at reactor.core.publisher.MonoNext$NextSubscriber.onError(MonoNext.java:93) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at org.springframework.http.server.reactive.WriteResultPublisher$State.publishError(WriteResultPublisher.java:277) ~[spring-web-5.3.21.jar!/:5.3.21] 	at org.springframework.http.server.reactive.WriteResultPublisher.publishError(WriteResultPublisher.java:99) ~[spring-web-5.3.21.jar!/:5.3.21] 	at org.springframework.http.server.reactive.AbstractListenerWriteProcessor$State.onError(AbstractListenerWriteProcessor.java:479) ~[spring-web-5.3.21.jar!/:5.3.21] 	at org.springframework.http.server.reactive.AbstractListenerWriteProcessor.onError(AbstractListenerWriteProcessor.java:132) ~[spring-web-5.3.21.jar!/:5.3.21] 	at reactor.core.publisher.StrictSubscriber.onError(StrictSubscriber.java:106) ~[reactor-core-3.4.19.jar!/:3.4.19] 	at org.springframework.http.server.reactive.AbstractListenerReadPublisher$State.onError(AbstractListenerReadPublisher.java:497) ~[spring-web-5.3.21.jar!/:5.3.21] 	at org.springframework.http.server.reactive.AbstractListenerReadPublisher.onError(AbstractListenerReadPublisher.java:145) ~[spring-web-5.3.21.jar!/:5.3.21] 	at org.springframework.web.reactive.socket.adapter.AbstractListenerWebSocketSession.handleError(AbstractListenerWebSocketSession.java:208) ~[spring-webflux-5.3.21.jar!/:5.3.21] 	at org.springframework.web.reactive.socket.adapter.StandardWebSocketHandlerAdapter.onError(StandardWebSocketHandlerAdapter.java:120) ~[spring-webflux-5.3.21.jar!/:5.3.21] 	at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.onError(WsHttpUpgradeHandler.java:234) ~[tomcat-embed-websocket-9.0.64.jar!/:na] 	at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler.upgradeDispatch(WsHttpUpgradeHandler.java:161) ~[tomcat-embed-websocket-9.0.64.jar!/:na] 	at org.apache.coyote.http11.upgrade.UpgradeProcessorInternal.dispatch(UpgradeProcessorInternal.java:60) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:59) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:890) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1787) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.64.jar!/:na] 	at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na] ```","closed","type: bug,","FlorianKirmaier","2022-07-18T14:56:03Z","2022-07-29T13:24:00Z"
"","28807","Fix typos in test code","Fixes typos in test class names, test method names and test variable names.","closed","type: task,","marcwrobel","2022-07-12T18:26:50Z","2022-07-14T11:19:58Z"
"","27986","Ignore identical BeanDefinition registration when allowBeanDefinitionOverriding is false","Fixes #27978","open","type: enhancement,","rilmay","2022-01-28T21:38:11Z","2022-02-19T02:05:02Z"
"","28520","Fix Javadoc for DatabaseClient","Fixed a misplaced double quote in the documentation for `DatabaseClient` in the example on how to map a `select` statement to a `Row`.","closed","type: documentation,","hsteinmueller","2022-05-24T14:12:41Z","2022-05-24T15:18:22Z"
"","28783","Reduce synchronization scope in AbstractAspectJAdvice#calculateArgumentBindings","fix synchronized problem, issues #26377","closed","type: enhancement,","jeooica","2022-07-11T08:00:51Z","2022-07-13T13:49:43Z"
"","28426","Polish Javadoc and inline comments","Fix some typos and polish trivial stuff.","closed","type: task,","yuhangbin","2022-05-08T15:27:47Z","2022-05-09T18:26:33Z"
"","28316","Fix issues 28298, findAnnotationOnBean finds annotations from a static @Bean method's enclosing class","Fix issue https://github.com/spring-projects/spring-framework/issues/28298  Please review my first PR, thx very much.","closed","status: declined,","284831721","2022-04-10T15:46:08Z","2022-06-25T07:20:44Z"
"","28653","issues-28645","fix https://github.com/spring-projects/spring-framework/issues/28645","closed","in: core,","huifer","2022-06-18T12:27:32Z","2022-06-18T15:18:26Z"
"","28652","issues-28645","fix https://github.com/spring-projects/spring-framework/issues/28645","closed","in: core,","huifer","2022-06-18T12:26:36Z","2022-06-18T15:14:19Z"
"","28616","Avoid eager instantiation of non-singleton FactoryBean in getBeanNamesForType","Fix for #28615","closed","in: core,","fsgonz","2022-06-13T22:07:31Z","2022-06-14T15:15:03Z"
"","28677","Fix DataSourceUtils inconsistent exception handling","Fix DataSourceUtils inconsistent exception handling   CannotGetJdbcConnectionException can take SQLException as well as IllegalStateException as cause.The public facing Exception remains unchanged in either way. This Pull Request is a continuation of the pull request https://github.com/spring-projects/spring-framework/pull/28669  Closes gh-28258","closed","status: declined,","Suthman","2022-06-22T11:42:04Z","2022-06-23T07:03:09Z"
"","27984","Fix ServletUriComponentsBuilder examples in ref docs","Fix `ServletUriComponentsBuilder` examples in reference docs.  Fixed two problems.  - Type mismatch - Comments are inaccurate  before  ```java // Re-uses host, port and context path...  ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)         .path(""/accounts"").build() ```   after  ```java // Re-uses host, port, scheme and context path...  URI uri = ServletUriComponentsBuilder.fromContextPath(request)         .path(""/accounts"")         .build()         .toUri(); ```","closed","in: web,","wkwkhautbois","2022-01-28T14:23:46Z","2022-01-28T15:19:11Z"
"","28382","Direct Buffer not freed and Netty Resource Leaks","First of all: I'm not sure if this is 100% the right place for this Issue as Netty, Reactor-Netty and Spring-Data mongodb are also involved.  After updating our Spring-Webflux app to 2.6.6 we encountered ""java.lang.OutOfMemoryError Direct buffer memory"" exceptions in our logs.   ~~After some investigation I found out that the netty update to 4.1.75/4.1.76 might cause the problem.~~  When netty leak detection is set to _paranoid_ we see the following leak report in our logs:  ``` LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information. Recent access records:  #1:         io.netty.buffer.AdvancedLeakAwareByteBuf.writeBytes(AdvancedLeakAwareByteBuf.java:611)         org.springframework.core.io.buffer.NettyDataBuffer.write(NettyDataBuffer.java:177)         org.springframework.core.io.buffer.NettyDataBuffer.write(NettyDataBuffer.java:43)         org.springframework.http.codec.json.AbstractJackson2Encoder.encodeStreamingValue(AbstractJackson2Encoder.java:286)         org.springframework.http.codec.json.AbstractJackson2Encoder.lambda$encode$1(AbstractJackson2Encoder.java:168)         reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) ... ``` [(complete one attached as file)](https://github.com/spring-projects/spring-framework/files/8562543/leak-log.txt)  The use case behind is: Streaming pretty large data as json (~70kb per json) from mongodb to the client using a spring-webflux application.  Before the update to Spring-Boot 2.6.6. (and the including netty update) the leak was also present in the logs but did not make any problems so far. When starting the app on Java 11 it also seems that the buffer is cleaned fine (probably by GC) - but using Java 17 we always see the  ""java.lang.OutOfMemoryError Direct buffer memory"" exceptions.  Our App runs on Cloudfoundry with MaxDirectMemorySize set to 80M which before the update was always enough. Increasins the MaxDirectMemorySize just delays the overflow exceptions.  ### Example to Reproduce the Issue:  [Here you find a small minimal example but is enough to reproduce the issue: webflux-buffer-overflow-demo](https://github.com/mgmeiner/webflux-buffer-overflow-demo)  Look at the readme of the repository for prerequisites and launch instructions.  For watching the direct buffer pools i used JVisualVM with the Buffer Pools plugins installed.","open","status: waiting-for-triage,","mgmeiner","2022-04-26T11:29:29Z","2022-04-28T07:35:45Z"
"","28629","kotlin Is there Get a nullable bean by coding","example:  ``` kotlin val bean = applicationContext.getBean()  // or val bean = applicationContext.getBeanOrNull() ```","closed","in: kotlin,","SchroedingersGitHub","2022-06-15T04:44:58Z","2022-06-15T08:23:18Z"
"","28734","kotlin @ComponentScan annotation cannot scanning ApplicationEventPublisherAware implementation","example: https://github.com/SchroedingersGitHub/Example-ApplicationEventPublisherAware/tree/main","closed","in: kotlin,","SchroedingersGitHub","2022-06-30T09:21:42Z","2022-06-30T17:37:20Z"
"","28764","Status and headers already sent","env: k8s Spring-Boot Version:2.6.3 Spring-cloud:3.1.0 java:11 webflux  it see like to set cookie when appear this error:  The example provides an interface request, which can be reproduced 100% as long as the request with a cookie   sample project: [SampleProject.zip](https://github.com/spring-projects/spring-framework/files/9099459/SampleProject.zip)   Error finishing response. Closing connection ``` java.lang.IllegalStateException: Status and headers already sent 	at reactor.netty.http.server.HttpServerOperations.addHeader(HttpServerOperations.java:243) 	at org.springframework.http.server.reactive.ReactorServerHttpResponse.applyCookies(ReactorServerHttpResponse.java:110) 	at org.springframework.http.server.reactive.AbstractServerHttpResponse.lambda$doCommit$14(AbstractServerHttpResponse.java:292) 	at reactor.core.publisher.MonoRunnable.subscribe(MonoRunnable.java:49) 	at reactor.core.publisher.Mono.subscribe(Mono.java:4400) 	at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:258) 	at reactor.core.publisher.FluxConcatArray.subscribe(FluxConcatArray.java:78) 	at reactor.core.publisher.MonoFromFluxOperator.subscribe(MonoFromFluxOperator.java:81) 	at reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:236) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:299) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260) 	at reactor.core.publisher.FluxDoOnEach$DoOnEachSubscriber.onComplete(FluxDoOnEach.java:223) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at org.springframework.cloud.sleuth.instrument.web.TraceWebFilter$MonoWebFilterTrace$WebFilterTraceSubscriber.onComplete(TraceWebFilter.java:281) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onComplete(FluxContextWrite.java:126) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onComplete(FluxContextWrite.java:126) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:181) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:85) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:234) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:181) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:85) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:234) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:181) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:181) 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:85) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:234) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:85) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at com.alibaba.csp.sentinel.adapter.reactor.SentinelReactorSubscriber.hookOnComplete(SentinelReactorSubscriber.java:136) 	at com.alibaba.csp.sentinel.adapter.reactor.InheritableBaseSubscriber.onComplete(InheritableBaseSubscriber.java:191) 	at com.alibaba.csp.sentinel.adapter.reactor.SentinelReactorSubscriber.onComplete(SentinelReactorSubscriber.java:37) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onComplete(MonoFlatMap.java:181) 	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142) 	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:85) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:209) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:234) 	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:203) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onComplete(Operators.java:2058) 	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onComplete(FluxContextWrite.java:126) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onComplete(FluxContextWrite.java:126) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:299) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onComplete(FluxPeekFuseable.java:277) 	at reactor.core.publisher.MonoPeekTerminal$MonoTerminalPeekSubscriber.onComplete(MonoPeekTerminal.java:299) 	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89) 	at reactor.core.publisher.FluxConcatArray$ConcatArraySubscriber.onComplete(FluxConcatArray.java:230) 	at org.springframework.cloud.sleuth.instrument.reactor.ScopePassingSpanSubscriber.onComplete(ScopePassingSpanSubscriber.java:103) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onComplete(FluxContextWrite.java:126) 	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondComplete(MonoFlatMap.java:196) 	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onComplete(MonoFlatMap.java:268) 	at reactor.netty.FutureMono$FutureSubscription.operationComplete(FutureMono.java:196) 	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:578) 	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:571) 	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:550) 	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:491) 	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:616) 	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:605) 	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104) 	at io.netty.util.internal.PromiseNotificationUtil.trySuccess(PromiseNotificationUtil.java:48) 	at io.netty.channel.ChannelOutboundBuffer.safeSuccess(ChannelOutboundBuffer.java:717) 	at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:272) 	at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:352) 	at io.netty.channel.epoll.AbstractEpollChannel.doWriteBytes(AbstractEpollChannel.java:364) 	at io.netty.channel.epoll.AbstractEpollStreamChannel.writeBytes(AbstractEpollStreamChannel.java:260) 	at io.netty.channel.epoll.AbstractEpollStreamChannel.doWriteSingle(AbstractEpollStreamChannel.java:471) 	at io.netty.channel.epoll.AbstractEpollStreamChannel.doWrite(AbstractEpollStreamChannel.java:429) 	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:931) 	at io.netty.channel.epoll.AbstractEpollChannel$AbstractEpollUnsafe.flush0(AbstractEpollChannel.java:557) 	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:895) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1372) 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:750) 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:742) 	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:728) 	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.flush(CombinedChannelDuplexHandler.java:531) 	at io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:125) 	at io.netty.channel.CombinedChannelDuplexHandler.flush(CombinedChannelDuplexHandler.java:356) 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:750) 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:742) 	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:728) 	at io.netty.channel.ChannelDuplexHandler.flush(ChannelDuplexHandler.java:127) 	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:750) 	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:765) 	at io.netty.channel.AbstractChannelHandlerContext$WriteTask.run(AbstractChannelHandlerContext.java:1071) 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469) 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:829)  ```","closed","status: feedback-provided,","fanpocha","2022-07-06T09:53:01Z","2022-07-15T08:30:33Z"
"","27938","Error validating an empty String org.springframework.util.StringUtils","During the development of a feature for the company I work for, I saw the need to validate if a String was empty. The idea was to receive a String expression ""cron"". When using the method ""hasLength (@Nullable String str)"" in org.springframework.util.StringUtils (spring-core-5.3.14), I identified that it validates as true even if you pass as an argument something like ""          "". This is because in the str.isEmpty() return, ""trim()"" is not applied to remove the space and after that, check if in fact the String passed is empty. My suggestion would be to replace the ""!str.isEmpty()"" check with ""!str.trim().isEmpty()"". Thank you all the team for your attention and for the beautiful work with Spring !!!  ![image](https://user-images.githubusercontent.com/49285474/149659036-65e5c732-914b-4739-8aed-e89788aba59b.png)  ![image](https://user-images.githubusercontent.com/49285474/149659100-e40b1eb2-76c1-4043-9b05-59a51634a079.png)","closed","in: core,","vtspp","2022-01-16T12:02:46Z","2022-01-17T07:37:50Z"
"","28007","HibernateJpaDialect compatibility with Hibernate 6 (read-only transactions etc)","During our work to investigate the compatibility with Hibernate 6 in Spring Data JPA we ran into an issue surfacing in Spring Frameworks transaction management:  In `….beginTransaction(…)`, `HibernateJpaDialect` calls `SessionImplementor.connection()` a method that has been removed in CR1 (could've been in one of the betas already, I didn't check) to issue read-only transactions. It looks like the new way to access the `Connection` is calling `….getJdbcConnectionAccess().obtainConnection()`.  Related tickets: * spring-projects/spring-data-jpa#2423","closed","type: enhancement,","odrotbohm","2022-02-04T10:32:18Z","2022-02-08T13:31:34Z"
"","28359","Generic cannot be injected through @Resource","During object injection, the type of pair is generic, @Autowired can inject normally, but @Resource cannot inject normally?  > @Resource : ``` public class ServiceImpl {      @Resource     private R repository;     ......... } ```  > **Error Info：** > nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type '?' available: expected single matching bean but found 3:  .........  > @Autowired  ``` public class ServiceImpl {     @Autowired     private R repository;     ......... } ```  This is true.   My Spring Boot version：2.6.6","closed","for: stackoverflow,","my420840806","2022-04-20T08:58:47Z","2022-04-21T10:16:58Z"
"","28194","Return UnmodifiableMap in PathVariableMapMethodArgumentResolver","Duplicated pr","closed","status: duplicate,","dugenkui03","2022-03-17T15:40:19Z","2022-04-16T15:22:01Z"
"","28350","Make `BeanThatListens`, `TestApplicationListener`, `ResourceUrlProvider` threadsafe","Duplicate pr","closed","status: waiting-for-triage,","dugenkui03","2022-04-16T10:30:49Z","2022-04-16T13:41:46Z"
"","28144","Replace KotlinBodySpec with proper ResponseSpec extensions","Due to #20606, we had to introduce `KotlinBodySpec` in Spring Framework 5.0.x in order to unlock Kotlin developers for most common use cases of `WebTestClient` in Kotlin.  [As of Kotlin 1.6, the related Kotlin issue on recursive generic types has been fixed](https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/#improved-type-inference-for-recursive-generic-types), making it possible for Spring Framework to provide regular reified extensions for `ResponseSpec` methods that takes a `ParameterizedTypeReference` (to be verified of course, but that's my current understanding).  As a consequence, my proposal is in Spring Framework 6 to remove `KotlinBodySpec`, as well as the current `inline fun  ResponseSpec.expectBody(): KotlinBodySpec` extension, and introduce regular reified extensions for `ResponseSpec.expectBody` since `ResponseSpec.expectBodyList`, `ResponseSpec.returnResult` extensions already exists.  This is a breaking change, I am afraid impossible to avoid, so it should be mentioned in the release notes. I am not sure we should deprecate the related extension in Spring Framework 5.3 since we need to support Kotlin 1.5 there and the current extension prevent to introduce the new proper one describe in this issue.","closed","in: kotlin,","sdeleuze","2022-03-08T10:25:23Z","2022-03-16T08:49:41Z"
"","28340","Fix method reference in Kotlin documentation","Documentation was probably copied from the `getBeansOfType` method, but not correctly altered.","closed","type: documentation,","koenpunt","2022-04-14T11:31:32Z","2022-04-14T12:16:27Z"
"","28884","Allow @Qualifier to enjoy the same level of support of @Resource for resolving properties placeholder","Didn't know that `@Qualifier` annotation didn't support the properties placeholder, which `@Resource` support it out of the box.  Any reason behind it that `@Qualifier` don't enjoy the same treatment?  ``` Parameter 0 of constructor in com.welcome.samples.patterns.strategy.startup.BeanNameBasedEnrichmentController required a bean of type 'com.welcome.samples.patterns.strategy.PayloadEnricher' that could not be found.  The injection point has the following annotations: 	- @org.springframework.beans.factory.annotation.Qualifier(""${com.welcome.samples.strategy.payload.enricher.bean}"")  The following candidates were found but could not be injected: 	- User-defined bean method 'swimInGmailEnricher' in 'NamedBeanEnrichment' 	- User-defined bean method 'runInIcloudEnricher' in 'NamedBeanEnrichment'   Action:  Consider revisiting the entries above or defining a bean of type 'com.welcome.samples.patterns.strategy.PayloadEnricher' in your configuration. ```  As above, change to use `@Resource` solve the problem, but constructor argument is not supported by `@Resource`. And this making some friction in unit testing","closed","status: duplicate,","tombyong","2022-07-29T04:49:36Z","2022-07-29T07:44:01Z"
"","28427","Use Arrays.toString for initMethodNames and destroyMethodNames arrays in AbstractBeanDefinition#toString","Default array `toString` implementation will not produce a readable result, `Arrays.toString` should be used instead","closed","in: core,","missingdays","2022-05-08T17:10:49Z","2022-05-09T08:19:04Z"
"","28716","Regression in resolving merged annotation attributes in multi-level annotation hierarchy","d6768ccc1852f4720781d490e13529e0283d9d63 seems to have introduced a regression when resolving merged annotation values.  The tests below pass for `6.0.0-M4` but fail with recent `snapshot` build.  ```java @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE }) @interface RootAnnotation { 	String value() default """"; 	boolean boolVal() default false; }  @RootAnnotation @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.FIELD, ElementType.ANNOTATION_TYPE }) @interface CustomMetaAnnotation {  	@AliasFor(annotation = RootAnnotation.class, attribute = ""boolVal"") 	boolean enabled() default true; }  @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.FIELD }) @CustomMetaAnnotation @interface CustomAnnotationWith2TimesMeta {  }  class DomainType {  	@CustomMetaAnnotation 	Object metaAnnotated;  	@CustomAnnotationWith2TimesMeta 	Object meta2timesAnnotated; }  @Test public void reproducer() {  	java.lang.reflect.Field metaAnnotated = ReflectionUtils.findField(DomainType.class, ""metaAnnotated""); 	RootAnnotation mergedAnnotation1 = AnnotatedElementUtils.findMergedAnnotation(metaAnnotated, RootAnnotation.class); 	assertThat(mergedAnnotation1.boolVal()).isTrue();  	java.lang.reflect.Field meta2timesAnnotated = ReflectionUtils.findField(DomainType.class, ""meta2timesAnnotated""); 	RootAnnotation mergedAnnotation2 = AnnotatedElementUtils.findMergedAnnotation(meta2timesAnnotated, RootAnnotation.class); 	assertThat(mergedAnnotation2.boolVal()).isTrue(); } ```","closed","in: core,","christophstrobl","2022-06-28T08:20:32Z","2022-07-02T14:58:14Z"
"","28319","CVE-2010-1622漏洞在高版本jdk上的绕过。在JDK 9及以上的版本中，新增的module属性可以被利用从而绕过了之前CVE-2010-1622漏洞的修复逻辑。","CVE-2010-1622漏洞在高版本jdk上的绕过。在JDK 9及以上的版本中，新增的module属性可以被利用从而绕过了之前CVE-2010-1622漏洞的修复逻辑。","closed","status: invalid,","1290708840","2022-04-11T06:52:42Z","2022-04-11T07:28:53Z"
"","27974","After upgrading to Spring Boot 2.6.3, queries with @Lock or  fail","Currently, we are using Spring Boot **2.5.9**.  After upgrading to **2.6.3** the Queries start to fail with the following error.  If we remove the `@Lock` annotation or `lock-mode` tag from `orm.xml` file, the error disappears.    ``` Caused by: javax.persistence.TransactionRequiredException: no transaction is in progress 	at org.hibernate.query.internal.AbstractProducedQuery.doList(AbstractProducedQuery.java:1644) 	at org.hibernate.query.internal.AbstractProducedQuery.list(AbstractProducedQuery.java:1617) 	at org.hibernate.query.Query.getResultList(Query.java:165) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.springframework.orm.jpa.SharedEntityManagerCreator$DeferredQueryInvocationHandler.invoke(SharedEntityManagerCreator.java:406) 	at com.sun.proxy.$Proxy169.getResultList(Unknown Source) 	at org.springframework.data.jpa.repository.query.JpaQueryExecution$CollectionExecution.doExecute(JpaQueryExecution.java:128) 	at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:90) 	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:155) 	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:143) 	at org.springframework.data.repository.core.support.RepositoryMethodInvoker.doInvoke(RepositoryMethodInvoker.java:137) 	at org.springframework.data.repository.core.support.RepositoryMethodInvoker.invoke(RepositoryMethodInvoker.java:121) 	at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.doInvoke(QueryExecutorMethodInterceptor.java:159) 	at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.invoke(QueryExecutorMethodInterceptor.java:138) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:80) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:388) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137) ```","open","status: feedback-provided,","kp185128","2022-01-25T10:09:21Z","2022-02-17T08:58:48Z"
"","28880","Instrument MVC and WebFlux for Observability","Currently, Spring MVC and WebFlux applications are instrumented wit Micrometer metrics in Spring Boot, thanks to `org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter` and `org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter`. Those filters are then auto-configured by Spring Boot and their metrics exported with the metrics system.  While those are timing request handling properly, the extraction of metadata can be complex since it requires inner knowledge of the web framework and is sometimes limited because it would need direct access to the request handling.  With the introduction of `Observation` in Micrometer 1.10, Spring Framework is now instrumenting directly some of its features. This issue aims at instrumenting the MVC and WebFlux web frameworks for the `""http.server.requests""` observation.","open","theme: observability,","bclozel","2022-07-27T14:37:46Z","2022-07-27T14:37:46Z"
"","28082","Let the DispatcherServlet get the HandlerMapping in advance","Currently, ``DispatcherServlet#initHandlerMappings`` is initialized in ``org.springframework.web.servlet.HttpServletBean#init``, But it is already executed in the servlet thread ``http-nio-8081-exec-1``，I hope it can be executed in advance to play the role of preloading，In this way, I can also get ``HandlerMapping`` earlier through ``DispatcherServlet#getHandlerMappings``  for example：DispatcherServlet can impl SmartInitializingSingleton and invoke ``DispatcherServlet#initHandlerMappings`` in method ``SmartInitializingSingleton#afterSingletonsInstantiated``  ![image](https://user-images.githubusercontent.com/13413715/154843456-4f0805d6-36ec-4c34-b120-3119719d5381.png)","closed","status: invalid,","brucelwl","2022-02-20T12:53:45Z","2022-04-27T13:25:54Z"
"","28737","spring-flex 1.0.3.RELEASE issue with spring 5.3.20","Currently using spring-flex 1.0.0.M2, As part of spring upgrade to 5.3.20, upgraded spring-flex to 1.5.2.RELEASE.  I'm getting the following error:  ``` ERROR [org.springframework.web.servlet.DispatcherServlet] [localhost-startStop-1] Context initialization failed - org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Unable to locate Spring NamespaceHandler for XML schema namespace [http://www.springframework.org/schema/flex] Offending resource: ServletContext resource [/WEB-INF/applicationContext-flex.xml] ``` I added the dependency on `pom.xml`, still getting the same error.  I see spring-flex-1.5.2.RELEASE does not have jar. It only has pom file. So, I changed the version to spring-flex-1.0.3.RELEASE, which has the jar and I am getting the below error:  ``` ERROR [org.springframework.web.servlet.DispatcherServlet] [localhost-startStop-1] Context initialization failed - org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from ServletContext resource [/WEB-INF/applicationContext-flex.xml]; nested exception is org.springframework.beans.FatalBeanException: Unresolvable class definition for NamespaceHandler class [org.springframework.flex.config.xml.FlexNamespaceHandler] for namespace [http://www.springframework.org/schema/flex]; nested exception is java.lang.NoSuchMethodError: org.springframework.util.ClassUtils.forName(Ljava/lang/String;)Ljava/lang/Class; ``` One of the classes in the spring-flex-1.0.3.RELEASE jar is referring to ClassUtils class which is present in spring 3.  I want to know what is the compatible spring-flex version for spring 5 or I need to resolve the above error.  Any help would be appreciated.","closed","status: invalid,","kawinprabhakaran","2022-06-30T11:57:17Z","2022-06-30T12:43:19Z"
"","28305","Mariadb needs to be treated as an independent db type.","Currently Spring Framework treats mariadb as a version of MySql. It needs to treat mariadb as its own type. I found this while working an identical issue in Spring Cloud Task.","closed","status: superseded,","ben-enfuse-io","2022-04-07T20:42:48Z","2022-07-29T15:55:20Z"
"","28557","Allow BeanRegistrationAotContributions to provide BeanRegistrationCodeFragments customization","Currently only `BeanRegistrationCodeFragmentsCustomizer` can be used to customize `BeanRegistrationCodeFragments` but for parent/child context support we'd like to be able to apply customization directly from a `BeanRegistrationAotContribution`.  Making such a change should also allow us to from the `BeanRegistrationCodeFragmentsCustomizer` entirely since the same functionality could be achieved using the existing `BeanRegistrationAotProcessor` interface.","closed","theme: aot,","philwebb","2022-06-03T00:30:35Z","2022-06-03T01:09:20Z"
"","27916","Make it easier to set the the default transaction timeout","Currently it is, somewhat, hard to set the default transaction timeout in Spring. It requires the configuration of a `PlatformTransactionManager` and calling the `setDefaultTimeout`. Now in a regular Spring application this might not be so much of an issue, however when using Spring Boot this might lead to unwanted bean declarations (and auto configuration to back off).   Ofcourse one could utilize a `BeanPostProcessor` to configure this property after the bean has been created but it would be nice if support was added for this in the framework.   One solution I could think of is extending the `@EnableTransactionManagement` with a `defaultTimeout` property and apply this to the configured `PlatformTransactionManager`.","open","type: enhancement,","mdeinum","2022-01-11T09:55:32Z","2022-06-22T14:44:48Z"
"","28190","Enable access to an RFC 7807 ProblemDetail formatted error response from the client side","Currently `WebClientResponseException` exposes the body as a `byte[]` or `String` and so does `RestClientResponseException`. It would be useful if these exposed convenience methods to decode an RFC 7807 formatted response to `ProblemDetail`.   The exceptions could be created with a `Callable` or similar to decouple them from the details of decoding, or perhaps the decoding could be done automatically for such a response and the ProblemDetail passed in to the exception.","closed","type: enhancement,","rstoyanchev","2022-03-16T18:36:33Z","2022-05-10T10:49:42Z"
"","28415","Add position variant of ObjectUtils.addObjectToArray","Currently `ObjectUtils.addObjectToArray` only allows you to add an element to the end of the array. With #28414 we need to add an element to the start.","closed","type: enhancement,","philwebb","2022-05-05T06:15:20Z","2022-05-05T20:35:47Z"
"","28505","Refactor HttpServiceProxyFactory to be suitable as an infrastructure bean","Currently `HttpServiceProxyFactory` is friendly for programmatic use but is more likely to be declared as a bean since it needs a number of dependencies injected such as as a `ConversionService`, and an `EmbeddedValueResolver` as of #28492. In a Boot application one would also inject `WebClient.Builder`.","closed","type: enhancement,","rstoyanchev","2022-05-23T15:30:33Z","2022-05-24T08:28:41Z"
"","28722","HtmlUnit / MockMvc integration handles forwarded URLs partially","Currently `ForwardRequestPostProcessor` uses the forwarded URL only to set the servletPath of the mock request, which means `requestUri` and `servletPath` are out of sync.  This hasn't been reported as an issue since `UrlPathHelper` falls back on the `servletPath` if it doesn't match the `requestURI` but that's not really correct behavior, and causes issues in more modern setups like parsed patterns where we rely mainly on the `requestURI` and only check the `servletPath` if a Servlet prefix mapping can be confirmed with Servlet 4.0.   In the absence of a Servlet container, i.e. with mock request and response, there is actually no good way to take a `forwardedUrl` and break it down into `contextPath`, `servletPath`, and `pathInfo`. At best, we can assert that the forwarded URL does start with the same `contextPath`, but otherwise break it down into `contextPath` + `servletPath`.  This was uncovered while working on #28607.","closed","type: bug,","rstoyanchev","2022-06-28T15:52:00Z","2022-06-29T09:18:40Z"
"","28526","Filtering of BeanRegistrationAotProcessor beans should be optional","Currently `BeanDefinitionMethodGeneratorFactory.isImplicitlyExcluded` always filters beans that implement `BeanRegistrationAotProcessor`. For Spring Boot, we think we'll need to have bean that implements `BeanRegistrationAotProcessor` but isn't filtered.","closed","theme: aot,","philwebb","2022-05-25T22:22:29Z","2022-07-18T11:46:26Z"
"","28293","Optimize cache used in AutowiredAnnotationBeanPostProcessor","Currently `AutowiredAnnotationBeanPostProcessor` has a few caches that aren't providing that much in a typical application. They're also no cleared once a context has been refreshed.  Specifically:  * [`candidateConstructorCache`](https://github.com/spring-projects/spring-framework/blob/192f2becf616642de23b43e03ffb3cdf5c5f4493/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java#L160) is not hit in a typical Spring Boot application and seems unnecessary if there's only a single constructor. * [`injectionMetadataCache`](https://github.com/spring-projects/spring-framework/blob/192f2becf616642de23b43e03ffb3cdf5c5f4493/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java#L162) is typically hit twice for singletons and always once after the other. The calls come from `postProcessProperties` and `postProcessMergedBeanDefinition`, both from `doCreateBean`. We could perhaps get away with a single element cache (at least for singletons). * [`@Lookup` support](https://github.com/spring-projects/spring-framework/blob/192f2becf616642de23b43e03ffb3cdf5c5f4493/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.java#L298) happens for each class and also uses a cache. It's not a particularly common pattern anymore and it would be nice if it could be skipped if we know it's not in use. Perhaps we can skip it for auto-configuration classes.","open","in: core,","philwebb","2022-04-06T17:19:43Z","2022-04-25T10:00:12Z"
"","28565","Allow ApplicationContextAotGenerator to generated better class names","Currently `ApplicationContextAotGenerator` always generates a `__.BeanFactoryRegistrations` class. For context hierarchy support we're going to need multiple registration classes so we should use different names. We'd also like to be able to provide a target class so that we can use a package other than `__`.","closed","theme: aot,","philwebb","2022-06-04T01:12:55Z","2022-06-07T16:59:50Z"
"","28580","Allow @CompileWithTargetClassAccess to work with all classes","Currently `@CompileWithTargetClassAccess` works by using `MethodHandles.privateLookupIn` and having target classes listed on the annotation. This is quite error prone and makes it impossible to have target access if the there isn't a class in the same package available.  We can probably get away with a reflection approach instead which will simplify a lot of tests.","closed","theme: aot,","philwebb","2022-06-07T21:07:27Z","2022-06-07T21:13:46Z"
"","28069","Controlling flashmap from a ModelAndView","Currently (Spring Boot2.6.2) it is not possible to add flashmap attributes to a `ModelAndView`.  In the `ModelAndView` constructor, the flash attributes from a `RedirectAttributesModelMap` are not merged into the regular `ModelMap` contained in `ModelAndView`.   The test in `RequestMappingHandlerAdapter.getModelAndView` for `RedirectAttributes` fails, because the `ModelAndView` reads the attributes from the `RedirectAttributesModelMap` and merges them into the already existing `ModelMap` in `ModelAndView`.  The only way now to cause the `ModelMap` to be an instance of `RedirectAttributes` is by adding a `RedirectAttributes` to the `Controller` method.  What was expected is that the `RedirectAttributesModelMap` was passed to the `ModelAndViewContainer` so it could be picked up by the test in `RequestMappingHandlerAdapter.getModelAndView()`.  If a `RedirectAttributesModelMap` could turn up in `RequestMappingHandlerAdapter.getModelAndView` it would be a beautiful way to create a `View` factory returning a `ModelAndView` (with flash attributes) without having to signal this in the `Controller` method. And providing a clean separation.   A workaround currently is to fetch the flashmap via `RequestContextUtils`, but that looks like a kludge.","closed","status: superseded,","sijskes","2022-02-17T11:07:45Z","2022-04-11T11:11:19Z"
"","28195","Create cacheKey when the cacheKey is really needed","Create cacheKey when the cacheKey is really needed.","closed","status: declined,","dugenkui03","2022-03-17T16:18:11Z","2022-03-17T17:09:29Z"
"","28149","Add GeneratedType infrastructure","Contributions need a way to contribute code without having to care about naming and access to privileged packages. A generation context of some kind offering a way to access such type and contribute methods is a first step towards that goal.","closed","theme: aot,","snicoll","2022-03-09T09:56:34Z","2022-03-09T10:19:01Z"
"","28391","ContentCachingRequestWrapper#getContentAsByteArray is empty before FilterChain#doFilter","ContentCachingRequestWrapper#getContentAsByteArray is empty before javax.servlet.FilterChain#doFilter  ```java public class LogFilter implements Filter {      @Override     public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)             throws IOException, ServletException {         ContentCachingRequestWrapper contentCachingRequestWrapper = new ContentCachingRequestWrapper((HttpServletRequest) servletRequest);         ContentCachingResponseWrapper contentCachingResponseWrapper = new ContentCachingResponseWrapper((HttpServletResponse) servletResponse);          byte[] contentAsByteArray = contentCachingRequestWrapper.getContentAsByteArray();         // but contentAsByteArray is empty         String s = new String(contentAsByteArray);         System.out.println(""request body:"" + s);          chain.doFilter(contentCachingRequestWrapper, contentCachingResponseWrapper);          byte[] contentAsBytes = contentCachingRequestWrapper.getContentAsByteArray();         // contentAsBytes is not empty         String str = new String(contentAsBytes);         System.out.println(""request body:"" + str);          byte[] contentAsByteArray1 = contentCachingResponseWrapper.getContentAsByteArray();         String s1 = new String(contentAsByteArray1);         System.out.println(""response body:"" + s1);                  contentCachingResponseWrapper.copyBodyToResponse();     }      } ```","open","status: waiting-for-triage,","brucelwl","2022-04-27T15:14:30Z","2022-04-28T06:16:11Z"
"","28374","Fix find RootBeanDefinition strategy in class FactoryAwareOrderSourceProvider","Consider ancestor bean factories for finding `RootBeanDefinition` in class `FactoryAwareOrderSourceProvider`.  Currently the code will only find `RootBeanDefinition` for a bean name in current bean factory, and `null` if no bean definition is found for the searching bean name. Not consider any ancestor bean factories. This is the cause of the bug of [issues 2466 spring-cloud-gateway](https://github.com/spring-cloud/spring-cloud-gateway/issues/2466)","open","status: waiting-for-triage,","tommas1988","2022-04-24T17:35:49Z","2022-07-31T05:06:21Z"
"","28812","AOT-generated code for a FactoryBean should have a better location","Consider a `BeanDefinition` with a `FactoryBean` that is registered programmatically. As it doesn't have a factory method, the code currently uses the target type's package to generate the code.  This does not work very well for `FactoryBean` target types, that are intermediate layers and should not be considered as a good target location for such a code. Perhaps `BeanRegistrationCodeFragments#getTarget` could have a check to see if the target type is such a factory bean?  See also #28809","closed","theme: aot,","snicoll","2022-07-13T12:51:36Z","2022-07-19T13:20:54Z"
"","28900","Ensure CompileWithTargetClassAccessExtension only uses the Jupiter TestEngine","Commit 9dd7f5412aa72efdeb1ba15b2cd86c6391540b61 addressed the issue of having the TestNG `TestEngine` for the JUnit Platform (JUnit 5) on the test runtime classpath by allowing `org.testng` types to pass through to the original `ClassLoader`; however, that fix merely obfuscates the underlying issue.  The underlying issue is that the `CompileWithTargetClassAccessExtension` is only applicable to JUnit Jupiter tests and therefore should launch the JUnit Platform with only the JUnit Jupiter `TestEngine` active.","closed","theme: aot,","sbrannen","2022-08-01T09:37:59Z","2022-08-01T10:12:05Z"
"","28654","WebClient doesn't handle errors related to connectivity without cluttering the logs with the stacktrace","Coming from `RestTemplate`, it was fairly easy catching all sorts of exceptions related to the connectivity with an external API service by catching `RestClientException` (e.g., if the service is down, or if you use the wrong port in the URL). Catching these exceptions won't clutter the log file and the errors can be shown in a clean manner.  Unfortunately, it doesn't seem that `WebClient` handles these exceptions nicely. Below is an example of my code. I am using (on purpose) an incorrect port in the URL of my service to simulate a connection problem. While the exception does print `The connection observed an error`, there is no way to catch this error nicely without cluttering the logs. On SO, the posts that mention a similar problem disable the Netty logger completely, which seems like overkill.   Is there a way to catch this connection error whilst disabling the stacktrace?   My code:  ```java webclient.post()     .uri(builder -> builder.path(myExternalApi).build())     .exchangeToMono(res -> {         HttpStatus httpStatus = res.statusCode();         if (httpStatus.isError()) {             return res.bodyToMono(String.class)                     .flatMap(body -> {                         log.error(""Error in response: "", body);                         return Mono.error(new MyCustomException(""Error"", ""error_code_0""));                     });         }         return res.toEntity(String.class);     })     .doOnError(ClosedChannelException.class, e -> {         log.error(""The error message is: "", e.getMessage());         throw new MyCustomException(""Error 1"", ""error_code_1"");     })     .doOnError(WebClientException.class, e -> {         log.error(""The error message is: "", e.getMessage());         throw new MyCustomException(""Error 2"", ""error_code_2"");     })     .block(); ```  Output (e.g., whenever I use the wrong port in my external API):  ``` 2022-06-18 22:18:10.759  WARN 43221 --- [r-http-kqueue-1] r.netty.http.client.HttpClientConnect  :  [error, L:/myip ! R:myexternalservice.com/myipaddress:myport] The connection observed an error  java.nio.channels.ClosedChannelException: null 	at io.netty.handler.ssl.SslHandler.channelInactive(SslHandler.java:1064) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:241) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1405) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:262) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:248) 	at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:901) 	at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:813) 	at io.netty.util.concurrent.AbstractEventExecutor.runTask(AbstractEventExecutor.java:174) 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:167) 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:470) 	at io.netty.channel.kqueue.KQueueEventLoop.run(KQueueEventLoop.java:293) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:995) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:834)  The error message is: nested exception is java.nio.channels.ClosedChannelException MyCustomException(""Error 2"", ""error_code_2""); is thrown ```","open","in: web,","simplyanything","2022-06-18T21:07:04Z","2022-06-19T16:11:54Z"
"","28664","Wrong reflection hints for arrays of inner types","Closes https://github.com/spring-projects/spring-framework/issues/28663","closed","theme: aot,","mhalbritter","2022-06-20T13:44:43Z","2022-06-20T14:01:33Z"
"","28896","Make AnnotationsUtils::findAnnotation recognize annotations on anonymous classes again","Closes gh-28895","open","status: waiting-for-triage,","janeisklar","2022-07-31T12:08:34Z","2022-08-01T07:29:17Z"
"","28108","Use equals() instead of contains() in RollbackRuleAttribute","Closes gh-28098","closed","status: declined,","lzj960515","2022-02-27T16:29:10Z","2022-02-28T17:04:02Z"
"","27948","`MissingServletRequestPartException` extends `ServletRequestBindingException`","Closes gh-27910","closed","type: enhancement,","heowc","2022-01-18T14:18:13Z","2022-06-01T17:21:36Z"
"","28647","Fix a typo in ResponseEntity documentation","Change `return ResponseEntity.ok().eTag(etag).build(body);` to `return ResponseEntity.ok().eTag(etag).body(body);` for both WebMVC and WebFlux.","closed","type: documentation,","sdeleuze","2022-06-17T10:08:18Z","2022-06-17T11:03:38Z"
"","28425","Remove obsolete SpEL expression grammar file","Can you provide a SpEL expression grammar file for antlr4 as known as `SpringExpression.g4`?","closed","in: core,","superdc","2022-05-08T08:55:12Z","2022-05-11T09:21:54Z"
"","28328","Work around the fact that GraalVM detects that DataSize is safe to initialize at build time","Building a simple command-line leads to:   ``` Error: Classes that should be initialized at run time got initialized during image building:  org.springframework.util.unit.DataSize was unintentionally initialized at build time. To see why org.springframework.util.unit.DataSize got initialized use --trace-class-initialization=org.springframework.util.unit.DataSize  com.oracle.svm.core.util.UserError$UserException: Classes that should be initialized at run time got initialized during image building:  org.springframework.util.unit.DataSize was unintentionally initialized at build time. To see why org.springframework.util.unit.DataSize got initialized use --trace-class-initialization=org.springframework.util.unit.DataSize  	at com.oracle.svm.core.util.UserError.abort(UserError.java:73) 	at com.oracle.svm.hosted.classinitialization.ConfigurableClassInitialization.checkDelayedInitialization(ConfigurableClassInitialization.java:555) 	at com.oracle.svm.hosted.classinitialization.ClassInitializationFeature.duringAnalysis(ClassInitializationFeature.java:167) 	at com.oracle.svm.hosted.NativeImageGenerator.lambda$runPointsToAnalysis$10(NativeImageGenerator.java:704) 	at com.oracle.svm.hosted.FeatureHandler.forEachFeature(FeatureHandler.java:74) 	at com.oracle.svm.hosted.NativeImageGenerator.lambda$runPointsToAnalysis$11(NativeImageGenerator.java:704) 	at com.oracle.graal.pointsto.PointsToAnalysis.runAnalysis(PointsToAnalysis.java:755) 	at com.oracle.svm.hosted.NativeImageGenerator.runPointsToAnalysis(NativeImageGenerator.java:702) 	at com.oracle.svm.hosted.NativeImageGenerator.doRun(NativeImageGenerator.java:537) 	at com.oracle.svm.hosted.NativeImageGenerator.run(NativeImageGenerator.java:494) 	at com.oracle.svm.hosted.NativeImageGeneratorRunner.buildImage(NativeImageGeneratorRunner.java:426) 	at com.oracle.svm.hosted.NativeImageGeneratorRunner.build(NativeImageGeneratorRunner.java:587) 	at com.oracle.svm.hosted.NativeImageGeneratorRunner.main(NativeImageGeneratorRunner.java:126) 	at com.oracle.svm.hosted.NativeImageGeneratorRunner$JDK9Plus.main(NativeImageGeneratorRunner.java:617) ```  This looks wrong and could be addressed in Graal. In the meantime we'll add a flag to prevent that from happening.","closed","type: task,","snicoll","2022-04-12T09:08:53Z","2022-06-03T14:53:01Z"
"","28315","Fix issues 28298, findAnnotationOnBean finds annotations from a static @Bean method's enclosing class","BugFix: https://github.com/spring-projects/spring-framework/issues/28298  Please review, thx","closed","status: waiting-for-triage,","284831721","2022-04-10T14:11:55Z","2022-04-10T14:40:00Z"
"","28636","Update to Bouncycastle 1.71","BouncyCastle changed its artifact name suffix from `jdk15on` to `jdk18on` in the latest releases, as it now requires at least Java 1.8","closed","type: dependency-upgrade,","larsgrefer","2022-06-16T01:23:39Z","2022-06-16T13:41:23Z"
"","28780","ResponseCookie does not declare nullability annotations consistently for domain and path","Both `domain` and `path` are nullable but `ResponseCookieBuilder#path` and `ResponseCookieBuilder#domain` arguments do not express this which causes warnings if actual arguments are potentially nullable.","closed","type: bug,","vpavic","2022-07-08T20:21:03Z","2022-07-29T15:41:39Z"
"","28219","Conversion Service not able to find Converter in Springframework 5.3.16","Below is a converter class I have created in my project, It was working fine in the previous version of the spring framework, and now it is not able to find the converter. ```java @Component public class BindingsFromEntityToApi implements Converter {      private final ObjectMapper om;          public BindingsFromEntityToApi(Jackson2ObjectMapperBuilder objectMapperBuilder) {         this.om = objectMapperBuilder.build();     }            public Binding convert(BindingInfoEntity source) {        //convert logic     }     } ``` The weird part is in tests it is able to find and do the conversion , but when I start the app and then try to do same operation it is not able to find the converter","closed","status: invalid,","sharma-abhishek2023","2022-03-23T05:57:10Z","2022-03-25T09:42:08Z"
"","28150","Introduce ApplicationContextAotGenerator","Based on https://github.com/spring-projects/spring-framework/issues/28065 and https://github.com/spring-projects/spring-framework/issues/28088, we are now capable of creating an entry point for processing a `GenericApplicationContext` ahead of time.   The generator refreshes the context for AOT processing  first, and then identifies the relevant contributions that are applicable for contributed bean definitions. It then invokes them so that code and runtime hints are contributed.","closed","theme: aot,","snicoll","2022-03-09T10:03:12Z","2022-03-09T10:19:04Z"
"","28617","Add ifPresent utility methods on RuntimeHints","Based on concrete usage of the API, it looks like a `registerIfPresent` would be a nice addition to the API. This makes sure hints aren't contributed for things that aren't available.","closed","theme: aot,","snicoll","2022-06-14T09:01:02Z","2022-06-14T12:15:44Z"
"","28446","Refine CachedIntrospectionResults property introspection","Backport of gh-28445","closed","type: backport,","jhoeller","2022-05-11T06:26:45Z","2022-05-11T06:53:19Z"
"","28444","Ignore invalid STOMP frame","Backport of gh-28443","closed","type: backport,","rstoyanchev","2022-05-11T06:24:56Z","2022-05-11T06:28:33Z"
"","28334","Improve documentation and matching algorithm in data binders","Backport of gh-28333","closed","type: backport,","sbrannen","2022-04-13T14:09:10Z","2022-04-13T14:09:36Z"
"","28281","Remove DNS lookups during websocket connection initiation","Backport of gh-28280","closed","type: backport,","jhoeller","2022-04-04T10:50:46Z","2022-04-08T12:48:54Z"
"","28272","NotWritablePropertyException when attempting to declaratively configure ClassLoader properties","Backport of gh-28269","closed","type: backport,","jhoeller","2022-04-01T17:45:21Z","2022-04-08T12:49:13Z"
"","28273","ResponseEntity objects are accumulated in ConcurrentReferenceHashMap","Backport of gh-28232","closed","type: backport,","jhoeller","2022-04-01T17:46:58Z","2022-04-08T12:49:08Z"
"","28257","Improve diagnostics in SpEL for large array creation","Backport of gh-28145","closed","type: backport,","jhoeller","2022-03-31T08:32:25Z","2022-04-05T14:32:51Z"
"","28279","CodeGenerationException thrown when using AnnotationMBeanExporter on JDK 17","Backport of gh-28138","closed","type: backport,","jhoeller","2022-04-04T10:12:21Z","2022-04-08T12:49:01Z"
"","28262","Restrict access to property paths on Class references","Backport of #28261.","closed","type: backport,","rstoyanchev","2022-03-31T10:55:17Z","2022-03-31T10:56:48Z"
"","28145","Improve diagnostics in SpEL for large array creation","Attempting to create a large array in a SpEL expression can result in an `OutOfMemoryError`. Although the JVM recovers from that, we should throw an exception with a meaningful error message in order to improve diagnostics for the user.","closed","type: enhancement,","sbrannen","2022-03-08T15:53:04Z","2022-03-31T10:53:53Z"
"","28678","Avoid use of Commons Logging in LoggingCacheErrorHandler public API","At present, creating `LoggingCacheErrorHandler` with custom logger requires use of Commons Logging API, as the appropriate constructor expects `org.apache.commons.logging.Log` instance. As Commons Logging is rarely the logging framework of choice in applications these days, interaction with its API might not be desirable.  This commit adds `LoggingCacheErrorHandler` constructor that accepts logger name and thus avoids leaking out any details about the underlying logging framework, while also deprecating the existing constructor that accepts `org.apache.commons.logging.Log`.  ---  I'm opening this PR to discuss one aspect of #28648 that was overlooked as that PR was superseded:  > The first commit could maybe be update to deprecate the existing constructor that takes `org.apache.commons.logging.Log` and replace it with the one that takes `String` representing logger name as that way Commons Logging dependency wouldn't leak out at all. But I'd leave that decision to whoever reviews this PR.  These days, it's almost inevitable to have several logging frameworks on the classpath, with only one of those being the intended application-wide logging API. To avoid unintended use of other logging APIs, something like Checkstyle can be used to prohibit imports of undesirable classes. However, `LoggingCacheErrorHandler` makes this a bit difficult at the moment hence this proposal.  If you agree this proposal and also with the deprecation of constructor that uses `org.apache.commons.logging.Log`, I'll rework the tests to avoid use of deprecated constructor.","open","status: waiting-for-triage,","vpavic","2022-06-22T16:04:04Z","2022-07-31T05:10:34Z"
"","28670","Simplify creation of LoggingCacheErrorHandler with logged stacktrace","At present, creating `LoggingCacheErrorHandler` that logs stacktrace also requires supplying the logger to be used. This might be inconvenient for some users, as it requires usage of Commons Logging API.  This commit simplifies creation of such as `LoggingCacheErrorHandler` instance by adding a constructor that only accepts a boolean flag indicating whether to log stacktrace.  ---  This was originally a part of:  - #28648  For consideration:  > The first commit could maybe be update to deprecate the existing constructor that takes `org.apache.commons.logging.Log` and replace it with the one that takes `String` representing logger name as that way Commons Logging dependency wouldn't leak out at all. But I'd leave that decision to whoever reviews this PR.","closed","type: enhancement,","vpavic","2022-06-21T10:56:06Z","2022-06-21T12:44:15Z"
"","28390","Upgrade to ASM 9.3","ASM 9.3 has been officially released in the meantime, with a few late code style commits not reflected in our fork yet. We'll upgrade to ASM 9.3 GA for 5.3.20, possibly as the end of ASM updates in 5.3.x line (with its intended JDK 8-19 support range covered by ASM now).","closed","type: dependency-upgrade,","jhoeller","2022-04-27T15:12:59Z","2022-05-05T16:20:06Z"
"","27954","Deprecate SpringFactoriesLoader#loadFactoryNames","As seen in #27753, the `SpringFactoriesLoader#loadFactoryNames` (introduced in #15158 ) has been very useful over the years but is too permissive for our AOT and native work. Some existing use cases can use reflection in a way that's not predictable for AOT processors.  Here are three example use cases in Spring Boot: * the [ConfigDataLoaders](https://github.com/spring-projects/spring-boot/blob/1e4e4f168d3956177d8dc81bdaba964bc54cf1ae/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/config/ConfigDataLoaders.java) are loading `ConfigDataLoader` class names and are calling non-default constructors using a set of dependencies maintained locally * the [ImportAutoConfigurationImportSelector](https://github.com/spring-projects/spring-boot/blob/1e4e4f168d3956177d8dc81bdaba964bc54cf1ae/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/ImportAutoConfigurationImportSelector.java) is loading auto-configuration class names. * the [FailureAnalyzers](https://github.com/spring-projects/spring-boot/blob/197203968aaa579e5fa7dac73b90a826fe7c6908/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/diagnostics/FailureAnalyzers.java#L83) is using class names to create objects directly and continue in failure scenarios.  Instead of Strings, the replacement should return a different type that allows for the actual type inspection and a Supplier to get an actual instance. Maybe something similar to `ServiceLoader.Provider`. This proposal will probably not solve the two use cases mentioned above, so we'll need to find proper replacements in Spring Boot or provide new features in Spring Framework to support them.","closed","theme: aot,","bclozel","2022-01-19T16:39:07Z","2022-07-27T15:58:48Z"
"","27955","Support AOT registration of Spring Factories","As seen in #27753, `SpringFactoriesLoader` is currently supported in Spring Native through subtitutions and complex AOT processors.  We'd like to improve `SpringFactoriesLoader` and allow static registration of Spring Factories, something our AOT processing could leverage and call early during application startup. Once a Factory type is registered with entries, `SpringFactoriesLoader` should use this entry as a pre-warmed cache and never look for additional entries in `spring.factories` files, skipping all the resource loading and reflection operations.  Instead of registering String instances as entries, this new contract might take `Supplier` instances instead, maybe mirroring the new contract to be added in #27954","closed","theme: aot,","bclozel","2022-01-19T17:04:19Z","2022-05-11T09:40:43Z"
"","28135","Links to Spring Security are broken in the reference guide","As reported on Twitter (https://twitter.com/nmpallas/status/1499731998558072840), we should review the links to Spring Security as they've changed recently.","closed","type: documentation,","snicoll","2022-03-04T13:16:02Z","2022-03-05T13:56:53Z"
"","28047","Add Bean instantiation generator infrastructure","As part of our AOT effort, we need an infrastructure that lets us generate the code to instantiate a bean.  This includes some low-level code generation infrastructure to write method calls, parameters, etc, as well as an API that can be used to contribute to the bean instance.   Such contributors should namely be based on the existing `BeanPostProcessor` infrastructure as they augment a bean instance with some logic that can be translated into code during the AOT phase. As BPP are ordered, so can their contributions so that the order in which they are applied by executing generated code matches.  To ease code generation, we need an infrastructure that focuses on something quite basic for a first version, something like:  ```java BeanDefinitionRegistrar.of(""restTemplateClientService"", RestTemplateClientService.class) 	  .withConstructor(RestTemplateBuilder.class) 	  .instanceSupplier((instanceContext) -> instanceContext.create(beanFactory, (attributes) -> 			  new RestTemplateClientService(attributes.get(0)))) 	  .register(beanFactory); ```  This registeres a `restTemplateClientService` bean that requires a `RestTemplateBuilder`. Rather than doing all the dependency resolution at build-time, we leverage framework's dependency resolution algorithm, via the `instanceContext` who can provide us resolved attributes according to `Executable` to use to instantiate the bean (here a constructor that takes a `RestTemplateBuilder`).","closed","theme: aot,","snicoll","2022-02-14T13:23:00Z","2022-03-09T09:45:57Z"
"","28814","Provide options for external control over `ProblemDetail` properties for Spring web exceptions","As part of #27052, each Spring web exception now implements `ErrorResponse` and exposes a `ProblemDetail` with details for the error response body. The `detail` field is typically set to a minimal message rather than the actual Exception message, to avoid exposing implementation specific details, and applications can extend `ResponseEntityExceptionHandler` to customize the details for each Spring web exception individually.  We should consider ways to customize the `ProblemDetail` for Spring web exceptions, and/or for any `ErrorResponseException`. One idea is to perform a lookup in a `MessageSource` using codes based on the exception name. `ResponseStatusExceptionResolver` does something similar and we could use this to derive `type`, `title`, and `detail`, including internationalized versions depending on the current locale.   One specific challenge will be the ability to parameterize messages with information from the exception.","open","type: enhancement,","rstoyanchev","2022-07-13T15:54:11Z","2022-07-13T15:54:12Z"
"","28614","Register native hints for jakarta.inject annotations","As of #28442, core Spring annotations are registered for native hints, including `@Order` and `@AliasFor`.  Spring optionally supports `jakarta.inject.Inject` and `jakarta.inject.Qualifier`, detecting their presence on the classpath. We should ensure that similar hints are registered if they are present on the classpath during the AOT phase.","closed","theme: aot,","bclozel","2022-06-13T16:32:41Z","2022-06-13T16:51:14Z"
"","27926","PrintingResultHandler in MockMvc should infer UTF-8 encoding for JSON response","As explained in https://github.com/spring-projects/spring-framework/pull/27846#issuecomment-1000572951, the `PrintingResultHandler` does not infer UTF-8 encoding for a response with content type `application/json`. Consequently, UTF-8 characters in such a response will be garbled in the output from the `PrintingResultHandler`.  Since `PrintingResultHandler` is effectively a _client_ of the application (similar to the role a web browser plays), the `PrintingResultHandler` should infer the response encoding to be UTF-8 if the content type is `application/json`.","closed","type: enhancement,","sbrannen","2022-01-12T15:52:09Z","2022-01-12T16:13:34Z"
"","28212","Fix queriedMethods handling in ReflectionHintsSerializer","As discovered by @snicoll, serialiation of `queriedMethods` is broken when there is no `methods`. ```json [   {     ""name"": ""com.example.nativex.sample.basic.SampleConfiguration""     ""queriedMethods"": [       {         ""name"": ""testBean"",         ""parameterTypes"": []       }     ]   } ] ```","closed","theme: aot,","sdeleuze","2022-03-22T08:56:39Z","2022-03-22T09:00:41Z"
"","28835","Harmonize visibility of RuntimeHints builders","As discovered by @mhalbritter, some builders of the runtimehints infrastructure  can be instantiated. This gives the false impression that they can be used directly, typically in tests.","closed","theme: aot,","snicoll","2022-07-18T12:04:42Z","2022-07-18T12:10:05Z"
"","28075","Deprecate SerializationUtils#deserialize","As based on Java's serialization mechanism, it can be the source of Remote Code Execution vulnerabilities.  Today this utility is part of the `public` API and can be naively used to _convert_ from object to text and vice versa. However a naive use can lead to RCE vulnerability if user-input data (like files, cookies, etc.) is transfered using this utility.  I think it should be nice to at least warn the user about the use of this tool (with `@Deprecated`) and later on remove it totally from the public API as this sole use in Spring code is to clone exceptions in `org.springframework.cache.jcache.interceptor.CacheResultInterceptor`.  I am not sure on how it can (or should) be handled. Let me know if you need me to adapt the code of this PR.","closed","type: enhancement,","ledoyen","2022-02-18T17:43:08Z","2022-03-30T08:33:24Z"
"","28163","Classpath-based filtering of the native configuration generation","As a follow-up of #27991 and #28160, a filtering on the generated configuration should be done based on classpath checks using `reachableType` for all hints + reflection/proxy/serializable types. This will allow to reduce the amount of configuration generated.","closed","theme: aot,","sdeleuze","2022-03-11T09:06:30Z","2022-07-27T08:42:54Z"
"","27991","Add GraalVM native JSON configuration generation","As a follow-up of #27829, we need to implement GraalVM native JSON configuration generation for [reflection](https://www.graalvm.org/22.0/reference-manual/native-image/Reflection/#manual-configuration), [JDK proxies](https://www.graalvm.org/22.0/reference-manual/native-image/DynamicProxy/#manual-configuration), [resources](https://www.graalvm.org/22.0/reference-manual/native-image/Resources/) and serialization as one of the possible outputs.  Other use cases could be generating HTML reports for example, so the APIs should be designed for other use cases, GraalVM native JSON configuration generation being just one use case among others.","closed","theme: aot,","sdeleuze","2022-01-31T09:51:09Z","2022-03-16T15:27:12Z"
"","28036","Upgrade to Kotlin 1.6.20","As a follow-up of #27814.","closed","in: kotlin,","bclozel","2022-02-11T10:42:07Z","2022-04-04T13:21:00Z"
"","28507","Introduce ModulePathResource for resources loaded from the module path","As a follow up to #28506, we should introduce `ModulePathResource` as companion to the existing `ClassPathResource` to support use cases when a developer wishes to explicitly load a resource from the module path instead of the class path.","open","type: enhancement,","sbrannen","2022-05-23T16:52:27Z","2022-06-20T13:07:32Z"
"","28708","GraalVM conflict with spring.main.log-startup-info property in WSL","Although the property is set to: _**false**_ **_(spring.main.log-startup-info=false)_** in my application.properties and even if you print it out it, spring still says it is set to false, the native-image logs of my app print out the spring startup-info like it is set to _true._ The process I am following is:  > mvn clean  > mvn -Pnative -DskipTests package  > Run the native-image of my app in my WSL  Versions:  - Java 17 - spring-boot-starter-parent: 2.7.0 - spring-aot-maven-plugin: 0.12.0 - native-maven-plugin: 0.9.11  **PS:** _If it has any meaning to the issue, I also tried doing the same with a very simple spring app too and this issue seems to persist._","closed","for: external-project,","LtVaios","2022-06-27T09:38:24Z","2022-06-27T11:08:53Z"
"","28598","Improve `ResourcePatternHint` documentation","Also add a link to this documentation to the various usages Javadoc.","closed","type: documentation,","sdeleuze","2022-06-09T12:32:49Z","2022-06-09T12:51:42Z"
"","28508","Official website not working properly","All actions point to the `https://spring.io/` home page, cannot access any other sections","closed","status: invalid,","Enfield-Li","2022-05-23T21:25:20Z","2022-05-23T21:34:24Z"
"","28669","Fix DataSourceUtils inconsistent exception handling","Align IllegalStateException with SQLException handling since IllegalState is only handled internally and the public facing Exception remains unchanged in either way.  Closes gh-28258","closed","type: enhancement,","kevin0x90","2022-06-21T09:52:06Z","2022-06-23T20:38:10Z"
"","28447","Facing SQL state [25P02]; error code [0] in spring integration flow while performing update","After looking at the logs we found that the exception occurred in `UPDATE INT_MESSAGE_GROUP set UPDATED_DATE=? where GROUP_KEY=? and REGION=?`, but the error code thrown was `0`, so spring integration class couldn't catch the proper exception and the exception was propagated to the top of hierarchy and got caught in super class Exception. So, we suspect that the issue was either in spring integration flow that it wasn't able to catch the uncategorized error or was it the PostgresDB which was culprit in throwing no error code.  It will be highly appreciative if I can get some help here. Please tell if anything else is required from my side.  I am attaching the detailed log captured in our code.  Here is the log printed :  ``` { ""preview"": false, ""offset"": 913, ""result"": {   ""_raw"": ""{\""ts\"":\""04 20 2022  03:10:25.763\"",\""th\"":\""task-scheduler-1\"",\""falcon_host\"":\""\"",\""tenant\"":\""\"",\""user\"":\""SysAdmin\"",\""trxid\"":\""469972d9-2f c7-4525-aaaf-8e88ff4d5fa9\"",\""level\"":\""ERROR\"",\""logger\"":\""org.springframework.integration.handler.LoggingHandler\"",\""msg\"" :\""org.springframework.messaging.MessageHandlingException: error occurred in message handler [bean  'org.springframework.integration.config.AggregatorFactoryBean#0' for component 'aggregator'; defined in: 'class path  resource [callbackProvisioning.xml]'; from source: ''int:aggregator' with id='aggregator'']; nested exception is   org.springframework.jdbc.UncategorizedSQLException: PreparedStatementCallback; uncategorized SQLException for SQL [UPDATE  INT_MESSAGE_GROUP set UPDATED_DATE=? where GROUP_KEY=? and REGION=?]; SQL state [25P02]; error code [0]; ERROR: current  transaction is aborted, commands ignored until end of transaction block; nested exception is com.edb.util.PSQLException:   ERROR: current transaction is aborted, commands ignored until end of transaction block, failedMessage=GenericMessage  [payload=TenantProvisionRequestStatusDTO [id=1322507, name=null, tenantProvisionRequestId=103916, service=WFMDB, displayService=WFM Database, status=pending, displayProvisionStatus=Pending, creationDate=2022-04-20 03:10:00.359, modifyDate=2022-04-20 03:10:00.359, description=null, serviceId=-12, provisionJson=null, isRecoverable=true, retryCount=0, nextRetryTime=null, subStatus=null], headers={sequenceNumber=1, sequenceDetails=[[b8ed4772-5c4b-01c6-3453-6368b2b430d7, 2, 2]], requestType=callback, sequenceSize=2, correlationId=aab63e4c-9809-ad0d-62a9-d9c3c6750dca, id=cfc77b00-1d3f-88d9-5d10-d4b487763aed, timestamp=1650424222608}]\\n\\tat  org.springframework.integration.support.utils.IntegrationUtils.wrapInHandlingExceptionIfNecessary(IntegrationUtils.java:192)\\n\\tat  org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:79)\\n\\tat  org.springframework.integration.dispatcher.AbstractDispatcher.tryOptimizedDispatch(AbstractDispatcher.java:115)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.doDispatch(UnicastingDispatcher.java:133)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.dispatch(UnicastingDispatcher.java:106)\\n\\tat  org.springframework.integration.channel.AbstractSubscribableChannel.doSend(AbstractSubscribableChannel.java:72)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:570)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:520)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:187)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:166)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:47)\\n\\tat  org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:109)\\n\\tat    org.springframework.integration.handler.AbstractMessageProducingHandler.sendOutput(AbstractMessageProducingHandler.java:445)\\n\\tatorg.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:47)\\n\\tat  org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:109)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.sendOutput(AbstractMessageProducingHandler.java:445)\\n\\tat   org.springframework.integration.handler.AbstractMessageProducingHandler.doProduceOutput(AbstractMessageProducingHandler.java:319)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.produceOutput(AbstractMessageProducingHandler.java:267)\\n\\tat  org.springframework.integration.splitter.AbstractMessageSplitter.produceOutput(AbstractMessageSplitter.java:311)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.sendOutputs(AbstractMessageProducingHandler.java:231)\\n\\tat  org.springframework.integration.handler.AbstractReplyProducingMessageHandler.handleMessageInternal(AbstractReplyProducingMessageHandler.java:140)\\n\\tat  org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:62)\\n\\tat  org.springframework.integration.dispatcher.AbstractDispatcher.tryOptimizedDispatch(AbstractDispatcher.java:115)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.doDispatch(UnicastingDispatcher.java:133)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.dispatch(UnicastingDispatcher.java:106)\\n\\tat   org.springframework.integration.channel.AbstractSubscribableChannel.doSend(AbstractSubscribableChannel.java:72)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:570)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:520)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:187)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:166)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:47)\\n\\tat  org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:109)\\n\\tat  org.springframework.integration.router.AbstractMessageRouter.doSend(AbstractMessageRouter.java:213)\\n\\tat  org.springframework.integration.router.AbstractMessageRouter.handleMessageInternal(AbstractMessageRouter.java:195)\\n\\tat  org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:62)\\n\\tat  org.springframework.integration.dispatcher.AbstractDispatcher.tryOptimizedDispatch(AbstractDispatcher.java:115)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.doDispatch(UnicastingDispatcher.java:133)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.dispatch(UnicastingDispatcher.java:106)\\n\\tat  org.springframework.integration.channel.AbstractSubscribableChannel.doSend(AbstractSubscribableChannel.java:72)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:570)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:520)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:187)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:166)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:47)\\n\\tat  org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:109)\\n\\tat   org.springframework.integration.handler.AbstractMessageProducingHandler.sendOutput(AbstractMessageProducingHandler.java:445)\\n\\tat   org.springframework.integration.handler.AbstractMessageProducingHandler.doProduceOutput(AbstractMessageProducingHandler.java:319)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.produceOutput(AbstractMessageProducingHandler.java:267)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.sendOutputs(AbstractMessageProducingHandler.java:231)\\n\\tat  org.springframework.integration.handler.AbstractReplyProducingMessageHandler.handleMessageInternal(AbstractReplyProducingMess ageHandler.java:140)\\n\\tat  org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:62)\\n\\tat  org.springframework.integration.dispatcher.AbstractDispatcher.tryOptimizedDispatch(AbstractDispatcher.java:115)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.doDispatch(UnicastingDispatcher.java:133)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.dispatch(UnicastingDispatcher.java:106)\\n\\tat  org.springframework.integration.channel.AbstractSubscribableChannel.doSend(AbstractSubscribableChannel.java:72)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:570)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:520)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:187)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:166)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:47)\\n\\tat  org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:109)\\n\\tat   org.springframework.integration.handler.AbstractMessageProducingHandler.sendOutput(AbstractMessageProducingHandler.java:445)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.doProduceOutput(AbstractMessageProducingHandler.java:319)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.produceOutput(AbstractMessageProducingHandler.java:267)\\n\\tat  org.springframework.integration.splitter.AbstractMessageSplitter.produceOutput(AbstractMessageSplitter.java:311)\\n\\tat  org.springframework.integration.handler.AbstractMessageProducingHandler.sendOutputs(AbstractMessageProducingHandler.java:231)\\n\\tat  org.springframework.integration.handler.AbstractReplyProducingMessageHandler.handleMessageInternal(AbstractReplyProducingMessageHandler.java:140)\\n\\tat  org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:62)\\n\\tat  org.springframework.integration.dispatcher.AbstractDispatcher.tryOptimizedDispatch(AbstractDispatcher.java:115)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.doDispatch(UnicastingDispatcher.java:133)\\n\\tat  org.springframework.integration.dispatcher.UnicastingDispatcher.dispatch(UnicastingDispatcher.java:106)\\n\\tat  org.springframework.integration.channel.AbstractSubscribableChannel.doSend(AbstractSubscribableChannel.java:72)\\n\\tat org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:570)\\n\\tat  org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:520)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:187)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:166)\\n\\tat  org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:47)\\n\\tat  org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:109)\\n\\tat  org.springframework.integration.endpoint.SourcePollingChannelAdapter.handleMessage(SourcePollingChannelAdapter.java:196)\\n\\ tat  org.springframework.integration.endpoint.AbstractPollingEndpoint.messageReceived(AbstractPollingEndpoint.java:444)\\n\\tat  org.springframework.integration.endpoint.AbstractPollingEndpoint.doPoll(AbstractPollingEndpoint.java:428)\\n\\tat  sun.reflect.GeneratedMethodAccessor188.invoke(Unknown Source)\\n\\tat   sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat  java.lang.reflect.Method.invoke(Method.java:498)\\n\\tat  org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)\\n\\tat  org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:198)\\n\\tat  org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)\\n\\tat  org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123)\\n\\tat  org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:388)\\n\\tat  org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\\n\\tat  org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)\\n\\tat  org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215)\\n\\tat  com.sun.proxy.$Proxy338.call(Unknown Source)\\n\\tat  org.springframework.integration.endpoint.AbstractPollingEndpoint.pollForMessage(AbstractPollingEndpoint.java:376)\\n\\tat  org.springframework.integration.endpoint.AbstractPollingEndpoint.lambda$null$3(AbstractPollingEndpoint.java:323)\\n\\tat  org.springframework.integration.util.ErrorHandlingTaskExecutor.lambda$execute$0(ErrorHandlingTaskExecutor.java:57)\\n\\tat  org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50)\\n\\tat  org.springframework.integration.util.ErrorHandlingTaskExecutor.execute(ErrorHandlingTaskExecutor.java:55)\\n\\tat  org.springframework.integration.endpoint.AbstractPollingEndpoint.lambda$createPoller$4(AbstractPollingEndpoint.java:320)\\n\\ tat  org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54)\\n\\tat  org.springframework.scheduling.concurrent.ReschedulingRunnable.run(ReschedulingRunnable.java:95)\\n\\tat  java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\\n\\tat  java.util.concurrent.FutureTask.run(FutureTask.java:266)\\n\\tat  java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\\n\\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\\n\\tat  java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\\n\\tat  java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\\n\\tat  java.lang.Thread.run(Thread.java:748)\\nCaused by: org.springframework.jdbc.UncategorizedSQLException:  PreparedStatementCallback; uncategorized SQLException for SQL [UPDATE INT_MESSAGE_GROUP set UPDATED_DATE=? where  GROUP_KEY=? and REGION=?]; SQL state [25P02]; error code [0]; ERROR: current transaction is aborted, commands ignored until  end of transaction block; nested exception is com.edb.util.PSQLException: ERROR: current transaction is aborted, commands  ignored until end of transaction block\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.translateException(JdbcTemplate.java:1542)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:667)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:960)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1015)\\n\\tat  org.springframework.integration.jdbc.store.JdbcMessageStore.doUpdateMessageGroup(JdbcMessageStore.java:635)\\n\\tat  org.springframework.integration.jdbc.store.JdbcMessageStore.addMessagesToGroup(JdbcMessageStore.java:361)\\n\\tat  org.springframework.integration.store.AbstractMessageGroupStore.addMessageToGroup(AbstractMessageGroupStore.java:189)\\n\\tat  org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler.store(AbstractCorrelatingMessageHandler.java:780 )\\n\\tat  org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler.processMessageForGroup(AbstractCorrelatingMessag eHandler.java:495)\\n\\tat  org.springframework.integration.aggregator.AbstractCorrelatingMessageHandler.handleMessageInternal(AbstractCorrelatingMessage Handler.java:474)\\n\\tat  org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:62)\\n\\t... 119  more\\nCaused by: com.edb.util.PSQLException: ERROR: current transaction is aborted, commands ignored until end of  transaction block\\n\\tat com.edb.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2759)\\n\\tat  com.edb.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2376)\\n\\tat  com.edb.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:347)\\n\\tat  com.edb.jdbc.PgStatement.executeInternal(PgStatement.java:510)\\n\\tat  com.edb.jdbc.PgStatement.execute(PgStatement.java:427)\\n\\tat  com.edb.jdbc.PgPreparedStatement.executeWithFlags(PgPreparedStatement.java:175)\\n\\tat  com.edb.jdbc.PgPreparedStatement.executeUpdate(PgPreparedStatement.java:141)\\n\\tat  sun.reflect.GeneratedMethodAccessor268.invoke(Unknown Source)\\n\\tat  sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat  java.lang.reflect.Method.invoke(Method.java:498)\\n\\tat  org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor$StatementProxy.invoke(StatementDecoratorInterceptor.jav a:237)\\n\\tat com.sun.proxy.$Proxy290.executeUpdate(Unknown Source)\\n\\tat  sun.reflect.GeneratedMethodAccessor268.invoke(Unknown Source)\\n\\tat  sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat  java.lang.reflect.Method.invoke(Method.java:498)\\n\\tat  org.apache.tomcat.jdbc.pool.StatementFacade$StatementProxy.invoke(StatementFacade.java:114)\\n\\tat  com.sun.proxy.$Proxy290.executeUpdate(Unknown Source)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.lambda$update$2(JdbcTemplate.java:965)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:651)\\n\\t... 128 more\\nCaused by:  com.edb.util.PSQLException: ERROR: duplicate key value violates unique constraint \\\""message_group_pk\\\""\\n  Detail: Key  (group_key, region)=(254b6008-0fd7-3c10-b142-2a2e4f1841d8, DEFAULT) already exists.\\n\\tat  com.edb.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2759)\\n\\tat  com.edb.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2376)\\n\\tat  com.edb.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:347)\\n\\tat  com.edb.jdbc.PgStatement.executeInternal(PgStatement.java:510)\\n\\tat  com.edb.jdbc.PgStatement.execute(PgStatement.java:427)\\n\\tat  com.edb.jdbc.PgPreparedStatement.executeWithFlags(PgPreparedStatement.java:175)\\n\\tat  com.edb.jdbc.PgPreparedStatement.executeUpdate(PgPreparedStatement.java:141)\\n\\tat  sun.reflect.GeneratedMethodAccessor268.invoke(Unknown Source)\\n\\tat  sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat  java.lang.reflect.Method.invoke(Method.java:498)\\n\\tat  org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor$StatementProxy.invoke(StatementDecoratorInterceptor.jav a:237)\\n\\tat com.sun.proxy.$Proxy290.executeUpdate(Unknown Source)\\n\\tat  sun.reflect.GeneratedMethodAccessor268.invoke(Unknown Source)\\n\\tat  sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat  java.lang.reflect.Method.invoke(Method.java:498)\\n\\tat  org.apache.tomcat.jdbc.pool.StatementFacade$StatementProxy.invoke(StatementFacade.java:114)\\n\\tat  com.sun.proxy.$Proxy290.executeUpdate(Unknown Source)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.lambda$update$2(JdbcTemplate.java:965)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:651)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:960)\\n\\tat  org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:1015)\\n\\tat  org.springframework.integration.jdbc.store.JdbcMessageStore.doCreateMessageGroup(JdbcMessageStore.java:623)\\n\\tat  org.springframework.integration.jdbc.store.JdbcMessageStore.addMessagesToGroup(JdbcMessageStore.java:357)\\n\\t... 124   more\\n\""  }"",     ""_time"": ""2022-04-20T03:10:25.763+0000"",     ""date_hour"": ""3"",     ""date_mday"": ""20"",     ""date_minute"": ""10"",     ""date_month"": ""april"",     ""date_second"": ""25"",     ""date_wday"": ""wednesday"",     ""date_year"": ""2022"",     ""date_zone"": ""local"",     ""falcon_host"": """",     ""host"": ""cust01-gss01-tms10-app-1648100547-1.int.gss.mykronos.com"",     ""index"": ""cust-prd-wfd-tms-app"",     ""level"": ""ERROR"",     ""linecount"": ""1"",     ""logger"": ""org.springframework.integration.handler.LoggingHandler"",     ""msg"": ""org.springframework.messaging.MessageHandlingException: error occurred in message handler [bean 'org.springframework.integration.config.AggregatorFactoryBean#0' for component 'aggregator'; defined in: 'class path resource [callbackProvisioning.xml]'; from source: ''int:aggregator' with id='aggregator'']; nested exception is      org.springframework.jdbc.UncategorizedSQLException: PreparedStatementCallback; uncategorized SQLException for SQL [UPDATE INT_MESSAGE_GROUP set UPDATED_DATE=? where GROUP_KEY=? and REGION=?]; SQL state [25P02]; error code [0]; ERROR: current transaction is aborted, commands ignored until end of transaction block; nested exception is      com.edb.util.PSQLException: ERROR: current transaction is aborted, commands ignored until end of transaction block, failedMessage=GenericMessage [payload=TenantProvisionRequestStatusDTO [id=1322507, name=null, tenantProvisionRequestId=103916, service=WFMDB, displayService=WFM Database, status=pending, displayProvisionStatus=Pending, creationDate=2022-04-20 03:10:00.359, modifyDate=2022-04-20 03:10:00.359, description=null, serviceId=-12, provisionJson=null, isRecoverable=true, retryCount=0, nextRetryTime=null, subStatus=null], headers={sequenceNumber=1, sequenceDetails=[[b8ed4772-5c4b-01c6-3453-6368b2b430d7, 2, 2]], requestType=callback, sequenceSize=2, correlationId=aab63e4c-9809-ad0d-62a9-d9c3c6750dca, id=cfc77b00-1d3f-88d9-5d10-d4b487763aed, timestamp=1650424222608}]\n\tat org.springframework.integration.support.utils.IntegrationUtils.wrapInHandlingExceptionIfNecessary(IntegrationUtils.java:192)     \more\n"",     ""source"": ""/data/tomcat/logs/tms.log"",     ""sourcetype"": ""tms:app"",     ""splunk_server"": ""cust01-prd01-log01-idx-210330-09.int.oss.mykronos.com"",     ""tenant"": """",     ""th"": ""task-scheduler-1"",     ""trxid"": ""469972d9-2fc7-4525-aaaf-8e88ff4d5fa9"",     ""ts"": ""04 20 2022 03:10:25.763"",     ""user"": ""SysAdmin"" } ```","closed","for: external-project,","ankitJavaMadeSoEasy","2022-05-11T10:59:15Z","2022-05-11T11:07:39Z"
"","28829","Hibernate error ""Session/EntityManager is closed"" when a query is reused","Affects: Spring Framework 5.3.21  A bean method shown below throws exception at the marked line: ```java     public void doTest() {         Query q = em.createNativeQuery(""select :n"");         q.setParameter(""n"", 1);         log.info(""result: {}"", q.getSingleResult());         q.setParameter(""n"", 2);     // <- exception         log.info(""result: {}"", q.getSingleResult());     } ``` Exception stack: ``` Exception in thread ""main"" java.lang.reflect.InvocationTargetException         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49)         at org.springframework.boot.loader.Launcher.launch(Launcher.java:108)         at org.springframework.boot.loader.Launcher.launch(Launcher.java:58)         at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:65) Caused by: java.lang.IllegalStateException: Session/EntityManager is closed         at org.hibernate.internal.AbstractSharedSessionContract.checkOpen(AbstractSharedSessionContract.java:407)         at org.hibernate.engine.spi.SharedSessionContractImplementor.checkOpen(SharedSessionContractImplementor.java:148)         at org.hibernate.query.internal.AbstractProducedQuery.setParameter(AbstractProducedQuery.java:492)         at org.hibernate.query.internal.NativeQueryImpl.setParameter(NativeQueryImpl.java:650)         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.lang.reflect.Method.invoke(Method.java:498)         at org.springframework.orm.jpa.SharedEntityManagerCreator$DeferredQueryInvocationHandler.invoke(SharedEntityManagerCreator.java:406)         at com.sun.proxy.$Proxy67.setParameter(Unknown Source)         at springtest.TestComponent.doTest(TestComponent.java:21)         at springtest.Main.main(Main.java:13)         ... 8 more ``` When the method is annotated with `@Transactional`, error does not occur.","closed","for: stackoverflow,","rafaello7","2022-07-16T17:23:02Z","2022-07-18T08:19:59Z"
"","28095","CronExpression fails to calculate properly next execution when running on the day of winter daylight saving time","Affects: Spring Framework 5.3.16  The PR #28044 fixing the issue #28038 did cause a regression for winter daylight saving time  Problem: CronExpression fails to calculate properly next execution when running on the day of winter daylight saving time, just before DST is applied.  Here is a unit test case that you can add to  `CronExpressionTests#daylightSaving` to reproduce the problem : ```java cronExpression = CronExpression.parse(""0 5 0 * * *"");  last = ZonedDateTime.parse(""2019-10-27T01:05+02:00[Europe/Paris]""); expected = ZonedDateTime.parse(""2019-10-28T00:05+01:00[Europe/Paris]""); actual = cronExpression.next(last); assertThat(actual).isNotNull(); assertThat(actual).isEqualTo(expected); ``` Please note that in the previous version 5.3.15 everything worked fine for that case","closed","in: core,","guilroux","2022-02-22T17:38:37Z","2022-03-29T12:11:09Z"
"","28038","CronExpression fails to calculate next execution on the day of daylight saving time","Affects: Spring Framework 5.3.15  Looks like the fix for #26744 doesn't cover the following case.  Problem: `CronExpression` fails to calculate properly next execution when running on the day of daylight saving time, just before DST is applied.  ```java ZonedDateTime current = ZonedDateTime.of(LocalDateTime.parse(""2021-03-28T01:00:00""), ZoneId.of(""Europe/Amsterdam"")); CronExpression cronExpression = CronExpression.parse(""0 5 0 * * *""); ZonedDateTime next = cronExpression.next(current); ```  In this case the value returned by `cronExpression.next(current)` is `2021-03-30T00:05` instead of the expected `2021-03-29T00:05`.  To be more precise any input date between `2021-03-28T00:05+01:00` and `2021-03-28T01:59+01:00` will calculate next execution to `2021-03-30T00:05` instead of the expected `2021-03-29T00:05`.  After DST, next execution is successfully calculated i.e. `2021-03-29T00:05`.","closed","in: core,","guilroux","2022-02-11T14:33:30Z","2022-02-16T10:30:44Z"
"","28854","ITS: IGNORES TICKETS TRACKING OUTSTANDING ISSUES BY DEFAULT","Affects: N/A --- Some of Spring's issue tracking has recently moved from Spring's Jira instance to GitHub. I'm afraid this brought a grave display issue, which affects https://github.com/spring-projects/spring-data-jpa/issues/2085 , https://github.com/spring-projects/spring-data-commons/issues/2458 and more. One way to reproduce would be to go to the issue tracker of an affected project and add to the search query a word part of a closed ticket's title, then launch search (press Enter). For example, on [Spring Data JPA's tracker](https://github.com/spring-projects/spring-data-jpa/issues), add ""hints"" to the text field. You will get a result like the following: ![Spring ITS search](https://user-images.githubusercontent.com/486141/180321062-1568b607-288b-49c8-a5d5-efdd6581e5f6.png)   This lacks ticket #2085, even if it has that term right in the title:  > 5.3.9. Applying Query Hints unclear about JPA query hints [DATAJPA-1790]  This false negative is in fact caused by a default search criteria which can be seen in the input field's default value:  > is:issue is:open  ""is:open"" excludes closed tickets.  Unless this is the result of a misconfiguration which can be fixed simply, I would recommend at least halting migration.  Most of this was already reported in #27532, but the scope of the bug is not actually restricted to search. This is in fact a general display issue, as can be seen in the numbers displayed in the ""Issues"" tab. For example, as of now, Spring Data Commons displays a count of 186, when it should display 2070 (186 + 1884): ![Spring ITS](https://user-images.githubusercontent.com/486141/179856952-0fb259c3-804c-4992-b266-e6506b34cd2b.jpg)  ### This ticket Needless to specify, in order to workaround #27532, thank you for not setting this ticket to closed until this is fixed.  Considering the gravity of this issue, #28692  and the stage the migration has reached, please either solve this immediately or ""pin"" this ticket.","closed","status: declined,","Chealer","2022-07-21T22:11:23Z","2022-07-22T07:48:50Z"
"","28356","SpEL: Two double quotes are replaced by one double quote in single quoted `String` literal (and vice versa)","Affects: `spring-expression` since `3.2 M2` up to `5.3.19`  The problem:  Two double quotes are replaced by one double quote - even when literal within single quotes  | Expression | Expected | Actual | | -- | -- | -- | | 'keep """" two double quotes' | keep """" two double quotes | keep "" two double quotes | | ""keep '' two single quotes"" | keep '' two single quotes | keep ' two double quotes |  According to reference guide only **single quotes** are allowed for `String` literals:  https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#:~:text=Strings%20are%20delimited%20by%20single%20quotation%20marks.%20To%20put%20a%20single%20quotation%20mark%20itself%20in%20a%20string%2C%20use%20two%20single%20quotation%20mark%20characters.  However actually double quotes are supported too (see https://github.com/spring-projects/spring-framework/issues/14254). And they also replacing two single quotes by one single quote  See  https://github.com/spring-projects/spring-framework/issues/14254 - this issue about double quotes support - however looks like it breaks single quoted literals https://github.com/spring-projects/spring-framework/blob/4e6ef82d8f3ae7c587e0f1900ca263fd5d7b7f02/spring-expression/src/main/java/org/springframework/expression/spel/standard/Tokenizer.java#L301 https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-expression/src/main/java/org/springframework/expression/spel/ast/StringLiteral.java#L41  Simple test program:          final var p = new SpelExpressionParser();         System.out.println(p.parseExpression(""'two double \""\"" quotes'"").getValue()); // prints two double "" quotes         System.out.println(p.parseExpression(""\""two single '' quotes\"""").getValue()); // prints two single ' quotes","open","status: waiting-for-triage,","acc15","2022-04-18T21:41:13Z","2022-04-18T21:55:36Z"
"","28109","Expression.setValue cannot parse complex expressions","Affects: 5.3.10，The same goes for the latest version 5.3.16  The Spring Framework source code for the last step is ```java package org.springframework.expression.spel.ast.SpelNodeImpl  @Override 	public void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException { 		throw new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass()); 	}  ```  Why does this method throw an exception directly? Why does the same expression, getValue, work correctly, while setValue reports an error? I think it might be a bug, normally, the get method should work just as well as the set method,or maybe I'm using it the wrong way? If you have any questions, please point them out to me. Thank you very much！！！  ## The entry object is as follows ```java @Accessors(chain = true) @Data public class OutDtoDigestLogDemo {     private InDtoDigestLogDemo inDtoDigestLogDemo;      public InDtoDigestLogDemo getInDtoDigestLogDemo() {         return inDtoDigestLogDemo;     } }   @Accessors(chain = true) @Data public class InDtoDigestLogDemo {      private List innerDtoDigestLogDemoList = new ArrayList<>();     private List innerSecondDtoDigestLogDemos = new ArrayList<>();}   @Accessors(chain = true) @Data public class InnerDtoDigestLogDemo {     private String demoStr;      private String demo;      private String str;}    @Accessors(chain = true) @Data public class InnerSecondDtoDigestLogDemo {     private String demoStrSecond;      private String demoSecond;      private String strSecond;} ```   ## The test method is as follows ```java     /*githubDemo*/     public OutDtoDigestLogDemo getListRequestParam() {         OutDtoDigestLogDemo outDtoDigestLogDemo = new OutDtoDigestLogDemo();         InDtoDigestLogDemo inDtoDigestLogDemo = new InDtoDigestLogDemo();         InnerDtoDigestLogDemo innerDtoDigestLogDemo1 = new InnerDtoDigestLogDemo();         InnerDtoDigestLogDemo innerDtoDigestLogDemo2 = new InnerDtoDigestLogDemo();         InnerDtoDigestLogDemo innerDtoDigestLogDemo3 = new InnerDtoDigestLogDemo();         innerDtoDigestLogDemo1.setDemoStr(""12313"").setDemo(""456465465"").setStr("",,,,"");         innerDtoDigestLogDemo2.setDemoStr(""3145342"").setDemo(""sfsf"").setStr(""....."");         innerDtoDigestLogDemo3.setDemoStr(""543235"").setDemo(""gssg"").setStr(""!!!!"");          InnerSecondDtoDigestLogDemo innerSecondDtoDigestLogDemo1 = new InnerSecondDtoDigestLogDemo();         InnerSecondDtoDigestLogDemo innerSecondDtoDigestLogDemo2 = new InnerSecondDtoDigestLogDemo();         InnerSecondDtoDigestLogDemo innerSecondDtoDigestLogDemo3 = new InnerSecondDtoDigestLogDemo();         innerSecondDtoDigestLogDemo1.setDemoStrSecond(""12313"").setDemoSecond(""456465465"").setStrSecond("",,,,"");         innerSecondDtoDigestLogDemo2.setDemoStrSecond(""3145342"").setDemoSecond(""sfsf"").setStrSecond(""....."");         innerSecondDtoDigestLogDemo3.setDemoStrSecond(""543235"").setDemoSecond(""gssg"").setStrSecond(""!!!!"");          List innerDtoDigestLogDemos                 = Arrays.asList(innerDtoDigestLogDemo1, innerDtoDigestLogDemo2, innerDtoDigestLogDemo3);         List innerSecondDtoDigestLogDemos                 = Arrays.asList(innerSecondDtoDigestLogDemo1, innerSecondDtoDigestLogDemo2, innerSecondDtoDigestLogDemo3);         inDtoDigestLogDemo.setInnerDtoDigestLogDemoList(innerDtoDigestLogDemos).setInnerSecondDtoDigestLogDemos(innerSecondDtoDigestLogDemos);         outDtoDigestLogDemo.setInDtoDigestLogDemo(inDtoDigestLogDemo);         return outDtoDigestLogDemo;     }      @Test     public void testGetValue() {         String[] expressions = new String[]{""#request.inDtoDigestLogDemo.innerDtoDigestLogDemoList.![#this.demoStr]""};         SpelExpressionParser parser = new SpelExpressionParser();         // spring的表达式上下文对象         EvaluationContext context = new StandardEvaluationContext();         // 给上下文赋值         context.setVariable(""request"", getListRequestParam());         String printFiledValue;         //获取关注参数         // 解析过后的Spring表达式对象         List expressionList = Arrays.stream(expressions)                 .map(parser::parseExpression)                 .collect(Collectors.toList());         printFiledValue = expressionList.stream()                 .map(expression -> Objects.nonNull(expression.getValue(context)) ? expression.getValue(context).toString() : """")                 .map(attentionFiledValueStr -> attentionFiledValueStr.replaceAll("","", ""==&==""))                 .collect(Collectors.joining(""==&==""));         printFiledValue = StringUtils.isBlank(printFiledValue) ? """" : printFiledValue;         System.out.println(""============================================================"");         System.out.println(printFiledValue);     }      @Test     public void testSetValue() {         String[] expressions = new String[]{""#request.inDtoDigestLogDemo.innerDtoDigestLogDemoList.![#this.demoStr]""};         SpelExpressionParser parser = new SpelExpressionParser();         // spring的表达式上下文对象         EvaluationContext context = new StandardEvaluationContext();         // 给上下文赋值         context.setVariable(""request"", getListRequestParam());         String printFiledValue;         // 解析过后的Spring表达式对象         List expressionList = Arrays.stream(expressions)                 .map(parser::parseExpression)                 .collect(Collectors.toList());         expressionList.forEach(expression -> expression.setValue(context, null));         //之后取出所有的参数put进一个map         Map paramsMap = Maps.newHashMap();         String expressionStr = ""#request"";         Expression expression = parser.parseExpression(expressionStr);         paramsMap.put(""request"", expression.getValue(context));         String jsonString = JSON.toJSONString(paramsMap);         printFiledValue = jsonString.replaceAll("","", ""==&=="");         printFiledValue = StringUtils.isBlank(printFiledValue) ? """" : printFiledValue;         System.out.println(""============================================================"");         System.out.println(printFiledValue);     } ```","closed","for: stackoverflow,","AresYoungLs","2022-02-28T04:10:59Z","2022-02-28T06:56:53Z"
"","28232","ResponseEntity objects are accumulated in ConcurrentReferenceHashMap","Affects: 5.2.8  --- > First of all, sorry for my bad english. If you're hard to understand my sentence, please comment  Ive been testing my team's project and monitoring it with `scouter` APM.  And found that ""used heap"" keeps going high whenever I call an different API .  I debugged and found that `Spring` accumulates `ResponseEntity` in `ConcurrentReferenceHashMap` of `ResolvableType.cache`.  It puts the whole response body of each `ResponseEntity` in `ConcurrentReferenceHashMap` which is static.  I believe that the Spring developers intended it for some reasons but I cannot find any even if I googled a lot.  If It it's an issue , please fix this.  if it's not, I would very appreciate you for giving me some explanation why `Spring` accumulates the `ResponseEntity` objects  even if it has a BIG BIG body.  Thank you. Best Regard.","closed","type: bug,","KangChanSong","2022-03-25T04:44:55Z","2022-04-08T11:26:58Z"
"","28712","Move ApplicationContextAotInitializer to Spring Boot","AFAICT currently the only user of `ApplicationContextAotInitializer` is `SpringApplication` in Spring Boot. If we move the class to Spring Boot we can make it package-private and have more control.","closed","status: declined,","philwebb","2022-06-27T15:41:52Z","2022-07-07T01:16:36Z"
"","28479","Test cases","Add two new test cases for jdbc part","closed","status: declined,","Robin11223","2022-05-19T05:19:15Z","2022-05-19T07:02:57Z"
"","28478","Testcases","Add two new test cases for jdbc part","closed","status: declined,","Robin11223","2022-05-19T05:05:50Z","2022-05-19T07:02:39Z"
"","27909","Add tests for StringUtils matchesCharacter() method","Add tests for StringUtils matchesCharacter() method","closed","in: core,","springmonster","2022-01-10T03:46:08Z","2022-01-10T12:29:38Z"
"","28774","add support for record value injection","add support for record value inject,just disable populateBean for reord,because recod is immutable，and no setter methods","open","status: waiting-for-triage,","1004789224","2022-07-08T03:08:44Z","2022-07-08T03:10:20Z"
"","28569","Add minimal Kotlin DSL RouterFunction attributes support","Add minimal Kotlin DSL RouterFunction attributes support  Fixes https://github.com/spring-projects/spring-framework/issues/28567.  The PR is composed by 2 commits that are more easy to review one by one : 1. _Add test case on nested RouterFunction attributes_ : as nested route attributes are already supported but not clearly tested 2. _Add minimal Kotlin DSL RouterFunction attributes support_ : just minimal to ensure that minimal support will be quickly integrated ; I think better Kotlin integration could be done be should probably be discussed","closed","in: kotlin,","christophejan","2022-06-05T17:11:34Z","2022-06-08T15:12:43Z"
"","28132","Batch update return generated keys","Add `NamedParameterJdbcTemplate#batchUpdate` methods taking `KeyHolder` and `String[] keyColumnNames` as counterparts to the `NamedParameterJdbcTemplate#update` methods of the same form.  This is in service of an enhancement to [`spring-data-jdbc`](https://github.com/spring-projects/spring-data-relational/pull/1191) to perform batch inserts to persist collections of entities referenced by an aggregate, when adequately supported by the database. The proposed changes to `spring-data-jdbc` currently include a [copy of the changes](https://github.com/spring-projects/spring-data-relational/pull/1191/files#diff-2526db37d52bc8ab9d5cb280c184ac07d28c0f1bfea856ea228653584374c04b) being proposed here, and could be refactored to use the respective `NamedParameterJdbcTemplate#batchUpdate` once accepted and merged.  Related to spring-projects/spring-framework#6530.","open","status: feedback-provided,","ctailor2","2022-03-03T22:26:49Z","2022-07-18T12:29:09Z"
"","27960","Modify status code 103 to (""Early Hints"")","According to rfc8297(https://tools.ietf.org/html/rfc8297), the reason phase of status code 103 should be ""Early Hints"", not ""Checkpoint"".  This commit modifies the status code 103 reason phase from (""Checkpoint"") to (""Early Hints"").","open","status: feedback-provided,","waisink","2022-01-20T09:09:31Z","2022-01-21T03:57:49Z"
"","27933","Ensure utility classes cannot be instantiated.","According to pull request #1848, utility classes are noninstantiable, but abstract is not enough to prevent from creating objects by subclasses. This change modified almost all utility classes, but I do think it is necessary, and the effects should small and limited.","closed","status: declined,","scruel","2022-01-14T04:14:59Z","2022-01-14T10:34:09Z"
"","27932","Ensure utility classes cannot be instantiated.","According to pull request #1848, utility classes are noninstantiable, but abstract is not enough for preventing create objects by subclasses. This change modified almost all utility classes, but I do think it is necessary, and the effects should small and limited.","closed","","scruel","2022-01-14T04:04:21Z","2022-02-18T19:05:45Z"
"","28214","Introduce HttpStatusCode interface","According to [the HTTP specification](https://datatracker.ietf.org/doc/html/rfc2616#section-6.1.1), the HTTP response status can be any 3-digit integer.   In Spring Framework, the HTTP status codes are enumerated in `HttpStatus`. Because this type is a Java `enum`, we need to have workarounds to allow for status codes not in the enum. For instance, the `ClientHttpResponse` interfaces offers both `getStatusCode` as well as `getRawStatusCode`, as does WebClient's `ClientResponse`, and we have similar workarounds in other places.  We cannot change `HttpStatus` from a enum to a class like we did for `HttpMethod` in #27697, because `HttpStatus` is used in the `ResponseStatus` annotation, where class instances can not be used as values.  @philwebb suggested that we can introduce a new interface `HttpStatusCode`, which is implemented by `HttpStatus`. Code that currently returns a `HttpStatus` will return this new `HttpStatusCode` instead, and we will deprecate the methods that return the raw status codes. All methods that *accepts* the raw integer values will still be available, we will only deprecate the integer returning methods.  Instances of the `HttpStatusCode` are obtained via static `valueOf(int)` factory method, which returns a `HttpStatus` enum entry if one is available for the given integer, and a default implementation otherwise. This way, we can assure that `HttpStatus`  instance comparisons  (i.e. `if (statusCode == HttpStatus.OK)`) will keep working as they currently do.","closed","type: enhancement,","poutsma","2022-03-22T11:00:49Z","2022-03-23T12:50:00Z"
"","28236","Support multiple segments in encoded Content-Disposition","According to  [Rfc6266](https://datatracker.ietf.org/doc/html/rfc6266) / [Appendix C.1 RFC 2047](https://datatracker.ietf.org/doc/html/rfc2047)  (MIME Part Three: Message Header Extensions for Non-ASCII Text), [Section 2. Syntax of encoded-words ( page 3 )](https://datatracker.ietf.org/doc/html/rfc2047#section-2) :  > An 'encoded-word' may not be more than 75 characters long, including >    'charset', 'encoding', 'encoded-text', and delimiters.  If it is >    desirable to encode more text than will fit in an 'encoded-word' of >    75 characters, multiple 'encoded-word's (separated by CRLF SPACE) may >    be used. >  Original pull request : https://github.com/spring-projects/spring-framework/pull/26463 , try to decode base64 encoded filename, but he forget there is more segments case.  And thanks @guangtuan find it.","closed","type: enhancement,","lxbzmy","2022-03-27T02:49:56Z","2022-04-29T10:44:29Z"
"","28885","Fix typos in Javadoc of class AbstractEncoder","AbstractEncoder is a Encoder implementations.","closed","type: documentation,","edfeff","2022-07-29T05:29:54Z","2022-07-29T07:32:35Z"
"","28516","Bean definition contribution includes attributes that are not used at runtime","A typical `@Configuration`-annotated bean include a `org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass` attribute in generated code. This attribute is useless at runtime and should not be contributed.  In Spring Native, we took the decision of not writing those attributes and that didn't seem to matter so I don't know how much of those attributes are required.   cc @philwebb","closed","theme: aot,","snicoll","2022-05-24T09:42:21Z","2022-07-27T13:02:37Z"
"","28433","Make inner classes static when feasible","A static nested class does not keep an implicit reference to its enclosing instance.  This prevents a common cause of memory leaks and uses less memory per instance of the class.","closed","in: core,","missingdays","2022-05-09T19:40:21Z","2022-05-10T10:20:57Z"
"","28068","Add support for parse gzip encoded response with RestTemplate in Spring-Web","a simple method make RestTemplate support parse gzip encoded response  just change **_org.springframework.web.client.MessageBodyClientHttpResponseWrapper_** old code is  ```java      @Override     public InputStream getBody() throws IOException { 	return (this.pushbackInputStream != null ? this.pushbackInputStream : this.response.getBody());     } ``` now code is  ```java     @Override     public InputStream getBody() throws IOException {         if (isGzip()) {             return new GZIPInputStream(getRealBody());         }         return getRealBody();     }      private InputStream getRealBody() throws IOException {         return (this.pushbackInputStream != null ? this.pushbackInputStream : this.response.getBody());     }      private boolean isGzip() {         List contentEncodings = getHeaders().get(""Content-Encoding"");         if (contentEncodings == null || contentEncodings.isEmpty()) {             return false;         }         for (String contentEncoding : contentEncodings) {             if (""gzip"".equalsIgnoreCase(contentEncoding)) {                 return true;             }         }         return false;     } ```","closed","status: declined,","AMJASH","2022-02-17T09:38:31Z","2022-02-17T10:02:32Z"
"","28809","AOT generated code should consider visibility of FactoryBean target type","A `FactoryBean` using a package private target type `T` leads to compile errors in the generated code when the `FactoryBean` implementation is not in the same package.  Given a package private repository `CustomerRepository` is located in `com.example.data.mongo`, and a factory `BeanDefinition` using `MongoRepositoryFactoryBean` as target results in the following code being generated in the `org.springframework.data.mongodb.repository.support` package, where the `MongoRepositoryFactoryBean` is located.  ```java package org.springframework.data.mongodb.repository.support;  /**  * Bean definitions for {@link MongoRepositoryFactoryBean}  */ public class MongoRepositoryFactoryBean__BeanDefinitions {   /**    * Get the bean definition for 'customerRepository'    */   public static BeanDefinition getCustomerRepositoryBeanDefinition() {     ResolvableType beanType = ResolvableType.forClassWithGenerics(MongoRepositoryFactoryBean.class, CustomerRepository.class, Object.class, Object.class);     RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);     beanDefinition.setLazyInit(false);     beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, ""com.example.data.mongo.CustomerRepository"");     beanDefinition.getPropertyValues().addPropertyValue(""queryLookupStrategyKey"", QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND);     beanDefinition.getPropertyValues().addPropertyValue(""lazyInit"", false);     beanDefinition.getPropertyValues().addPropertyValue(""namedQueries"", new RuntimeBeanReference(""mongo.named-queries#0""));     beanDefinition.getPropertyValues().addPropertyValue(""repositoryFragments"", new RuntimeBeanReference(""mongodb.CustomerRepository.fragments#0""));     beanDefinition.getPropertyValues().addPropertyValue(""mongoOperations"", new RuntimeBeanReference(""mongoTemplate""));     beanDefinition.getPropertyValues().addPropertyValue(""createIndexesForQueryMethods"", false);     beanDefinition.setAttribute(""factoryBeanObjectType"", ""com.example.data.mongo.CustomerRepository"");     beanDefinition.setInstanceSupplier(InstanceSupplier.of(MongoRepositoryFactoryBean__BeanDefinitions::getCustomerRepositoryInstance));     return beanDefinition;   } ```  Visibility checks should consider the generic arguments and potentially guard/load those via reflection.","closed","theme: aot,","christophstrobl","2022-07-13T04:14:53Z","2022-07-22T14:37:43Z"
"","28013","Add support for registering multiple init & destroy method names","A `BeanDefinition` can have an `init` and `destroy` method name. While uncommon, it is possible for a bean to have more than one of those, see `InitDestroyAnnotationBeanPostProcessor`.   To replace the runtime behavior of searching for those annotations, we need a way to specify multiple init and destroy method names. There might be an impact on `isExternallyManagedConfigMember` in `RootBeanDefinition` as well.","closed","theme: aot,","snicoll","2022-02-07T12:14:49Z","2022-02-17T17:14:49Z"
"","28498","Fix attribute return types in `@DeleteExchange`, `@PatchExchange`, and `@PutExchange`","`value` and `url` doesn't match with `HttpExchange` return type.","closed","type: bug,","eddumelendez","2022-05-21T07:55:21Z","2022-05-21T12:38:42Z"
"","28213","Throw a meaningful exception if a TypeReference does not use a fully qualified name","`TypeReference.of(""int"")` fails because a dot is expected in the type name.  ``` begin 0, end -1, length 3 java.lang.StringIndexOutOfBoundsException: begin 0, end -1, length 3 	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4601) 	at java.base/java.lang.String.substring(String.java:2704) 	at org.springframework.aot.hint.SimpleTypeReference.createTypeReference(SimpleTypeReference.java:60) 	at org.springframework.aot.hint.SimpleTypeReference.of(SimpleTypeReference.java:48) 	at org.springframework.aot.hint.TypeReference.of(TypeReference.java:75) ```","closed","in: core,","sdeleuze","2022-03-22T09:16:00Z","2022-03-22T12:31:51Z"
"","28363","MultiStatement#toCodeBlock should be name toLambdaBody","`toCodeBlock` is confusing as it is heavily tailored for adding the code in the context of a lambda. We could use a `toCodeBlock` that actually creates a regular multi-statements code block.","closed","theme: aot,","snicoll","2022-04-21T13:06:54Z","2022-04-25T09:03:42Z"
"","28130","Reconsider fallback date formats for ISO variants in DateTimeFormatterRegistrar","`spring-boot-starter-webflux-2.6.4`  The following controller can take a date in `yyyy-MM-dd` format in a `@PostMapping` request without problems, but fails for a `@GetMapping` query parameter.  ```java @RestController public class DateTimeServlet {         static class DateTimeDto {         private LocalDate date;         //getter, setter     }      @PostMapping(""/datetime"")     public Mono datetimePost(@RequestBody DateTimeDto dto) {         return Mono.just(""OK"");     }      @GetMapping(""/datetime"")     public Mono datetimeGet(DateTimeDto dto) {         return Mono.just(""OK);     } } ```  Works:  ``` POST localhost:8080/datetime {     ""date"": ""2022-02-02"" } ```  Does not work:  ``` GET localhost:8080/datetime?date=2022-02-02 ```  Result:  ```json {     ""timestamp"": ""2022-03-03T08:57:56.248+00:00"",     ""status"": 400,     ""message"": ""'date': : Parse attempt failed for value [2022-02-02]. rejectedValue: 2022-02-02"" } ```  Why are get and post requests behaving that differently? Shouldn't either both succeed, or both fail?  Update: while I discovered that POST bodies are converted using `jackson`, and GET parameters using Spring Conversation Service, I wonder if it wouldn't be better that both could have the same behavior?","closed","type: enhancement,","membersound","2022-03-03T09:18:07Z","2022-03-03T14:13:48Z"
"","28210","Introduce TestSocketUtils as a replacement for SocketUtils","`SocketUtils` was officially deprecated in 5.3.16 (#28052) and removed in 6.0 M3 (#28054); however, there is still need for a subset of this functionality in integration tests for testing scenarios in which it is not possible for the system under test to select its own random port (or rely on the operating system to provide an ephemeral port).  We will therefore introduce a scaled down version in `spring-test` called `TestSocketUtils`, supporting retrieval of a single TCP port, and potentially with a simple retry mechanism that allows test code using the available port to be retried a given number of times if an exception is thrown.","open","type: enhancement,","sbrannen","2022-03-21T16:57:50Z","2022-04-09T15:09:32Z"
"","28052","Deprecate SocketUtils","`SocketUtils` was introduced in Spring Framework 4.0, primarily to assist in writing integration tests which start an external server on an available random port.  However, these utilities make no guarantee about the subsequent availability of a given port and are therefore unreliable.  Instead of using `SocketUtils` to find an available local port for a server, it is recommended that users rely on a server's ability to start on a random port that it selects or is assigned by the operating system. To interact with that server, the user should query the server for the port it is currently using.","closed","type: enhancement,","sbrannen","2022-02-15T11:30:17Z","2022-03-21T16:59:17Z"
"","28234","Move off deprecated API in `SessionTransactionData`","`SessionTransactionData` in `HibernateJpaDialect` still refers to `Session.setFlushMode(FlushMode)` which was deprecated and now removed with Hibernate 6.0 CR2. Other code in `HibernateJpaDialect` already uses the suggested alternative `setHibernateFlushMode(…)`.","closed","type: bug,","odrotbohm","2022-03-25T16:36:03Z","2022-03-25T17:19:56Z"
"","28246","Introduce warnings in documentation of SerializationUtils","`SerializationUtils#deserialize` is deprecated in Spring Framework 6.0 (see #28075); however, we do not want to deprecate this utility so late in the `5.3.x` line.  So we are creating this issue and adding warnings to the Javadoc for `SerializationUtils` to raise awareness in `5.3.x`.","closed","in: core,","sbrannen","2022-03-29T13:19:40Z","2022-03-29T13:29:50Z"
"","28383","Generate appropriate AOT bean registration for scoped proxies","`ScopedProxyFactoryBean` are not handled property in an AOT optimized  context. As a result, such a bean cannot be injected properly.","closed","theme: aot,","snicoll","2022-04-26T11:33:50Z","2022-04-26T13:15:58Z"
"","28528","Proxy hint missing when `AliasFor` is used on the annotation itself","`RuntimeHintsUtils#registerAnnotation` will not register a proxy hint for an annotation using `@AliasFor` against a local attribute. This leads to issues in a native environment:  ``` Caused by: com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by interfaces [interface org.springframework.web.bind.annotation.RequestMapping, interface org.springframework.core.annotation.SynthesizedAnnotation] not found. Generating proxy classes at runtime is not supported. Proxy classes need to be defined at image build time by specifying the list of interfaces that they implement. To define proxy classes use -H:DynamicProxyConfigurationFiles= and -H:DynamicProxyConfigurationResources= options. ```","closed","theme: aot,","snicoll","2022-05-26T13:10:35Z","2022-05-26T13:58:22Z"
"","28342","Allow to register AotContributingBeanFactoryPostProcessor declaratively","`RuntimeHintsPostProcessor` is one of its kind. There are actually more needs like this.","closed","theme: aot,","snicoll","2022-04-14T13:09:28Z","2022-04-14T13:14:01Z"
"","28595","Support RouterFunction ordering in Spring MVC","`RouterFunctionMapping` in Spring MVC does not support ordering. By comparison, the WebFlux `RouterFunctionMapping` does, refactored in #21861 to use `ObjectProvider`, but always had the support for it.   This was uncovered in https://github.com/spring-projects/spring-graphql/issues/404.","closed","type: bug,","rstoyanchev","2022-06-09T09:59:00Z","2022-06-14T11:21:20Z"
"","28608","Issue with `equals(…)`/`hashCode()` for `ResolvableType.forRawClass(…)`","`ResolvableType.forRawClass(…)` returns an anonymous subclass of `ResolvableType` that alters its behavior but does not override `equals(…)`/`hashCode()` so that instances created through that method are considered the same as ones created via `forClass(…)` despite different behavior when trying to resolve generics. This fundamentally breaks the ability to use `ResolvableType` instances that are potentially created in both ways as map or cache keys.","open","type: enhancement,","odrotbohm","2022-06-10T17:09:38Z","2022-06-14T20:35:48Z"
"","28776","ResolvableType.forInstance should return NONE for null instance","`ResolvableType.forInstance(Object)` enforces a not-null argument which makes it unpleasant to use with input that can come from a nullable source (or even just an API call which in some circumstances may return `null` and is therefore marked as `@Nullable`, even if never actually `null` in a given usage scenario). A more usage-friendly variant is to accept `null` but turn it into `ResolvableType.NONE`.","closed","type: enhancement,","jhoeller","2022-07-08T08:30:46Z","2022-07-13T09:20:54Z"
"","28572","Update reference docs to use PropertySourcesPlaceholderConfigurer","`PropertyPlaceholderConfigurer` has been deprecated as of Spring 5.2, in favor of `PropertySourcesPlaceholderConfigurer`, according to the doc comments following:  https://github.com/spring-projects/spring-framework/blob/305055d6b1a42c7795891b7b389936ed80270505/spring-beans/src/main/java/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.java#L52-L54","closed","type: documentation,","gorisanson","2022-06-06T10:29:18Z","2022-06-07T06:31:34Z"
"","28607","Use PathPatternParser by default in Spring MVC","`PathPatternParser` was introduced for WebFlux in 5.0 as a replacement for `AntPathMatcher` that uses pre-compiled patterns, supports mapping without decoding the full URL path, and optimizes the pattern syntax for web (vs file system) paths.   It has been available for use in Spring MVC since version 5.3 and has been enabled as the default in Spring Boot since version 2.6 with https://github.com/spring-projects/spring-boot/issues/24805.  This issue is to consider switching the default in Spring Framework to `PathPatternParser` for 6.0, and potentially deprecate `PathMatcher` and related options.","closed","type: enhancement,","rstoyanchev","2022-06-10T14:18:07Z","2022-06-29T10:07:30Z"
"","28475","AOT contribution for @EventListener","`org.springframework.context.event.internalEventListenerProcessor` and `org.springframework.context.event.internalEventListenerFactory` are the last two remaining annotation-based processors that are contributed to an AOT context. We should detect and register the listeners at build-time so that these beans are no longer necessary.","open","theme: aot,","snicoll","2022-05-18T13:25:07Z","2022-06-21T05:26:04Z"
"","28563","Use a single `--initialize-at-build-time` parameter per file","`native-image.properties` supports specifying a single `--initialize-at-build-time` parameter with multiple packages separated with `,`. This issue intend to use this capability since:  - This is usually the recommended way to specify multiple packages.  - This is consistent with the generated configuration.  - It allows to group per module `--initialize-at-build-time` when passed to the `native-image` command.","closed","in: core,","sdeleuze","2022-06-03T15:38:43Z","2022-06-03T15:41:09Z"
"","27921","Implement an AOT equivalent of AutowiredAnnotationBeanPostProcessor","`InjectionMetadata`  provides some information we could use at build-time. For instance, if `AutowiredAnnotationBeanPostProcessor` is enabled for the `ApplicationContext` that app uses without AOT, we should be able to find out about `autowired` elements, potentially even reusing any custom configuration that was set on the post processor.  There is also some logic in the way injection works that we may need to streamline to be consistent.","closed","theme: aot,","snicoll","2022-01-11T15:21:32Z","2022-02-15T12:34:15Z"
"","28345","`StrictHttpFirewall` throws `RequestRejectedException` by `StrictFirewalledRequest` which wraps ...","`HttpServeltRequest`, but `RequestRejectedException` cannot be handled in `RequestRejectedHandler`.  I get this error when I send the following request from the server I'm developing. (I discovered this while monitoring.) ```sh $ curl --location --request POST 'http://localhost:8080/_search' \ --header 'Content-Type: application/x-www-form-urlencoded' \ --data-raw '{     ""size"": 1,     ""query"": {       ""filtered"": {         ""query"": {           ""match_all"": {           }         }       }     },     ""script_fields"": {         ""command"": {             ""script"": ""import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\""cat /etc/passwd\"").getInputStream()).useDelimiter(\""\\\\A\"").next();""         }     } }' ```       Detail Logs  ```text 2022-04-15 13:35:34.355 DEBUG 91192 --- [,,,] [nio-8060-exec-2] o.s.web.servlet.DispatcherServlet        : Failed to complete request: org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the parameter name ""{     ""size"": 1,     ""query"": {       ""filtered"": {         ""query"": {           ""match_all"": {           }         }       }     },     ""script_fields"": {         ""command"": {             ""script"": ""import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\""cat /etc/passwd\"").getInputStream()).useDelimiter(\""\\\\A\"").next();""         }     } }"" is not allowed. 2022-04-15 13:35:34.364 ERROR 91192 --- [,,,] [nio-8060-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the parameter name ""{     ""size"": 1,     ""query"": {       ""filtered"": {         ""query"": {           ""match_all"": {           }         }       }     },     ""script_fields"": {         ""command"": {             ""script"": ""import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\""cat /etc/passwd\"").getInputStream()).useDelimiter(\""\\\\A\"").next();""         }     } }"" is not allowed.] with root cause  org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the parameter name ""{     ""size"": 1,     ""query"": {       ""filtered"": {         ""query"": {           ""match_all"": {           }         }       }     },     ""script_fields"": {         ""command"": {             ""script"": ""import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\""cat /etc/passwd\"").getInputStream()).useDelimiter(\""\\\\A\"").next();""         }     } }"" is not allowed. 	at org.springframework.security.web.firewall.StrictHttpFirewall$StrictFirewalledRequest.validateAllowedParameterName(StrictHttpFirewall.java:758) 	at org.springframework.security.web.firewall.StrictHttpFirewall$StrictFirewalledRequest.getParameterMap(StrictHttpFirewall.java:700) 	at org.springframework.web.servlet.DispatcherServlet.lambda$logRequest$2(DispatcherServlet.java:990) 	at org.springframework.core.log.LogFormatUtils.traceDebug(LogFormatUtils.java:114) 	at org.springframework.web.servlet.DispatcherServlet.logRequest(DispatcherServlet.java:979) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:681) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at io.sentry.spring.SentryUserFilter.doFilterInternal(SentryUserFilter.java:56) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:204) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:354) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:267) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:96) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at io.sentry.spring.SentrySpringFilter.doFilterInternal(SentrySpringFilter.java:62) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) 	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) 	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) 	at ch.qos.logback.access.tomcat.LogbackValve.invoke(LogbackValve.java:256) 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360) 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:889) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1743) 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) 	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) 	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) 	at java.base/java.lang.Thread.run(Thread.java:829) ```    It cannot handle `RequestRejectedException` because `FrameworkServlet` converts it to `NestServletException` if an exception is thrown during processing after `DispatcherServlet`. See https://github.com/spring-projects/spring-framework/blob/main/spring-webmvc/src/main/java/org/springframework/web/servlet/FrameworkServlet.java#L1003...L1013  I made a simple filter to solve this simply.  ```java @Component @Order(0) public class RequestRejectedExceptionDetectionFilter implements Filter {      private static final Logger logger = LoggerFactory.getLogger(RequestRejectedExceptionDetectionFilter.class);     @Override     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)             throws ServletException, IOException {          try {             chain.doFilter(request, response);         } catch (ServletException e) {             Throwable rootCause = e.getRootCause();             if (rootCause instanceof RequestRejectedException) {                 logger.debug(""Convert to RequestRejectedException from ServletException"");                 throw new RequestRejectedException(rootCause.getMessage());             }             throw e;         }     } } ```  But I think we need a clearer solution than this. what do you think? 🤔","open","status: waiting-for-triage,","heowc","2022-04-15T04:51:44Z","2022-04-15T04:52:28Z"
"","28146","WebSocketConfigurationSupport.DefaultSockJsSchedulerContainer is private and exposed as a Bean","`defaultSockJsSchedulerContainer()` is a package protected method that exposes a type that is private. This makes it impossible to create a programmatic equivalent of this configuration arrangement.","closed","type: bug,","snicoll","2022-03-08T15:55:25Z","2022-03-09T15:40:09Z"
"","28287","Allow to provide a pre-computed scan PersistenceUnitManager","`DefaultPersistenceUnitManager` is quite classpath-scanning centric. With AOT, we'd like to invoke the scanning of the classpath at build-time and generate a representation of the entities that should be contributed in the `PersistenceUnit`.  We have a similar problem in Spring Boot with other data stores that is being investigated in https://github.com/spring-projects/spring-boot/issues/30523. The solution there is to have some sort of contract where one implementation is the scanning logic, and another that provides values straight away.  I don't know if that would apply here.  The purpose of this issue is to investigate how we could swap this logic when AOT runs so that it uses an hard-coded list, while providing the list to 3rd parties that might need it at build time for further processing","open","theme: aot,","snicoll","2022-04-05T08:24:58Z","2022-07-08T15:10:10Z"
"","28728","Support by-type constructor references in `ConstructorOrFactoryMethodResolver`","`ConstructorOrFactoryMethodResolver` supports type various constructor argument types such as by-name references through inspecting `BeanReference`. It would be neat to also support `RuntimeBeanReference` with a `Class` argument to lookup beans by their type rather than just the type name. Having by-type references that work similar to the non-AOT runtime arrangement would simplify bean definitions.  FWIW, a `RuntimeBeanReference` leads to the following exception:  ``` Exception in thread ""main"" org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'org.springframework.data.mongodb.core.mapping.MongoMappingContext' available 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:862) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1302) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getType(AbstractBeanFactory.java:691) 	at org.springframework.beans.factory.aot.ConstructorOrFactoryMethodResolver.determineParameterValueType(ConstructorOrFactoryMethodResolver.java:137) 	at org.springframework.beans.factory.aot.ConstructorOrFactoryMethodResolver.determineParameterValueTypes(ConstructorOrFactoryMethodResolver.java:125) 	at org.springframework.beans.factory.aot.ConstructorOrFactoryMethodResolver.resolve(ConstructorOrFactoryMethodResolver.java:84) 	at org.springframework.beans.factory.aot.ConstructorOrFactoryMethodResolver.resolve(ConstructorOrFactoryMethodResolver.java:436) 	at org.springframework.beans.factory.aot.BeanDefinitionMethodGenerator.(BeanDefinitionMethodGenerator.java:73) 	at org.springframework.beans.factory.aot.BeanDefinitionMethodGeneratorFactory.getBeanDefinitionMethodGenerator(BeanDefinitionMethodGeneratorFactory.java:91) 	at org.springframework.beans.factory.aot.BeanRegistrationsAotProcessor.processAheadOfTime(BeanRegistrationsAotProcessor.java:44) 	at org.springframework.beans.factory.aot.BeanRegistrationsAotProcessor.processAheadOfTime(BeanRegistrationsAotProcessor.java:32) 	at org.springframework.context.aot.BeanFactoryInitializationAotContributions.getContributions(BeanFactoryInitializationAotContributions.java:67) 	at org.springframework.context.aot.BeanFactoryInitializationAotContributions.(BeanFactoryInitializationAotContributions.java:49) 	at org.springframework.context.aot.BeanFactoryInitializationAotContributions.(BeanFactoryInitializationAotContributions.java:44) 	at org.springframework.context.aot.ApplicationContextAotGenerator.generateApplicationContext(ApplicationContextAotGenerator.java:53) 	at org.springframework.boot.AotProcessor.performAotProcessing(AotProcessor.java:150) 	at org.springframework.boot.AotProcessor.process(AotProcessor.java:111) 	at org.springframework.boot.AotProcessor.main(AotProcessor.java:221) ```","closed","theme: aot,","mp911de","2022-06-29T13:20:21Z","2022-06-29T15:04:04Z"
"","28517","Ambiguous behavior for ClassNameGenerator::generateClassName","`ClassNameGenerator` has two variants for the `generateClassName` feature. One that takes a target `Class` and another that takes a target `String`. I'm a bit confused by the concept of a target here and I think we should explain that a bit more in the javadocs.  These methods also have different behavior:  ```java ClassName first = this.generator.generateClassName(java.io.InputStream.class, ""bytes""); // will result in java.io.InputStream__Bytes  ClassName first = this.generator.generateClassName(""java.io.InputStream"", ""bytes""); // will result in __.JavaIoInputStream__Bytes ```  Even if the difference of behavior is intended, the name and docs are very similar. Also, a common use case for the `ClassNameGenerator` is about generating sources in a specific package to work around visibility issues. The second variant can make this case more difficult to achieve.  As a side note, this class is also referring to the now defunct `@see GeneratedClassName`.  cc @philwebb @snicoll","closed","theme: aot,","bclozel","2022-05-24T11:52:11Z","2022-06-20T09:17:05Z"
"","28029","Make BeanDefinitionValueResolver public","`BeanDefinitionValueResolver` is package private at the moment and the AOT engine could use calling it directly to resolve constructur arguments typically.   We could also improve the current usage where a default `TypeConverter` can be provided by default as the current pattern uses a protected method of the bean factory to initialize it.","closed","theme: aot,","snicoll","2022-02-10T13:59:54Z","2022-02-10T15:02:31Z"
"","28570","BeanDefinitionPropertiesCodeGenerator should filter single inferred init/destroy method","`BeanDefinitionPropertiesCodeGenerator` currently generates `setInitMethodNames()/setDestroyMethodNames()` methods with not parameters if only a single `AbstractBeanDefinition.INFER_METHOD` method is specified. Although this is harmless, it doesn't look great so we should just not add the statement.","closed","theme: aot,","philwebb","2022-06-05T23:12:42Z","2022-06-05T23:16:26Z"
"","28585","Rationalize naming strategy in ApplicationContextAotGenerator","`ApplicationContextAotGenerator` uses a `GenerationContext` to analyze an `ApplicationContext`. The generation context provides the necessary infrastructure to generate ""files"" (i.e. source code and resources). It's part of `spring-core`.  As part of this analysis, an `ApplicationContextInitializer` is generated and serves as the entry point for running an optimized version of the specified `ApplicationContext` at runtime. Additional files may be generated and needs extra help in terms of naming conventions.  The current API has a `ClassName` for the `ApplicationContextInitializer` as well as a target `Class` and a `name` for naming conventions purposes. I think that, at the very least, we should gather these in some sort of naming conventions strategy. Because we need to get a reference to the initializer classname, we could return something rather than `void`.  There is the use case that `ApplicationContextGenerator` is called for dedicated contexts (such as the management context in Spring Boot). In this case we want to pass along the `GenerationContext` so that it records all resources/files in a single place and an updated naming strategy.","closed","theme: aot,","snicoll","2022-06-08T12:31:00Z","2022-06-23T14:28:52Z"
"","28525","ApplicationContextAotGenerator should return the initializer class name","`ApplicationContextAotGenerator` doesn't currently return the class name of the generated initializer and it probably should. The method name might also be better as `generateApplicationContextInitializer` since that's what it actually generates.","closed","status: invalid,","philwebb","2022-05-25T22:17:33Z","2022-05-31T17:56:06Z"
"","28866","Clarify which AOT components can be instantiated at build-time","`AotFactoriesLoader#load` is merging entries from `aot.factories` and beans from the context. We're still in the process of determining what should or shouldn't be instantiated at build-time but it looks we're in agreement that it should be limited to certain use cases only whereas load does it for any factory type.","closed","theme: aot,","snicoll","2022-07-25T08:13:54Z","2022-07-28T13:31:58Z"
"","28815","Improve regex ""."" matching for URL paths","`AntPathMatcher` and `PathPattern` support regex expressions but do not use the `DOTALL` option to ignore newline characters in URL paths. We should enable use of that to make path matching more predictable.  Note that this could create a mismatch in path matching between a security layer and Spring MVC or WebFlux, but such a security layer needs to address issues even more broadly, along the lines of Spring Security's [MvcRequestMatcher](https://docs.spring.io/spring-security/reference/servlet/integrations/mvc.html#mvc-requestmatcher) which guarantees alignment with Spring MVC path matching. In addition, Spring Security's firewall rejects newlines and other problematic characters in URL paths to begin with.  We should also update the documentation to provide guidance around this and for example discourage use of `HandlerInterceptor` for security, or even a `Filter`, in favor of Spring Security, or otherwise use a path matching approach similar to that of Spring Security.  This issue is based on a report by @4ra1n.","closed","type: enhancement,","rstoyanchev","2022-07-13T16:19:37Z","2022-07-13T18:24:45Z"
"","28666","Stop using SpringFactoriesLoader.loadFactoryNames in the TestContext framework","`AbstractTestContextBootstrapper.getDefaultTestExecutionListenerClassNames()` is currently the only remaining use of `SpringFactoriesLoader.loadFactoryNames()` in the core Spring Framework.  Since `SpringFactoriesLoader.loadFactoryNames()` will be deprecated in #27954, we should stop using it and remove the `getDefaultTestExecutionListenerClassNames()` method from `AbstractTestContextBootstrapper`.   We should likely remove `getDefaultTestExecutionListenerClasses()` as well and refactor `getTestExecutionListeners()` to make use of the new `FailureHandler` support in `SpringFactoriesLoader`.","closed","theme: aot,","sbrannen","2022-06-20T18:07:33Z","2022-06-24T18:05:09Z"
"","28663","Wrong reflection hints for arrays of inner types","```java hints.reflection().registerType(com.zaxxer.hikari.util.ConcurrentBag.IConcurrentBagEntry[].class, hint -> {}); ```  generates  ```json {   ""name"": ""com.zaxxer.hikari.util.IConcurrentBagEntry[]"" }, ```  but should generate  ```json {   ""name"": ""com.zaxxer.hikari.util.ConcurrentBag$IConcurrentBagEntry[]"" }, ```  `IConcurrentBagEntry` is an inner interface of `ConcurrentBag`.  I'm going to contribute a PR to fix this.","closed","theme: aot,","mhalbritter","2022-06-20T12:39:23Z","2022-06-20T13:52:17Z"
"","28310","Add new header method #28309","```Java @Override public DefaultRequestBodyUriSpec header(String headerValue) { 	String[] header = headerValue.split("":""); 	getHeaders().add(header[0], header[1]); 	return this; } ``` Users can add headers using only one parameter.  If there are any mistakes, please comment. Thanks!","closed","status: declined,","SonYoonSeok","2022-04-09T15:10:06Z","2022-04-09T15:47:10Z"
"","28491","Support default methods in `@HttpExchange` interface","```java @HttpExchange(""http://localhost:8080"") public interface GreetingClient {      @GetExchange(""/greeting"")     Flux greetings();      @PostExchange(""/greeting"")     Mono greetings(@RequestBody Greeting greeting);      default Flux defaultMethod() {         return greetings(new Greeting(""default method test""))                 .flatMapMany(it -> greetings());     } } ```  defaultMethod method I hope it works!","closed","type: enhancement,","wonwoo","2022-05-20T01:59:58Z","2022-06-01T17:19:09Z"
"","28894","Why in ConfigurationClassPostProcessor.processConfigBeanDefinitions  need if (registry.getBeanDefinitionCount() > candidateNames.length) {} judge","````  @Import({SimpleStart.MemberClass.class}) public class SimpleStart {      public SimpleStart(ExampleBean exampleBean) {      }       static class MemberClass implements ImportBeanDefinitionRegistrar {         private Environment environment;          public MemberClass(Environment environment) {             this.environment = environment;         }          @Override         public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {             if(environment.getProperty(""new-config.enable"", Boolean.class,false)){                 registry.removeBeanDefinition(""oldBeanConfig"");                 registry.registerBeanDefinition(NewBeanConfig.class.getName(), BeanDefinitionBuilder.genericBeanDefinition(NewBeanConfig.class).getBeanDefinition());             }         }     }  }  public class NewBeanConfig {     @Bean     ExampleBean exampleBean(){         return new ExampleBean();     } }      public class OldBeanConfig{  }  public class ExampleBean {  }   ````  ```` @Test public void research(){      System.setProperty(""new-config.enable"",""true"");     AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SimpleStart.class,OldBeanConfig.class);     ExampleBean bean = context.getBean(ExampleBean.class);  } ```` The above code will cause the ExampleBean to not be obtained,When I saw ConfigurationClassPostProcessor source code,I found processConfigBeanDefinitions method have if (registry.getBeanDefinitionCount() > candidateNames.length) {} lead to no more process NewBeanConfig ConfigClass.I don't see why did it.","closed","status: invalid,","kse-music","2022-07-30T16:24:56Z","2022-08-01T07:32:05Z"
"","28673","AcceptHeaderLocaleContextResolver Resolution Error","``` @Test public void resolvePreferredAgainstLanguageOnly() {     this.resolver.setSupportedLocales(Arrays.asList(GERMANY, US));     assertThat(this.resolver.resolveLocaleContext(exchange(UK, ENGLISH)).getLocale()).isEqualTo(US); }  ```  This test should _pass_.  If a client requests `en-GB, en` and the supported locales are `de-DE, en-US` then this should resolve to US because `en` (English of any kind) matches `en-US` (US English).  Instead it incorrectly resolves to `en-GB`.  Note: There is an existing test with the same name that I believe has this wrong:  ``` @Test public void resolvePreferredAgainstLanguageOnly() {     this.resolver.setSupportedLocales(Collections.singletonList(ENGLISH));     assertThat(this.resolver.resolveLocaleContext(exchange(GERMANY, US, UK)).getLocale()).isEqualTo(ENGLISH); } ```  This test _should_ also pass but not because it ""matches"" -- it should resolve to ENGLISH because that's the only supported locale.  This affects all versions.","open","status: waiting-for-triage,","chulbert","2022-06-21T17:52:21Z","2022-06-21T17:58:04Z"
"","28600","Remove obsolete references to @Required","`@Required` was removed in a previous 6.0 milestone.","closed","type: documentation,","sbrannen","2022-06-09T12:51:41Z","2022-06-09T12:54:59Z"
"","28235","@RequestScope feature for Reactive Web","`@RequestScope` is a specialization of `@Scope` for a component whose lifecycle is bound to the current web request. In spring WebFlux the use of this annotation cause a:  > No Scope registered for scope name 'request'  It would be nice have the same feature/annotation in WebFlux to bind the life of a component with the current web request. Currently, I don't think it's possible achieve this behaviour in WebFlux in a simple way (like using an annotation).","open","status: waiting-for-triage,","SimoneGiusso","2022-03-26T19:53:25Z","2022-03-28T09:25:47Z"
"","28504","Allow custom HTTP method with @HttpExchange methods","`@HttpExchange` is currently only allowed at the class level for inheriting common attributes, but at the method level one has to choose one of the HTTP method specific shortcut annotations. We can allow it at the method level for custom HTTP methods, or less common ones like OPTIONS which won't need a dedicated shortcut.","closed","type: enhancement,","rstoyanchev","2022-05-23T15:23:25Z","2022-05-24T08:28:41Z"
"","28215","Code generation should not contribute (inferred) destroy method name","`(inferred)` is used as a special method name within the core container. When AOT runs, it should handle that and not write that value.","closed","theme: aot,","snicoll","2022-03-22T11:41:47Z","2022-07-27T09:52:41Z"
"","28839",".status(HttpStatus) ignored on RenderingResponse.create(""redirect:/somewhere"").status(...)","__Version__: `org.springframework:spring-webflux:5.3.21`  __Problem__: When I use `RenderingResponse.create(""redirect:/controller"").status(HttpStatus.FOUND).build()`, the response status is not modified (remains `303 See Other` no matter what).  (`.status(something)` works fine on a non-redirect view: `RenderingResponse.create(""template"").status(something).build()`.)  __Expected Behavior__: When I modify the status of a ""redirect view"", I expect the status to be as directed in the invocation.  __Actual Behavior__: The redirect works fine. However, its status is `303 See Other` no matter what I set it to.  I have a router: ```kt @Configuration class CVRouter(private val controller: CVController) {     @Bean     fun route() = router {         path(""/cvs"").nest {             GET("""", controller::list)             GET(""new"", controller::new)             POST("""", controller::create)         }     } } ```  and a controller: ```kt @Component class CVController(val repository: CVRepository) {     fun list(request: ServerRequest) = RenderingResponse         .create(""cv/list"")         .modelAttribute(""cvs"", repository.findAll())         .build()      fun new(request: ServerRequest) = RenderingResponse         .create(""cv/new"")         .modelAttribute(""cv"", CV(name = ""Test Name""))         .build()      // This does not create anything yet, only testing PRG (Post/Redirect/Get) pattern.     fun create(request: ServerRequest) = RenderingResponse         .create(""redirect:/cvs"")         .status(HttpStatus.FOUND)         .build() } ```","open","in: web,","tgrushka","2022-07-18T19:08:12Z","2022-08-01T09:41:15Z"
"","28816","Guard against NPE in PathMatchConfigurer","[This](https://github.com/spring-projects/spring-framework/blob/7a042062f59deb596e9208ecafebd4a08139dbf0/spring-webmvc/src/main/java/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.java#L156) would cause an NPE if `suffixPatternMatch` is `null`.  ```java Caused by: java.lang.NullPointerException: Cannot invoke ""java.lang.Boolean.booleanValue()"" because ""suffixPatternMatch"" is null 	at org.springframework.web.servlet.config.annotation.PathMatchConfigurer.setUseSuffixPatternMatch(PathMatchConfigurer.java:156) ~[spring-webmvc-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT] 	at com.example.demo.PathMatchingThingyApplication.configurePathMatch(PathMatchingThingyApplication.java:14) ~[main/:na] 	at org.springframework.web.servlet.config.annotation.WebMvcConfigurerComposite.configurePathMatch(WebMvcConfigurerComposite.java:53) ~[spring-webmvc-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT] 	at org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration.configurePathMatch(DelegatingWebMvcConfiguration.java:58) ~[spring-webmvc-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT] 	at org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport.getPathMatchConfigurer(WebMvcConfigurationSupport.java:388) ~[spring-webmvc-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT] 	at org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport.mvcResourceUrlProvider(WebMvcConfigurationSupport.java:614) ~[spring-webmvc-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na] 	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:130) ~[spring-beans-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT] 	... 34 common frames omitted ```  While the API doesn't expect nulls, it's worth investigating whether switching to `boolean` or adding an `Assert` would be possible. Similar case for `registeredSuffixPatternMatch `.","closed","type: bug,","mbhave","2022-07-13T17:09:29Z","2022-07-13T19:24:51Z"
"","28341","Instrument HTTP clients for Observability","[Micrometer 1.10 will bring a new micrometer-observation module](https://github.com/micrometer-metrics/micrometer/wiki/1.10-Migration-Guide) - this will bring a lightweight API designed for instrumenting code for observability (both metrics and tracing concerns).  We'd like to introduce a compile dependency on that in the `spring-web` module, which will allow us to instrument `RestTemplate` and `WebClient`. This should not only make the instrumentation more efficient and focused, but also fix a number of limitations of the current instrumentation contributed in Spring Boot.","open","theme: observability,","bclozel","2022-04-14T11:58:20Z","2022-07-11T07:10:52Z"
"","28752","Upgrade to JUnit 5.9","[JUnit 5.9 RC1](https://twitter.com/junitteam/status/1544048394510950405) has been released.  In light of that, we should upgrade to 5.9 RC1 – to provide early feedback if necessary – and then upgrade to 5.9 GA as soon as it's released (likely in 2-3 weeks).","closed","type: dependency-upgrade,","sbrannen","2022-07-03T19:18:04Z","2022-07-27T08:03:26Z"
"","27952","Range Requests do not take in to account the If-Range header set in the http request","[https://github.com/spring-projects/spring-framework/blob/main/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java](url) The logic to support range requests using ResourceRegions does not seem to consider the If-Range header in http requests.  As per https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Range, this header decides whether partial content should be sent or the full resource needs to be sent back along with appropriate response code.  Currently, this header is ignored and the partial content is always sent with 206 response code","closed","status: invalid,","ab185034","2022-01-19T11:26:47Z","2022-02-02T11:39:57Z"
"","28033","get all placeholder that spring resolved","[enhancements] **Affects:** \  org.springframework.util.PropertyPlaceholderHelper: this is util for replacing the placeholder with environment's value, such as @Value(""${aa${cc:defaultv}}""). but the class not support getting all placeholders that I need, i think it should give a chance to return placeholders, in: `	 protected String parseStringValue( 			String value, PlaceholderResolver placeholderResolver, Set visitedPlaceholders)  ` the items in `Set visitedPlaceholders` would be removed by resolved, I think we could add a new method (with a new Set) to finish it.","closed","","kc910521","2022-02-11T02:52:00Z","2022-02-11T07:42:21Z"
"","28250","Document how to configure the cache infrastructure globally","[@CacheConfig](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache-annotations-config) > An operation-level customization always overrides a customization set on @CacheConfig. Therefore, this gives three levels of customizations for each cache operation: >  > + **Globally configured**, available for CacheManager, KeyGenerator. >  > + At the class level, using @CacheConfig. >  > + At the operation level.  How to do global configuration？","open","type: documentation,","starriesWEB","2022-03-30T06:15:52Z","2022-03-30T15:46:08Z"
"","28253","If request body is missing i want to store null in db","@PutMapping(""/item/categoryId/{srsCustomerId}"")     public ResponseEntity saveOmsFiltersWithCategoryIds(@PathVariable(""srsCustomerId"") Long srsCustomerId, @RequestBody (required=false) List omsFilters) {        if (srsCustomerId != null || omsFilters == null ){            adminBO.saveOmsFiltersWithCategoryId(srsCustomerId, null);        }         try {             if (srsCustomerId != null || omsFilters != null) {                 adminBO.saveOmsFiltersWithCategoryId(srsCustomerId, omsFilters);             }             return ResponseEntity.ok(success());         } catch (Exception e) {              log.error(""Exception trying to save SrsCustomer and SrsOmsFilterId"", e);             e.printStackTrace();             return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();         }     } I have tried above code and it is giving me 500 bad request","closed","","abdullah7435","2022-03-30T11:51:48Z","2022-04-18T13:42:38Z"
"","28156","Initial version with TX, Context Propagation and Observation","@mp911de","open","status: waiting-for-triage,","marcingrzejszczak","2022-03-10T16:15:47Z","2022-03-24T13:52:22Z"
"","28775","@AliasFor may have a bug when dealing with repeated annotations","@Aliasfor 在处理Array类型属性覆盖时,可能导致 AnnotationTypeMapping#validateAllAliasesClaimed() 不通过","closed","in: core,","w547963","2022-07-08T03:39:08Z","2022-07-08T13:31:54Z"
"","28336","HttpHeaders constructor should not be public or should not mutate original HttpHeaders","## Problem  1. When I use HttpHeaders, its constructors confuse me, because instance initialized from original header has same hashmap of original. For example, test code below will be failed. Calling a method of copy instance may affect original instance.  ```java import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; import org.springframework.http.HttpHeaders;  public class HeaderTest {      @Test     void test() {         var original = new HttpHeaders();         var copy = new HttpHeaders(original);          copy.add(""key"", ""value"");          Assertions.assertFalse(original.containsKey(""key""));     } } ```   2. The javadoc says that the constructor I mentioned is for internal use in the spring fremework, but users can access it. https://github.com/spring-projects/spring-framework/blob/c28fd91a10eaeae4c090f4fb9faa89f2f9d34bda/spring-web/src/main/java/org/springframework/http/HttpHeaders.java#L426-L444  ## Suggetion  So I suggest this confusional constructor is package-private not to be accessed from external the library or support immutableness of its hashmap field.","open","status: feedback-provided,","ryoheinagao","2022-04-14T04:14:34Z","2022-05-26T02:38:00Z"
"","28012","Using recursive annotations in Kotlin causes stack overflow","spring boot version: `2.6.3` I have defined several annotations in kotlin similar to the following:  ```kotlin @JvmRepeatable(Bar::class) annotation class Foo(val value: Bar = Bar()) annotation class Bar(vararg val value: Foo) ``` This does not seem to be possible in Java, but kotlin allows it. Then I use it in springboot:  ```kotlin @RestController class HappyController {     @Foo     @Foo     @GetMapping(""/hi"")     fun fine() = ""Hello World"" } ```  I get exceptions at startup:  ``` 2022-02-06 02:35:10.045  INFO 16948 --- [           main] love.bot.forli.MyBot3ApplicationKt       : Starting MyBot3ApplicationKt using Java 17.0.2 on ForteScarlet with PID 16948 (G:\code\javaProjects\my-bot3\bot\build\classes\kotlin\main started by forte in G:\code\javaProjects\my-bot3) 2022-02-06 02:35:10.048  INFO 16948 --- [           main] love.bot.forli.MyBot3ApplicationKt       : The following profiles are active: dev 2022-02-06 02:35:10.295  WARN 16948 --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [G:\code\javaProjects\my-bot3\bot\build\classes\kotlin\main\love\bot\forli\business\say\HappyController.class]; nested exception is java.lang.StackOverflowError 2022-02-06 02:35:10.438 ERROR 16948 --- [           main] o.s.boot.SpringApplication               : Application run failed  org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [G:\code\javaProjects\my-bot3\bot\build\classes\kotlin\main\love\bot\forli\business\say\HappyController.class]; nested exception is java.lang.StackOverflowError 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents(ClassPathScanningCandidateComponentProvider.java:457) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:316) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:276) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ComponentScanAnnotationParser.parse(ComponentScanAnnotationParser.java:128) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:296) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:250) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:207) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:175) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:331) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:247) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:311) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:112) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:746) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:564) ~[spring-context-5.3.15.jar:5.3.15] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:732) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:414) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:302) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1303) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1292) ~[spring-boot-2.6.3.jar:2.6.3] 	at love.bot.forli.MyBot3ApplicationKt.main(MyBot3Application.kt:36) ~[main/:na] Caused by: java.lang.StackOverflowError: null 	at org.springframework.util.ConcurrentReferenceHashMap.getHash(ConcurrentReferenceHashMap.java:222) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.util.ConcurrentReferenceHashMap.getReference(ConcurrentReferenceHashMap.java:264) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.util.ConcurrentReferenceHashMap.get(ConcurrentReferenceHashMap.java:235) ~[spring-core-5.3.15.jar:5.3.15] 	at java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:329) ~[na:na] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:198) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:182) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:169) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.computeSynthesizableFlag(AnnotationTypeMapping.java:343) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:106) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:112) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:68) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:245) ~[spring-core-5.3.15.jar:5.3.15] 	at java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[na:na] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:241) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:199) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:182) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:169) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.computeSynthesizableFlag(AnnotationTypeMapping.java:343) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:106) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:112) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:68) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:245) ~[spring-core-5.3.15.jar:5.3.15] 	at java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[na:na] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:241) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:199) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:182) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:169) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.computeSynthesizableFlag(AnnotationTypeMapping.java:343) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:106) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:112) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:68) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.createMappings(AnnotationTypeMappings.java:245) ~[spring-core-5.3.15.jar:5.3.15] 	at java.base/java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:330) ~[na:na] 	at org.springframework.core.annotation.AnnotationTypeMappings$Cache.get(AnnotationTypeMappings.java:241) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:199) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:182) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.forAnnotationType(AnnotationTypeMappings.java:169) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.computeSynthesizableFlag(AnnotationTypeMapping.java:343) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMapping.(AnnotationTypeMapping.java:106) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addIfPossible(AnnotationTypeMappings.java:112) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.addAllMappings(AnnotationTypeMappings.java:75) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:68) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.core.annotation.AnnotationTypeMappings.(AnnotationTypeMappings.java:46) ~[spring-core-5.3.15.jar:5.3.15] ```","closed","in: kotlin,","ForteScarlet","2022-02-05T18:37:56Z","2022-06-14T09:57:24Z"
"","28325","WebSocketSession should raise an exception if an operation is not supported","JettyWebSocketSession.setTextMessageSizeLimit/setBinaryMessageSizeLimit has an empty function body, and the comment says:""it is a no-op for Jetty. As per Session.getPolicy(), the returned WebSocketPolicy is read-only and changing it has no effect."",so I think it would be better to raise an exception as it's not supported in Jetty rather than just do nothing.It may cause an unexcepted issue and hard to find out what's going on there.","open","status: waiting-for-triage,","asypost","2022-04-11T07:48:28Z","2022-04-11T12:51:46Z"
"","27973","Issue with WebSocket transport compression for RSocket","Unable to make WebSocket transport compression work in RSocket client/server Spring Boot applications running with Netty backend and Spring Boot version 2.5.9.  The Spring Boot allows to specify the server-side RSocket transport and endpoint path in the application.properties, but there are no any additional configuration parameters available besides that. The autoconfig creates an instance of the `RSocketWebSocketNettyRouteProvider` which doesn't have compression enabled and also doesn't have any customizers to enable it.  To get around that I removed `spring.rsocket.server.mapping-path` property and declared a bean like this in the server config to pass a `WebsocketServerSpec` with compress option enabled to `httpServerRoutes.ws(...)` call:  ```     @Bean     NettyRouteProvider rSocketWebsocketRouteProvider(             RSocketProperties properties, RSocketMessageHandler messageHandler,             ObjectProvider customizers) {         return new NettyRouteProvider() {             public HttpServerRoutes apply(HttpServerRoutes httpServerRoutes) {                 RSocketServer server = RSocketServer.create(messageHandler.responder());                 customizers.forEach((customizer) -> customizer.customize(server));                  return httpServerRoutes.ws(""/rsocket"",                         WebsocketRouteTransport.newHandler(server.asConnectionAcceptor()),                         WebsocketServerSpec.builder().compress(true).build());             }         };     } ```  On the client side I'm creating `RSocketRequester` like this:  ``` RSocketRequester requester = builder                 .setupRoute(""/backend/connect"")                 .setupData(id)                 .rsocketConnector(connector -> connector                         .reconnect(Retry.fixedDelay(Integer.MAX_VALUE, Duration.ofSeconds(5)))                         .acceptor(RSocketMessageHandler.responder(strategies, backendController)) // ****** (1)                 )                 .dataMimeType(MediaType.APPLICATION_JSON)                 .transport(() -> {                     // httpClient is immutable - baseUrl() creates a copy                     ClientTransport t = WebsocketClientTransport.create(                                 HttpClient.create().baseUrl(backendUrl), ""/rsocket"")                             .webSocketSpec(configurer -> configurer                                     .compress(true) // ****** (2)                                     .maxFramePayloadLength(65536));                     return t.connect();                 }); ```  The `webSocketSpec` need to have compress flag enabled. Otherwise I don't see compression applied when looking at the traffic in Charles proxy with a simple port forwarding enabled.  The problem is that when compress is enabled on line (2) the client can't complete the connection sequence. However if I comment out the `.acceptor()` configuration on line (1) the connect is working and I see server to client calls going through and I can see data is being compressed. But without the acceptor server can't call the client.  Here is an example project repository https://github.com/maximdim/rsocket2/tree/rsocket-compression You can launch `BackendApplication` and `AgentApplication` to observe described issue.","closed","for: external-project,","ekuleshov","2022-01-20T20:25:15Z","2022-03-28T16:43:38Z"
"","28782","Can not rollback transaction in Mono.zip(...) when use several reactive transaction managers","Currently in project we have separate configured r2dbc connection factories to different schemas in db.  And have several reactive transaction managers.  We met the next issue: with an open transaction through the first transaction manager, we execute Mono.zip to merge two streams. First one work with first db shema (in opened transaction), the second one - with another db schema and open separate transaction through the second transaction manager. And in case of any runtime exception in first stream we get  ### Expected Behavior: rollback both transactions ### Actual Behavior: Second transaction rollbacked, but the first one throw exception on rollback: `java.lang.IllegalStateException: Transaction synchronization is not active`.  ### Reason: Seems like as on exception in the first stream from Mono.zip, the second stream is canceled and clears synchronizations in common TransactionContext. As `synchronizations` is null then first transaction is failed on rollback.  Example to reproduce can be found here https://github.com/RomanPilyutik/spring-tx-issue. Just run SynchronizaionsApplicationTests.  org.springframework.boot: 2.6.3 kotlin: 1.6.0 reactor-core 3.4.14","open","status: waiting-for-triage,","RomanPilyutik","2022-07-10T17:52:08Z","2022-07-12T09:37:22Z"
"","28667","ReactiveSessionRepository getting delayed for initialization","**Affects:** spring-web-5.3.9 --- Currently ReactiveSessionRepository in memory repository reflects change in delayed fashion.  Means, If we add any attribute to session inside WebFilter and call the controller for first time, this repository is getting populated after returning from controller call.","closed","for: external-project,","javatype","2022-06-20T22:49:54Z","2022-06-21T15:43:30Z"
"","28168","ProxyExchange discards all incoming request headers when making a request with a body.","**Affects:** spring-cloud-gateway-webflux:3.1.1  ---  **Setup** Define an MVC RestController that accepts a ProxyExchange as an argument to a request handler method, and use the ProxyExchange object to issue a POST request (or any request that contains a body) to an upstream service, using a body created (or manipulated) in the request handler method.  **Expected Behaviour** The ProxyExchange forwards the original request headers, minus filtered sensitive headers, and Content related headers in the upstream request.  **Observed Behaviour** The ProxyExchange discards all original incoming headers, appending only the X-Forwarded-For and X-Forwarded-Proto headers. This behaviour is in contrast to the behaviour observed when using a ProxyExchange object to make requests to upstream services  that do not contain bodies (GET, OPTIONS, etc).","closed","for: external-project,","ericyanush","2022-03-11T20:41:22Z","2022-03-11T20:48:12Z"
"","28408","Unexpected and inconsistent behavior when dealing with Kotlin data classes and null values in a request body","**Affects:** spring-boot 2.6.7  ### Expected Behavior  I would expect that:  - if I use a `Kotlin data class` as a `request body` with properties that cannot be `null`, properties mustn't be `null` at runtime, - if I use a `Kotlin data class` as a `request body` with properties that cannot be `null` and I send the `payload` with `nulls`, I get a `Bad Request` in the response.  ### Current Behaviour  I would expect that:  - if I use a `Kotlin data class` as a `request body` with properties that cannot be `null`, properties can be `null` at runtime, - if I use a `Kotlin data class` as a `request body` with properties that cannot be `null` and I send the `payload` with `nulls`, sometimes I get a `Bad Request` and sometimes I get a `Internal Server Error` in the response.  ## Request ends up with an expected Bad Request (400)  Minimal reproducible code (the gist of this issue): ```kotlin package io.github.ryszardmakuch.springbootkotlinissue  import org.apache.logging.log4j.LogManager import org.springframework.http.ResponseEntity import org.springframework.web.bind.annotation.PostMapping import org.springframework.web.bind.annotation.RequestBody import org.springframework.web.bind.annotation.RestController  // expected behavior because I cannot instantiate ExampleRequest(element = null) data class ExampleRequest(val element: String)  @RestController class ExampleController {     @PostMapping(""/example"")     fun examplePostRequest(@RequestBody exampleRequest: ExampleRequest): ResponseEntity {         logger.info(""Element's length: ${exampleRequest.element.length}"")         return ResponseEntity.ok().build()     }      companion object {         private val logger = LogManager.getLogger(ExampleController::class.java)     } } ```  Request:  ``` curl -X POST localhost:8080/example    -H 'Content-Type: application/json'    -d '{""element"": null}'     ```  Response:  ```json {""timestamp"":""2022-05-02T19:31:35.715+00:00"",""status"":400,""error"":""Bad Request"",""path"":""/example""} ```  In logs I can see:  ``` 2022-05-02 21:33:01.139  WARN 12654 --- [nio-8080-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Instantiation of [simple type, class io.github.ryszardmakuch.springbootkotlinissue.ExampleRequest] value failed for JSON property element due to missing (therefore NULL) value for creator parameter element which is a non-nullable type; nested exception is com.fasterxml.jackson.module.kotlin.MissingKotlinParameterException: Instantiation of [simple type, class io.github.ryszardmakuch.springbootkotlinissue.ExampleRequest] value failed for JSON property element due to missing (therefore NULL) value for creator parameter element which is a non-nullable type at [Source: (org.springframework.util.StreamUtils$NonClosingInputStream); line: 1, column: 17] (through reference chain: io.github.ryszardmakuch.springbootkotlinissue.ExampleRequest[""element""])] ```  ## Request ends up with an unexpected Internal Server Error (500) due to an unexpected NullPointerException  Minimal reproducible code (the gist of this issue): ```kotlin package io.github.ryszardmakuch.springbootkotlinissue  import org.apache.logging.log4j.LogManager import org.springframework.http.ResponseEntity import org.springframework.web.bind.annotation.PostMapping import org.springframework.web.bind.annotation.RequestBody import org.springframework.web.bind.annotation.RestController  // unexpected behavior because I cannot instantiate ExampleRequest(elements = listOf(null)) data class ExampleRequest(val elements: List) data class ExampleElement(val value: String)  @RestController class ExampleController {     @PostMapping(""/example"")     fun examplePostRequest(@RequestBody exampleRequest: ExampleRequest): ResponseEntity {         exampleRequest.elements.map {             logger.info(""Element's length: ${it.value.length}"") // throws unexpected java.lang.NullPointerException         }         return ResponseEntity.ok().build()     }      companion object {         private val logger = LogManager.getLogger(ExampleController::class.java)     } } ```  Request:  ``` curl -X POST localhost:8080/example    -H 'Content-Type: application/json'   -d '{""elements"": [ null ]}' ```  Response: ```json {""timestamp"":""2022-05-02T19:39:02.284+00:00"",""status"":500,""error"":""Internal Server Error"",""path"":""/example""} ```  In logs I can see:  ``` java.lang.NullPointerException: null 	at io.github.ryszardmakuch.springbootkotlinissue.ExampleController.examplePostRequest(ExampleController.kt:17) ~[main/:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na] (...) 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1743) ~[tomcat-embed-core-9.0.62.jar:9.0.62] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.62.jar:9.0.62] 	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.62.jar:9.0.62] 	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.62.jar:9.0.62] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.62.jar:9.0.62] 	at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na] ```  I would expect `com.fasterxml.jackson.module.kotlin.MissingKotlinParameterException` due to non-nullable `ExampleElement` type and a `Bad Request` response in the result.  Typically a `NullPointerException` may happen when I declared `elements` as `List` and unsafely called the `value` like in the example below:  ```kotlin data class ExampleRequest(val elements: List) // ... logger.info(""Element's length: ${it!!.value.length}"") ```  `build.gradle.kts`: ```kotlin import org.jetbrains.kotlin.gradle.tasks.KotlinCompile  plugins {     id(""org.springframework.boot"") version ""2.6.7""     id(""io.spring.dependency-management"") version ""1.0.11.RELEASE""     kotlin(""jvm"") version ""1.6.21""     kotlin(""plugin.spring"") version ""1.6.21"" }  group = ""io.github.ryszardmakuch"" version = ""0.0.1-SNAPSHOT"" java.sourceCompatibility = JavaVersion.VERSION_11  repositories {     mavenCentral() }  dependencies {     implementation(""org.springframework.boot:spring-boot-starter-web"")     implementation(""com.fasterxml.jackson.module:jackson-module-kotlin"")     implementation(""org.jetbrains.kotlin:kotlin-reflect"")     implementation(""org.jetbrains.kotlin:kotlin-stdlib-jdk8"")     testImplementation(""org.springframework.boot:spring-boot-starter-test"")}  tasks.withType {     kotlinOptions {         freeCompilerArgs = listOf(""-Xjsr305=strict"")         jvmTarget = ""11""     } }  tasks.withType {     useJUnitPlatform() } ```  ---","closed","for: external-project,","ryszardmakuch","2022-05-02T20:27:56Z","2022-05-22T03:42:17Z"
"","28601","WebFlux: ServerWebExchange.getRequest().getURI() returns wrong scheme if forwarding-header-strategy is set or cloud platform is detected","**Affects:** Spring Webflux 5.3.20  ---  Running our app in our kubernetes cluster (or simulating it via `spring.main.cloud-platform=kubernetes`) or using `server.forward-headers-strategy=native` produces the wrong scheme when calling `ServerWebExchange.getRequest().getURI()` when forward headers are present.  This seems to be because `ReactorServerHttpRequest` uses `request.scheme()` (which netty fills from `X-Forwarded-Proto` if present), and combines it with the `Host` header, where there's no clear correlation between those two headers.  Effectively, the following cURL request: ``` curl -H ""X-Forwarded-Proto: https"" -H ""X-Forwarded-Host: my-gateway"" -H ""X-Forwarded-Port: 8181"" http://localhost:8080/print-uri ```  ... will return `ServerWebExchange.getRequest().getURI() = https://localhost:8080/print-uri`, even though the scheme used for the request was HTTP.  Minimal Controller Example: https://github.com/mabako/spring-native-forwarding-headers-webflux/blob/master/src/main/java/com/example/demo/PrintUriController.java","open","status: waiting-for-triage,","mabako","2022-06-09T13:55:56Z","2022-06-09T14:00:18Z"
"","28385","JPA Repository tries to use unmanaged type of same name as my entity","**Affects:** Spring Framework 5.2.3.RELEASE, Spring Data JPA 2.2.4.RELEASE  ---  Hi, I'm having an issue with the generation of Spring JPA Daos. I'm generating a repository like so:  `public interface FooDao extends JpaRepository { ... }` where Foo is an entity that is managed by Hibernate. The application fails at startup with the error Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'package.name.one.FooDao' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {} 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1695) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1253) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) 	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885) 	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789) 	... 119 common frames omitted   I investigated the cause and finally found that DefaultListableBeanFactory#allBeanNamesByType, that was queried during the autowiring process, didn't contain FooDao, even though `beanFactory.containsBean(""fooDao"")==true`. I tried calling `factory.getBean(""fooDao"")` in the debugger, and got this more interesting exception:    org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'fooDao': Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Not a managed type: class package.name.two.Foo   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1796)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)   	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)   	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)   	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)   	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1250)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207)   	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885)   	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789)   	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)   	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)   	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)   	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)   	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)   	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207)   	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885)   	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789)   	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)   	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)   	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)   	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)   	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)   	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207)   	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885)   	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789)   	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)   	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)   	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)   	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)   	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)   	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207)   	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885)   	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789)   	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)   	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)   	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)   	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)   	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)   	at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207)   	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:885)   	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:789)   	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:228)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1358)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1204)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:557)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517)   	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323)   	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)   	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321)   	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)   	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:879)   	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:878)   	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550)   	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:401)   	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:292)   	at package.name.three.commons.web.context.ServletContextUnwrappingContextLoaderListener.initApplication(ServletContextUnwrappingContextLoaderListener.java:79)   	at package.name.three.commons.web.context.ServletContextUnwrappingContextLoaderListener.contextInitialized(ServletContextUnwrappingContextLoaderListener.java:66)   	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4725)   	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5189)   	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)   	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:752)   	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:728)   	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)   	at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1702)   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   	at java.lang.reflect.Method.invoke(Method.java:497)   	at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300)   	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819)   	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)   	at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:482)   	at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:431)   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   	at java.lang.reflect.Method.invoke(Method.java:497)   	at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300)   	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819)   	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801)   	at com.sun.jmx.remote.security.MBeanServerAccessController.invoke(MBeanServerAccessController.java:468)   	at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1471)   	at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76)   	at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1312)   	at java.security.AccessController.doPrivileged(Native Method)   	at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1411)   	at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:832)   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   	at java.lang.reflect.Method.invoke(Method.java:497)   	at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:323)   	at sun.rmi.transport.Transport$1.run(Transport.java:200)   	at sun.rmi.transport.Transport$1.run(Transport.java:197)   	at java.security.AccessController.doPrivileged(Native Method)   	at sun.rmi.transport.Transport.serviceCall(Transport.java:196)   	at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:568)   	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826)   	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$256(TCPTransport.java:683)   	at java.security.AccessController.doPrivileged(Native Method)   	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682)   	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)   	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)   	at java.lang.Thread.run(Thread.java:745)   Caused by: java.lang.IllegalArgumentException: Not a managed type: class package.name.two.Foo   	at org.hibernate.metamodel.internal.MetamodelImpl.managedType(MetamodelImpl.java:473)   	at org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.(JpaMetamodelEntityInformation.java:74)   	at org.springframework.data.jpa.repository.support.JpaEntityInformationSupport.getEntityInformation(JpaEntityInformationSupport.java:66)   	at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getEntityInformation(JpaRepositoryFactory.java:211)   	at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:161)   	at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:144)   	at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:69)   	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:312)   	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.lambda$afterPropertiesSet$5(RepositoryFactoryBeanSupport.java:297)   	at org.springframework.data.util.Lazy.getNullable(Lazy.java:212)   	at org.springframework.data.util.Lazy.get(Lazy.java:94)   	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:300)   	at org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean.afterPropertiesSet(JpaRepositoryFactoryBean.java:121)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855)   	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792)   	... 129 more   One of my library jars contains another class of the same name 'Foo' (but in a different package) that can be used as an entity (i.e. it is annotated with JPA annotations). It is not contained in the persistence unit of the application at hand, and it is certainly not the class imported in my Spring JPA 'FooDao'. When I remove the library jar containing that second Foo class from my war-file and start the application, my application starts normally.  Let me know what additional information you need.","open","status: waiting-for-triage,","florianwicher","2022-04-26T16:10:20Z","2022-04-26T16:15:18Z"
"","28031","Scoped proxy causes conditional bean to throw unsatisfied dependency exception","**Affects:** Spring Boot 2.6.3, Spring Context 5.3.15  ---   I worked on make my web session serializable, so I turned some of the service into scoped proxies so that they can be serialized then. This way the problem occoured. Please check out the code at https://github.com/liptga/springbug  If you run ""./gradlew clean test"" you will see the problem.  The bean `BeanConditionalOnProperty `is conditional on a property. There is an other bean (`BeanConditionalOnOtherBean`) depending from this bean, which is conditional on bean `BeanConditionalOnProperty`.  If `BeanConditionalOnOtherBean `has a Proxy, then the context won't start unless the property is defined. This is demonstrated by the test `PropertyDoesNotExistsTest`. If the proxy is deleted (`@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)` is commented out), then the test passes.  **I would expect, that the proxy has no effect on evaluating the conditions.**   ``` package at.liptakg.springbug;  import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component;  @Component @ConditionalOnProperty(name = BeanConditionalOnProperty.BEAN_EXISTS) @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS) public class BeanConditionalOnProperty { 	public static final String BEAN_EXISTS = ""beanExists""; }  ```  ``` package at.liptakg.springbug;  import org.springframework.boot.autoconfigure.condition.ConditionalOnBean; import org.springframework.context.annotation.Scope; import org.springframework.context.annotation.ScopedProxyMode; import org.springframework.stereotype.Component;  @Component @ConditionalOnBean(BeanConditionalOnProperty.class) @Scope(proxyMode = ScopedProxyMode.TARGET_CLASS) //remove this and PropertyDoesNotExistsTest passes public class BeanConditionalOnOtherBean { 	private final BeanConditionalOnProperty beanConditionalOnProperty;  	public BeanConditionalOnOtherBean(BeanConditionalOnProperty beanConditionalOnProperty) { 		this.beanConditionalOnProperty = beanConditionalOnProperty; 	} } ```  ``` package at.liptakg.springbug;  import static org.assertj.core.api.Assertions.assertThat;  import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest;  @SpringBootTest(classes = Config.class) public class PropertyDoesNotExistsTest { 	@Autowired(required = false) 	public BeanConditionalOnOtherBean beanConditionalOnOtherBean;  	@Test 	void test() { 		assertThat(beanConditionalOnOtherBean).isNull(); 	} } ```  If the property exists, there is no problem. This is demonstrated in `PropertyExistsTest`:  ``` package at.liptakg.springbug;  import static org.assertj.core.api.Assertions.assertThat;  import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.TestPropertySource;  import at.liptakg.springbug.BeanConditionalOnOtherBean; import at.liptakg.springbug.Config;  @SpringBootTest(classes = Config.class) @TestPropertySource(properties = ""beanExists=true"") public class PropertyExistsTest { 	@Autowired(required = false) 	public BeanConditionalOnOtherBean beanConditionalOnOtherBean;  	@Test 	void test() { 		assertThat(beanConditionalOnOtherBean).isNotNull(); 	} } ```  If you need more information, do not hesitate to contact me.","closed","status: invalid,","liptga","2022-02-10T16:13:18Z","2022-02-10T17:11:30Z"
"","27982","Jaxb2Marashaller don't fired up pointed EscapeHandler","**Affects:** Spring Boot 2.5.6  ---   When implementing SOAP consumer with usage of WebServiceGatewaySupport Jaxb2Marshaller is setup like below:  ```     @Bean     @SneakyThrows     public Jaxb2Marshaller marshaller() {         final var marshaller = new Jaxb2Marshaller();         marshaller.setPackagesToScan(SCHEMAS_PATH);         marshaller.setMarshallerProperties(Map.of(                 Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.FALSE,                 Marshaller.JAXB_ENCODING, ""UTF-8"",             ""com.sun.xml.bind.marshaller.CharacterEscapeHandler"", new NoEscapeHandler()));          return marshaller;     } ```  Marshalled object contains XML as String inside which should be not escaped, but when the request is serialised EscapeHandler is not used and some data are escaped (in this case should not)","closed","for: external-project,","jabednarski","2022-01-27T22:15:29Z","2022-01-28T08:04:14Z"
"","28360","Unexpected @Autowired bean when newly registered bean is set as Primary","**Affects:** Spring 5.3.18  When registering a new bean X2 of type X and marking it as the primary implementation, a previously `@Autowired` field is still returning the previous instance type X1 when the parent bean instance is constructed.  **Expected:** The new primary class X2 is injected. The class with the @Autowired field is marked with @Scope(""prototype""). **Actual:** The previous class X1 is injected instead.  This code screenshot should be able to explain the issue better: ![image](https://user-images.githubusercontent.com/92868401/164204428-9672395b-0812-4eea-a576-533ab986e419.png)   PS. If the parent bean has not been retrieved prior to the bean definition, it works fine. The correct bean X2 is being returned.  https://github.com/rj-cam/autowire-primary/tree/main/src/test/java/com/example/autowireprimary  ---","open","status: waiting-for-triage,","rj-cam","2022-04-20T10:20:52Z","2022-04-22T03:44:37Z"
"","28393","DefaultContextCache uses hardcoded cache size, instead of the declared property","**Affects:** master  --- The documentation for [`org.springframework.test.context.cache.DefaultContextCache`](https://github.com/spring-projects/spring-framework/blob/main/spring-test/src/main/java/org/springframework/test/context/cache/DefaultContextCache.java) says ""configured with a maximum size"", there exists a field `maxSize`, which is set by a constructor parameter, but the `contextMap` uses a hardcoded size value of 32.","closed","status: invalid,","markonius","2022-04-28T08:42:50Z","2022-05-16T11:08:03Z"
"","28343","@EventListener + Coroutines","**Affects:** Any  ---  Spring introduced first-class support to kotlin and coroutines and while almost everything works flawlessly I really miss the support for coroutines in the `@EventListener`.  I used in the past [spring-kotlin-coroutine ](https://github.com/konrad-kaminski/spring-kotlin-coroutine)however this project is not updated for 3 years so I wonder if such support could be added to core Spring.","open","in: kotlin,","rotilho","2022-04-14T18:12:07Z","2022-05-02T19:49:10Z"
"","28367","Yaml global tags feature (Javabeans loaded from yaml properties) does not work","**Affects:** \spring-core:5.3.15 spring-boot:2.6.3  ---  Greetings  In the past, e.g. in a project that used _spring-core:4.3.20_, _spring-boot:1.5.17_ and, transitively, _snakeyaml:1.17_ I could load Java models in @ConfigurationProperties - annotated class fields, with yaml property-driven constructs, using yaml global tags, such as ```some.project:   level:	     property:       default: !!fully.qualified.ClassName {         aBooleanProperty: true       } ```  In [older versions](https://code.google.com/archive/p/snakeyaml/wikis/Documentation.wiki) of the Snakeyaml documentation, it was stated   > Introduced in version 1.8 of SnakeYAML is the ability to merge mappings that are then converted into custom Java objects (as opposed to simple Map objects). A merged Java object is very similar, except that the type of object must be specified.  (Don't get distracted by the mention to the merge capability, the point is to underline the ability to deserialize javabeans-compliant models from yaml.  The [current snakeyaml specification](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation) states:  > JavaBeans The spec says - ""One of the main goals of the JavaBeans architecture is to provide a platform neutral component architecture."" Avoiding global tags significantly improves ability to exchange the YAML documents between different platforms and languages. If the custom Java class conforms to the JavaBean specification it can be loaded and dumped without any extra code. For instance this JavaBean  ``` public class CarWithWheel {     private String plate;     private String year;     private Wheel wheel;     private Object part;     private Map map; //... ```  > will be dumped as ``` !!package.CarWithWheel map: {id: 3} part: !!org.yaml.snakeyaml.constructor.Wheel {id: 4} plate: 12-XP-F4 wheel: {id: 2} year: '2008' ``` Currently, I tried to use the afore-mentioned syntax, in a new project setup with _spring-core:5.3.15_ _spring-boot:2.6.3_ and (transitively) _snakeyaml:1.29_ and I was getting an error: ``` org.yaml.snakeyaml.constructor.ConstructorException: could not determine a constructor for the tag tag:yaml.org,2002:com.xxxxxx.xxxxx.xxxx.xxxx.results.SampleBean  in 'reader', line 544, column 17:         sampleBean: !!com.xxxxxx.xxxxx.xxxx.xxxx.res ...                      ^ ``` when I added this  ``` #...   results:     sampleBean: !!com.xxxxxx.xxxxx.xxxx.xxxx.results.SampleBean       sampleField: true ```  in my _application.yml_ I didn't find anything in the [snakeyaml changelist section](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Changes), indicating that something has changed on that matter, so I guess it must have to do with how spring leverages yaml (loads it in particular)","open","status: waiting-for-triage,","moudatsos","2022-04-21T15:52:35Z","2022-04-29T23:32:08Z"
"","28318","Multipart parts with no 'filename' defined in the Content-Disposition are ignored","**Affects:** \5.3.8+ --- When submitting a multipart request that has a part that does not specify a filename in the Content-Disposition, then the part is ignored and a validation error is shown that the ""Required request part '...; was not present'.  The problem appears to be in StandardMultipartHttpServletRequest.parseRequest() (L:102) where it fails to add the MultipartFile to the MultiValueMap if the filename is null.  I am trying to submit a multipart form that has two parts.  One with a JSON part named 'data' and another part named 'file' that is either a binary file (with the appropriate mime type for the file) or data with a mime-type of 'text/uri-list' which is a newline delimited list of URLs to fetch.  When submitting the part as say a PDF file with the Content-Disposition filename attribute set and mime-type of 'application/pdf' and the request works.  When you remove it because it's not-applicable to a part of mime-type 'text/uri-list', then the request fails with ""Request request part 'file' is not present"".  My understanding is that the filename attribute on the Content-Disposition is optional.  The comments on MultipartFile.getOriginalFilename() also correctly call out the function can return null if it has not been provided by the client.","closed","status: declined,","h4xmd","2022-04-11T03:43:16Z","2022-04-20T22:25:55Z"
"","28159","Strict input validation for REST APIs","**Affects:** \5.3.13  ---  When I define an API like this: ```java @RestController public class MyController {    @GetMapping   Me me() {     ...   }    } ```  I would like to receive an HTTP 400 Bad Request response when passing a parameter e.g. /me?you=notme","closed","for: stackoverflow,","donnd-t","2022-03-11T07:31:11Z","2022-03-11T07:47:31Z"
"","28695","JmsTemplate ignores message priority & deliveryMode","**Affects:** \5, 6  Using org.springframework.jms.core.MessagePostProcessor I can configure custom values for priority & deliveryMode but it seems like JmsTemplate doesn't take into account those values(check below link)  [			producer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());](https://github.com/spring-projects/spring-framework/blob/16c43c2041a50a8e1fd0befbb71cc2aa9644620a/spring-jms/src/main/java/org/springframework/jms/core/JmsTemplate.java#L631)  Issue is that in such case I need to configure multiple `JmsTemplate` instances to be able to generate messages with different priorities & delivery models  ```java JmsTemplate jmsTemplatePriorityDefault; JmsTemplate jmsTemplatePriority5; JmsTemplate jmsTemplatePriority2; .. and so on .. ```  ---","open","status: waiting-for-triage,","borsch","2022-06-24T08:29:03Z","2022-06-24T08:30:24Z"
"","28524","ConnectionManagerSupport must also provide a ctor for the URI which will be created and encoded respectively by end-user upfront.","**Affects:** \ spring-websocket-5.2.0.RELEASE in ConnectionManagerSupport ,  Whether or not the URI is encoded should be resolved by the developer  ---    see this issue,  https://github.com/spring-projects/spring-integration/issues/3813#issuecomment-1137339457","open","status: waiting-for-triage,","TheheiWorld","2022-05-25T14:45:50Z","2022-05-25T14:50:20Z"
"","28494","All Spring 5 versions are vulnerable to  RCE - CVE-2016-100002","**Affects:** \ 5.3.18, 5.3.19.5.3.20  ---   All Spring 5 versions, including the latest 5.3.20 released on May 11th, are now flagged as vulnerable to remote code execution. The score of the vulnerability is 9.8.  https://nvd.nist.gov/vuln/detail/CVE-2016-1000027#range-7969608 https://nvd.nist.gov/vuln/detail/CVE-2016-1000027/cpes?expandCpeRanges=true  We have strict security requirements, all our builds started failing because of this. However, the description still lists versions up to 5.3.16 as vulnerable.  Are you aware of this issue, is there any fix pending?  Thanks, Mircea Stan","closed","status: duplicate,","mirsilstan","2022-05-20T07:54:52Z","2022-05-20T07:59:46Z"
"","28610","R2DBC: @Transactional(readOnly) is applied to the connection before the transaction has begun","**Affects:** \ At least 5.3.19->5.3.20  ---  I was trying to set a transaction to read only to fake a read only connection. Turns out that the `SET TRANSACTION READ ONLY` statement is called before there's any transaction going, rendering it useless. This happens in https://github.com/spring-projects/spring-framework/blob/bc3b3d01ee359e4960aa7444d2fec2baedf9a8f0/spring-r2dbc/src/main/java/org/springframework/r2dbc/connection/R2dbcTransactionManager.java#L212 when you run the `R2dbcTransactionManger` with `enforceReadOnly= true`. The code reads that it tries to `prepareTransactionalConnection` where the statement is called but then on the next line `.then(Mono.from(doBegin(definition, con)))` which calls `BEGIN` is called after the statement has been called so there's no transaction to set to `READ ONLY`. This results in the following output in postgres 13.3:  ``` [35] LOG:  statement: SET TRANSACTION READ ONLY [35] WARNING:  SET TRANSACTION can only be used in transaction blocks [35] LOG:  statement: BEGIN [35] LOG:  execute S_0/B_1: INSERT INTO  [35] DETAIL:  parameters: $1 =  [35] LOG:  statement: COMMIT ``` The method called is set with `@Transactional(readOnly=true)`","closed","type: bug,","hheg","2022-06-11T14:18:46Z","2022-07-13T08:33:05Z"
"","28551","Spring Framework 5.3.20 is reported as vulnerable","**Affects:** \  Spring Framework Version 5.3.20 is reported as vulnerable on blackduck, what is the next stable version we can upgrade to? also i see a new 6.x snapshot version is released but i read that in one of the comments that it needs Java 17.   can you please advise on this showstopper issue we have.    ---","closed","status: duplicate,","shamkumarp","2022-06-01T06:40:04Z","2022-06-01T07:35:01Z"
"","28530","Support for CGLIB BeanCopier utility on JDK 17","**Affects:** \  --- env:jdk17,spring-core:5.3.19,springboot:2.6.7 cglib said it does not support jdk17, but spring is still using cglib, will the new version after spring remove cglib?  org.springframework.cglib.core.CodeGenerationException: java.lang.reflect.InaccessibleObjectException-->Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @3567135c  	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:589) 	at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108) 	at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) 	at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) 	at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134) 	at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319) 	at org.springframework.cglib.beans.BeanCopier$Generator.create(BeanCopier.java:95) 	at org.springframework.cglib.beans.BeanCopier.create(BeanCopier.java:51) 	at club.edm.bscwallet.server.service.WalletServiceTest.initTokenWallet(WalletServiceTest.java:80) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) 	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not ""opens java.lang"" to unnamed module @3567135c 	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354) 	at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297) 	at java.base/java.lang.reflect.Method.checkCanSetAccessible(Method.java:199) 	at java.base/java.lang.reflect.Method.setAccessible(Method.java:193) 	at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:553) 	... 81 more","closed","type: enhancement,","SuperEdison","2022-05-27T03:46:54Z","2022-06-28T11:04:51Z"
"","28297","How do i generate javadoc-api for all spring-framwork?","**Affects:** \  ---  I mean not use the export from IDE on the subject one by one.Thanks I lots!","closed","status: invalid,","JamesLiuft","2022-04-07T08:38:07Z","2022-04-08T01:58:43Z"
"","28380","Import to IDEA UnsupportedMethodException: Unsupported method: BuildEnvironment.getBuildIdentifier().","**Affects:** \  ---  Gradle sync failed after importing code to IDEA. Pre-compile was success(./gradlew cleanIdea :spring-oxm:compileTestJava) And I changed repository like below: ``` mavenCentral() 		maven { url ""https://plugins.gradle.org/m2"" } 		maven { url ""https://repo1.maven.org/maven2"" } 		maven { 			url ""https://repo.spring.io/plugins-release"" 		} 		maven { url ""https://repo.spring.io/ui/native/plugins-release"" } 		maven { url ""https://repo.spring.io/ui/native/milestone"" } 		mavenLocal() ``` But Gradle sync failed without an error message in IDEA, And I found error messages in idea.log. To avoid compatibale problems, I install Gradle using distributionUrl of gradle-wrapper.properties in gradle/wrapper directory, and I also config use sepcified location and Gradle user home to the installing home.  Environment： branch: 4.2.x jdk: 1.8.0_192 gradle: 2.5 IDEA: IntelliJ IDEA 2022.1 (Ultimate Edition) System: MacOS Monterey 12.3.1  idea.log ``` 2022-04-25 18:23:17,294 [27994188]   INFO - #o.j.p.g.s.p.GradleProjectResolver - Gradle project resolve error org.gradle.tooling.model.UnsupportedMethodException: Unsupported method: BuildEnvironment.getBuildIdentifier(). The version of Gradle you connect to does not support that method. To resolve the problem you can change/upgrade the target version of Gradle you connect to. Alternatively, you can ignore this exception and read other information from the model. 	at org.gradle.tooling.model.internal.Exceptions.unsupportedMethod(Exceptions.java:33) 	at org.gradle.tooling.internal.adapter.ProtocolToModelAdapter$InvocationHandlerImpl.invoke(ProtocolToModelAdapter.java:435) 	at com.sun.proxy.$Proxy193.getBuildIdentifier(Unknown Source) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.setupLogging(GradleExecutionHelper.java:497) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.prepare(GradleExecutionHelper.java:390) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.prepare(GradleExecutionHelper.java:335) 	at org.jetbrains.plugins.gradle.service.project.BuildActionRunner.prepare(BuildActionRunner.kt:163) 	at org.jetbrains.plugins.gradle.service.project.BuildActionRunner.createPhasedExecuter(BuildActionRunner.kt:149) 	at org.jetbrains.plugins.gradle.service.project.BuildActionRunner.fetchModels(BuildActionRunner.kt:78) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver.doResolveProjectInfo(GradleProjectResolver.java:276) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver$ProjectConnectionDataNodeFunction.fun(GradleProjectResolver.java:793) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver$ProjectConnectionDataNodeFunction.fun(GradleProjectResolver.java:775) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.lambda$execute$0(GradleExecutionHelper.java:138) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.maybeFixSystemProperties(GradleExecutionHelper.java:165) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.lambda$execute$1(GradleExecutionHelper.java:138) 	at org.jetbrains.plugins.gradle.GradleConnectorService$Companion.withGradleConnection(GradleConnectorService.kt:181) 	at org.jetbrains.plugins.gradle.GradleConnectorService.withGradleConnection(GradleConnectorService.kt) 	at org.jetbrains.plugins.gradle.service.execution.GradleExecutionHelper.execute(GradleExecutionHelper.java:130) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver.resolveProjectInfo(GradleProjectResolver.java:154) 	at org.jetbrains.plugins.gradle.service.project.GradleProjectResolver.resolveProjectInfo(GradleProjectResolver.java:74) 	at com.intellij.openapi.externalSystem.service.remote.RemoteExternalSystemProjectResolverImpl.lambda$resolveProjectInfo$0(RemoteExternalSystemProjectResolverImpl.java:37) 	at com.intellij.openapi.externalSystem.service.remote.AbstractRemoteExternalSystemService.execute(AbstractRemoteExternalSystemService.java:43) 	at com.intellij.openapi.externalSystem.service.remote.RemoteExternalSystemProjectResolverImpl.resolveProjectInfo(RemoteExternalSystemProjectResolverImpl.java:36) 	at com.intellij.openapi.externalSystem.service.remote.wrapper.ExternalSystemProjectResolverWrapper.resolveProjectInfo(ExternalSystemProjectResolverWrapper.java:48) 	at com.intellij.openapi.externalSystem.service.internal.ExternalSystemResolveProjectTask.doExecute(ExternalSystemResolveProjectTask.java:115) 	at com.intellij.openapi.externalSystem.service.internal.AbstractExternalSystemTask.execute(AbstractExternalSystemTask.java:151) 	at com.intellij.openapi.externalSystem.service.internal.AbstractExternalSystemTask.execute(AbstractExternalSystemTask.java:135) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$2.executeImpl(ExternalSystemUtil.java:491) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$2.lambda$execute$0(ExternalSystemUtil.java:327) 	at com.intellij.openapi.project.DumbServiceHeavyActivities.suspendIndexingAndRun(DumbServiceHeavyActivities.java:21) 	at com.intellij.openapi.project.DumbServiceImpl.suspendIndexingAndRun(DumbServiceImpl.java:190) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$2.execute(ExternalSystemUtil.java:327) 	at com.intellij.openapi.externalSystem.util.ExternalSystemUtil$4.run(ExternalSystemUtil.java:614) 	at com.intellij.openapi.progress.impl.CoreProgressManager.startTask(CoreProgressManager.java:442) 	at com.intellij.openapi.progress.impl.ProgressManagerImpl.startTask(ProgressManagerImpl.java:114) 	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcessWithProgressAsynchronously$5(CoreProgressManager.java:493) 	at com.intellij.openapi.progress.impl.ProgressRunner.lambda$submit$3(ProgressRunner.java:244) 	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcess$2(CoreProgressManager.java:189) 	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$executeProcessUnderProgress$12(CoreProgressManager.java:608) 	at com.intellij.openapi.progress.impl.CoreProgressManager.registerIndicatorAndRun(CoreProgressManager.java:683) 	at com.intellij.openapi.progress.impl.CoreProgressManager.computeUnderProgress(CoreProgressManager.java:639) 	at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:607) 	at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:60) 	at com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(CoreProgressManager.java:176) 	at com.intellij.openapi.progress.impl.ProgressRunner.lambda$submit$4(ProgressRunner.java:244) 	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1700) 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) 	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:668) 	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:665) 	at java.base/java.security.AccessController.doPrivileged(Native Method) 	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:665) 	at java.base/java.lang.Thread.run(Thread.java:829) ```","closed","status: declined,","xu20160924","2022-04-26T03:27:57Z","2022-04-26T05:58:30Z"
"","28898","When we change the system time to past(say 1 hour before), the ScheduledThreadPoolExecutor starts consuming more CPU (around 95-100%).)","**Affects:** \  ---  Below is the code :  ``` final ThreadFactory threadFactory = new ThreadFactoryBuilder()                 .setNameFormat(""XXX_THREAD"")                 .setDaemon(true)                 .build();          // Intentionally 1 thread         ScheduledThreadPoolExecutor scheduledExecutor = new ScheduledThreadPoolExecutor(1, threadFactory);         scheduledExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);         scheduledExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);         scheduledExecutor.setRemoveOnCancelPolicy(true);         scheduledExecutor.setRejectedExecutionHandler(new DiscardPolicy());         return scheduledExecutor; ```  `scheduledExecutor.scheduleWithFixedDelay(this::runUpdateJob, 1, 1, TimeUnit.SECONDS);`  The moment we change the system time to past (say 1 hour before current time), it starts affecting CPU resources(around 95%). The similar thing could happen during Daylight Saving also where time shifts to 1 hour past. Although, its gets normal when the past time elapsed.  Using JDK 1.8.0_202","open","status: waiting-for-triage,","Shikari0744","2022-08-01T06:10:38Z","2022-08-01T06:10:47Z"
"","28593","could you tell me，why used volatile","**Affects:** \  ---  ![image](https://user-images.githubusercontent.com/97614802/172806854-4c940ab1-0729-45fb-9077-765621092a15.png)","closed","for: stackoverflow,","cocodx","2022-06-09T08:53:07Z","2022-06-09T10:52:31Z"
"","28368","Database access can escape transaction when using AspectJ & TestPropertySource","**Affects:** \  ---   We hit an issue when using AspectJ transactions in a Kotlin application - sometimes, depending on a number of factors, the database access seems to be able to escape the transaction. This is best demonstrated by [the sample project](https://github.com/moreginger/aspectj-no-tx). However, in summary this seems to occur when:  - Using AspectJ (load-time or compile-time) - Some (test) code accesses a method marked `@Transactional` - TestPropertySource is used - Some (test) code accesses another method marked `@Transactional` - the changes aren't captured in the transaction and e.g. an exception will not roll back.  [Discussion on Stack Overflow](https://stackoverflow.com/questions/71855704/why-is-spring-transactional-unreliable-with-aspectj)","open","status: waiting-for-triage,","moreginger","2022-04-22T14:50:59Z","2022-04-22T14:52:32Z"
"","28023","spring-framework validation controller not support list?","**Affects:** \  ---   spring-framework validation controller not support list?  ```java     @PostMapping(""test"")     public List test(@RequestBody @Validated @Valid List inspectOptionResults) {         return new ArrayList<>();     } ```","closed","for: stackoverflow,","120011676","2022-02-10T05:10:12Z","2022-02-10T09:47:49Z"
"","28602","ComponentScan scanbase packages not working in gradle multi-module build","**Affects:** \  ---   I have multi-module build using Gradle. There are 2 independent spring projects in it. 1 of the projects is working as expected but 2nd project is not scanning any beans either in the same package or sub packages. Below are the things that I have tried (including the comments), but it's not working. Only thing that worked was ImportAutoConfiguration and mentioning the classes in sub-packges.  ``` @SpringBootApplication(scanBasePackages = {""io.comany.logs.functionality""}) //@ImportAutoConfiguration( classes = {Test.class, DecorationManager.class, Consumer.class}) //@ComponentScan(basePackages = {""io.comany.logs.functionality""}) public class Main {   public static void main(String[] args) {     SpringApplication.run(Main.class, args);   } } ```","closed","for: stackoverflow,","ypulstya","2022-06-09T16:36:19Z","2022-06-09T16:44:15Z"
"","28413","Spring webflux : Using JSR-380 validation.xml file to disable a @Valid annotation in a controller method dont work","**Affects:** \  ---   I have a spring webflux using annotated controllers and java validation  the controller interface is generated by open api generator so i cant modify it  i need to add and disable some of the validations generated in the model classes and the controllers methods so i used the validation.xml as described in https://beanvalidation.org/2.0/spec/#xml-mapping-constraintdeclarationinxml everythings works fine but not the disabling of an @Valid in a controller method (updating the Model validation works and disabling validation annotations other than @Valid in the controller method works)  i have pushed a demo project in this location : https://github.com/influence160/spring-webflux-xml-validation-test to reproduce the bug  the demo project contains also a postman collection for testing  all the tests in the postman requests works as expected but not the last one  (withValidationOverrided post model invalid id) ![image](https://user-images.githubusercontent.com/3180939/166743835-abb75d50-2f76-4885-abc9-68e253fd6578.png) that one shouldnt results in a validation error because the validation is disabled in additional-validation-mapping.xml   i checked the code of the class` org.springframework.web.reactive.result.method.annotation.AbstractMessageReaderArgumentResolver` and in the method  `protected Mono readBody(MethodParameter bodyParam, @Nullable MethodParameter actualParam, boolean isBodyRequired, BindingContext bindingContext, ServerWebExchange exchange) {` the exception is raised by the method    ```     private void validate(Object target, Object[] validationHints, MethodParameter param, BindingContext binding, ServerWebExchange exchange) {         String name = Conventions.getVariableNameForParameter(param);         WebExchangeDataBinder binder = binding.createDataBinder(exchange, target, name);         binder.validate(validationHints);         if (binder.getBindingResult().hasErrors()) {             throw new WebExchangeBindException(param, binder.getBindingResult());         }     } ```  because the value of hints come from  `org.springframework.validation.annotation.ValidationAnnotationUtils`  which is checking for the annotation @Valid  ![image](https://user-images.githubusercontent.com/3180939/166744817-eb1d2588-9acd-4796-bfc8-631546516a80.png)   **Possible Solution** maybe ValidationAnnotationUtils should call the Constraint metadata request APIs of the JAVA Validation API ( https://beanvalidation.org/2.0/spec/#constraintmetadata )  to check if the parameter is annotated with @Valid","open","status: waiting-for-triage,","influence160","2022-05-04T17:34:24Z","2022-05-04T17:35:18Z"
"","28110","java.lang.NoClassDefFoundError: org/springframework/cglib/beans/BeanMapEmitter","**Affects:** \  ---   Hi: After we upgrade to spring boot 2.5.10 (spring-core 5.3.16), when invoke following method  `org.springframework.cglib.beans.BeanMap.create(BeanMap.java:68)`  got the the exception  `java.lang.NoClassDefFoundError: org/springframework/cglib/beans/BeanMapEmitter`  Checking the jar of spring-core-5.3.16, seems the class BeanMapEmitter was miss","closed","in: core,","murainwood","2022-02-28T10:15:31Z","2022-03-16T10:30:08Z"
"","28571","disable SSL verification in Spring Vault for testing","**Affects:** \  ---","closed","status: invalid,","Nidhi-Tanwar14","2022-06-06T09:36:27Z","2022-06-07T06:07:15Z"
"","28543","Is it possible to do interface injection in Spring please?","**Affects:** \  ---","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-05-31T07:45:52Z","2022-05-31T09:16:50Z"
"","28537","Which version of JBoss eap is the minimum requirement of Spring framework upgrade from 3 to 5 please?","**Affects:** \  ---","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-05-29T04:29:41Z","2022-05-29T05:53:01Z"
"","28536","Which version of hibernate is suitable for spring framework 5.0.2?","**Affects:** \  ---","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-05-29T04:28:07Z","2022-05-29T05:55:12Z"
"","28510","Currently there is a complex and time-consuming process of converting a legacy or an existing Spring project to a Spring Boot application. Any api planned in upcoming releases to solve this","**Affects:** \  ---","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-05-24T07:28:41Z","2022-05-29T13:40:27Z"
"","28509","Spring Boot creates a lot of unused dependencies, resulting in a large deployment file. Is there any solution for this in upcoming releases?","**Affects:** \  ---","closed","for: stackoverflow,","Nidhi-Tanwar14","2022-05-24T07:24:23Z","2022-05-29T13:38:32Z"
"","28353","Spring Data MongoDB","**Affects:** \  ---","closed","status: invalid,","Qingyu-Limitless","2022-04-18T01:52:39Z","2022-04-18T09:24:36Z"
"","28300","how can i download 5.3.18 jar ?","**Affects:** \  ---","closed","for: stackoverflow,","manjeetdangi","2022-04-07T14:14:25Z","2022-04-07T14:41:24Z"
"","28259","Where can I check the version comparison of spring framework corresponding to spring boot","**Affects:** \  ---","closed","for: stackoverflow,","wuaoya","2022-03-31T09:58:15Z","2022-04-01T01:42:57Z"
"","28167","ProxyExchange discards all incoming headers when used to make an upstream request containing a body.","**Affects:** \  ---","closed","","ericyanush","2022-03-11T20:39:27Z","2022-03-11T20:40:24Z"
"","28089","test","**Affects:** \  ---","closed","status: invalid,","cuzz1","2022-02-21T15:07:46Z","2022-02-21T15:16:50Z"
"","28087","NO FUNCIONA SI PONGO UNA LINEA","**Affects:** \  ---","closed","status: invalid,","jonatan0867","2022-02-21T11:26:22Z","2022-02-21T13:06:16Z"
"","28584","spring框架对配置文件找不到的处理","**Affects:** \  ## 问题复述  在一次使用`ssm`开发的时候，发现了此bug  ```java public class TestGetBeanProductTypeServiceImpl {      /**      *  用于测试：      */     @Test     public void test() {         ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(""spring/application-*.xml"");          String[] beanDefinitionNames = classPathXmlApplicationContext.getBeanDefinitionNames();         for (String beanDefinitionName : beanDefinitionNames) {             System.out.println(""beanDefinitionName = "" + beanDefinitionName);         }          ProductTypeService productTypeServiceImpl = (ProductTypeService) classPathXmlApplicationContext.getBean(""ProductTypeServiceImpl"");          List all = productTypeServiceImpl.getAll();         all.forEach(type -> System.out.println(type.toString()));     }  } ```  代码如上所示：  我的配置文件：  ![image-20220608174000883](https://user-images.githubusercontent.com/77964041/172589534-2ce4ea0d-9b99-4416-b7b1-ba92975ab378.png)  在获取`productTypeServiceImpl`的时候，第一次出现了异常  ```xml org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'ProductTypeServiceImpl' available  	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:808) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:1279) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:297) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) 	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1108) 	at indi.yuluo.test.TestGetBeanProductTypeServiceImpl.test(TestGetBeanProductTypeServiceImpl.java:31) 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.lang.reflect.Method.invoke(Method.java:498) 	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) 	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) 	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) 	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) 	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) 	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) 	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) 	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) 	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) 	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) 	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) 	at org.junit.runners.ParentRunner.run(ParentRunner.java:363) 	at org.junit.runner.JUnitCore.run(JUnitCore.java:137) 	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) 	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) ```  **第一次出现之后，我认为是bean id的问题，定义了bean id之后，同样是此问题，后来对比了配置文件之后，发现问题所在**  正确代码：  ```java ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(""spring/applicationContex-*.xml""); ```  ## 问题分析  debug展开对问题的分析：  配置文件错误应该报出的是FileNotFoundException异常，为什么会No bean name异常？  经过分析，在深入了spring的源码之后  ![image-20220608174701899](https://user-images.githubusercontent.com/77964041/172589614-161ea388-b95e-4909-a4ff-9bb3e7fabbe9.png)    在上下文环境配置的源码中`org.springframework.context.support.AbstractApplicationContext`  发现问题  此代码缺少对parent为空的处理，我认为此处应该报出一个`FileNotFoundException`异常， 而不是直接执行下一步。","closed","for: stackoverflow,","829yuluo","2022-06-08T10:04:05Z","2022-06-08T10:51:34Z"
"","28872","Reactive applications on Tomcat not compatible with servlet filters","**Affects:** 5.x/current  I have a Servlet filter that adds request headers via decorating request object (the only way allowed by Servlet API).  ```java class AddHeaders extends HttpServletRequestWrapper {     private Map headers;      public AddHeaders(HttpServletRequest request, Map headers) {         super(request);         this.headers = headers;     }      public String getHeader(String name) {         return headers.getOrDefault(name, super.getHeader(name));     }      public Enumeration getHeaderNames() {         List names = Collections.list(super.getHeaderNames());         names.addAll(headers.keySet());         return Collections.enumeration(names);     } } ```  Unfortunately `TomcatServerHttpRequest`/`TomcatHeadersAdapter` bypasses  request object and reaches directly into backing map thus my wrapper is ignored.  Generic `ServletServerHttpRequest` looks to handle it correctly but Tomcat subclass seems to have been too optimized.","open","in: web,","mwisnicki","2022-07-26T01:11:36Z","2022-08-01T08:55:50Z"
"","28017","`PatternMappingFilterProxy#addUrlPattern` not support `*` url pattern","**Affects:** 5.4.15  --- Does not work in MockMvc when `FilterRegistrationBean` url pattern is `*`.  See [demo](https://github.com/Deycoesr/SPR28017)","closed","status: superseded,","Deycoesr","2022-02-08T08:03:59Z","2022-02-12T07:56:36Z"
"","28199","Mono Object wrapped by ResponseEntity cannot be passed correctly by mvc framework","**Affects:** 5.3.x  ---  Please refer to this [disscusion ](https://github.com/spring-projects/spring-boot/issues/30158)for more detailed information. In function `ResponseBodyEmitterReturnValueHandler.supportsReturnType`, it failed to recognize the correct type when a controller returns an object having a Mono object wrapped by ResponseEntity. However, the parameter `HandlerMethod.ReturnValueMethodParameter` actually has an attribute `returnValue` containing enough information.  I wonder if there's a way taking return value into consideration. I tried to fetch the actual return value at runtime, but the subclass `HandlerMethod.ReturnValueMethodParameter` is protected, so the type cannot be converted from `MethodParameter` to `HandlerMethod.ReturnValueMethodParameter`.","closed","status: duplicate,","YuanHao97","2022-03-19T08:26:49Z","2022-03-25T20:57:49Z"
"","28231","Get MockHttpServletResponse contentType (without characterEncoding)","**Affects:** 5.3.8  ---  During an upgrade from springboot 2.3.8.RELEASE to 2.5.8 I have encountered some issues with integration testing during assertions to the request contentType.  Example of assertion: ``` assertEquals(MediaType.APPLICATION_JSON_VALUE, response.getContentType()); ``` I noticed that this commit was made to fix some issues the community had pointed out https://github.com/spring-projects/spring-framework/commit/e4b9b1fadb35c4e439acc8931910aaba6e1342e3 But I've been wondering if there is a way to get the contentType alone from the request Currently ``` private void updateContentTypePropertyAndHeader() { 		if (this.contentType != null) { 			String value = this.contentType; 			if (this.characterEncodingSet && !value.toLowerCase().contains(CHARSET_PREFIX)) { 				value += ';' + CHARSET_PREFIX + getCharacterEncoding(); 				this.contentType = value; 			} 			doAddHeaderValue(HttpHeaders.CONTENT_TYPE, value, true); 		} 	} ``` https://github.com/spring-projects/spring-framework/blob/main/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletResponse.java#L219 Appends the character encoding to the contentType, therefore the assertion in the integration fails like so: ``` org.opentest4j.AssertionFailedError:  Expected :application/json Actual   :application/json;charset=UTF-8 ``` I tried setting a default character encoding for mockMvc  ``` @Bean     public MockMvc mockMvc() {         return MockMvcBuilders.webAppContextSetup(webApplicationContext)                 .defaultResponseCharacterEncoding(Charset.defaultCharset()).build();     } ``` Which I thought would help me avoid setting the flag `this.characterEncoding = true` https://github.com/spring-projects/spring-framework/blob/main/spring-test/src/main/java/org/springframework/mock/web/MockHttpServletResponse.java#L212 But that was unsuccessful as AbstractJackson2View#prepareResponse sets the character encoding triggering the flag to be set to true, which in turn appends the encoding to the contentType https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-webmvc/src/main/java/org/springframework/web/servlet/view/json/AbstractJackson2View.java#L150  So I guess the question is, am I missing something? It seems like there is no way to get the respose.contentType by itself (without character encoding). If so, should MediaType.APPLICATION_JSON_UTF8_VALUE be deprecated? https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-web/src/main/java/org/springframework/http/MediaType.java#L118 It seems like there is an inconsistency here between spring-web and spring-test. Are there better ways to test this? Or a way to disable the character encoding from getting appended to the contentType?","open","status: feedback-provided,","fabianlem","2022-03-24T19:05:10Z","2022-03-25T20:15:55Z"
"","28337","ConfigurationCondition with REGISTER_BEAN phase unable to find bean name for type, if bean of that type created via factory bean method of @Configuration class","**Affects:** 5.3.7  --- Imagine a configuration like that: ```java // module A depends on module B @Configuration @Import(ConfigB.class) public class ConfigA {     @Bean     public SomeBean someBean() {         return new SomeBean();     } }  // module B @Configuration public class ConfigB {     @Bean     @Conditional(ConfigB.SomeBeanExistsCondition.class)     public DependantBean dependantBean(SomeBean someBean) {         return new DependantBean(someBean);     }      public static class SomeBeanExistsCondition implements ConfigurationCondition {         @Override         public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {             return context.getBeanFactory().getBeanNamesForType(SomeBean.class).length != 0;         }          @Override         public ConfigurationPhase getConfigurationPhase() {             return ConfigurationPhase.REGISTER_BEAN;         }     } } ``` Now, if I write a test in module A with configuration for test `ConfigA`, then test context would not contain a bean of type `DependantBean`. It happens because `context.getBeanFactory().getBeanNamesForType(SomeBean.class)` search only for beans, that registered via `@Component` annotation, but not beans exposed via `@Bean` factory methods is counted in this process, nor imported directly via `@Import(SomeBean.class)`  Test examples  ### Passing test  ```java package my.package;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.ConditionContext; import org.springframework.context.annotation.Conditional; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.ConfigurationCondition; import org.springframework.context.annotation.Import; import org.springframework.core.type.AnnotatedTypeMetadata; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;  import ru.yandex.market.jmf.blackbox.support.test.impl.SomeBean;  @SpringJUnitConfig(TestSuccessDependencies.ConfigA.class) public class TestSuccessDependencies {     private final BeanFactory beanFactory;      @Autowired     public TestSuccessDependencies(BeanFactory beanFactory) {         this.beanFactory = beanFactory;     }      @Test     public void testThatAllBeansArePresent() {         Assertions.assertDoesNotThrow(() -> beanFactory.getBean(SomeBean.class));          Assertions.assertDoesNotThrow(() -> beanFactory.getBean(DependantBean.class));     }      @Configuration     @Import({ConfigB.class})     @ComponentScan(""my.package.impl"") // here placed the @Component public class SomeBean{}     public static class ConfigA {     }      @Configuration     public static class ConfigB {         @Bean         @Conditional(TestSuccessDependencies.ConfigB.Condition.class)         public DependantBean dependantBean(SomeBean someBean) {             return new DependantBean(someBean);         }          public static class Condition implements ConfigurationCondition {             @Override             public ConfigurationPhase getConfigurationPhase() {                 return ConfigurationPhase.REGISTER_BEAN;             }              @Override             public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {                 return context.getBeanFactory().getBeanNamesForType(SomeBean.class).length != 0;             }         }     }      public static class DependantBean {         public DependantBean(SomeBean someBean) {          }     } } ```  ### Failing test  ```java package my.package;  import javax.inject.Inject;  import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ConditionContext; import org.springframework.context.annotation.Conditional; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.ConfigurationCondition; import org.springframework.context.annotation.Import; import org.springframework.core.type.AnnotatedTypeMetadata; import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;  @SpringJUnitConfig(TestFailureDependencies.ConfigA.class) public class TestFailureDependencies {     private final BeanFactory beanFactory;      @Autowired     public TestFailureDependencies(BeanFactory beanFactory) {         this.beanFactory = beanFactory;     }      @Test     public void testThatAllBeanIsPresent() {         Assertions.assertDoesNotThrow(() -> beanFactory.getBean(SomeBean.class));          Assertions.assertDoesNotThrow(() -> beanFactory.getBean(DependantBean.class));     }     @Configuration     public static class ConfigB {         @Bean         @Conditional(TestFailureDependencies.ConfigB.Condition.class)         public DependantBean dependantBean(SomeBean someBean) {             return new DependantBean(someBean);         }          public static class Condition implements ConfigurationCondition {             @Override             public ConfigurationPhase getConfigurationPhase() {                 return ConfigurationPhase.REGISTER_BEAN;             }              @Override             public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {                 return context.getBeanFactory().getBeanNamesForType(SomeBean.class).length != 0;             }         }     }      @Configuration     @Import(ConfigB.class)     public static class ConfigA {         @Bean         public SomeBean someBean() {             return new SomeBean();         }     }      public static class DependantBean {         public DependantBean(SomeBean someBean) {          }     }      public static class SomeBean {     } } ```   I think, that this is the bug. But maybe I'm wrong? Could anyone clarify?","open","in: core,","gallyamb","2022-04-14T05:41:37Z","2022-06-03T16:53:27Z"
"","28837","ContentDisposition does not unescape quotes and backslashes when parsing","**Affects:** 5.3.21  --- When a multipart request contains a part with a quote or backslash in the `name` or `filename`, it should be escaped. `ContentDisposition` properly escapes them when building the header, but it does not unescape them when parsing it. See the following code: ```java ContentDisposition cd = ContentDisposition.builder(""form-data"").name(""file"").filename(""a\\nice \""file\"" with \\\"" quotes.txt"").build(); System.out.println(""Generated header: "" + cd); System.out.println(""Original: "" + cd.getFilename()); ContentDisposition parsed = ContentDisposition.parse(cd.toString()); System.out.println(""Parsed:   "" + parsed.getFilename()); ``` output: ``` Generated header: form-data; name=""file""; filename=""a\nice \""file\"" with \"" quotes.txt"" Original: a\nice ""file"" with \"" quotes.txt Parsed:   a\nice \""file\"" with \"" quotes.txt ``` (also note that the last quote seems to be considered as already escaped so it does not get escaped – seems intentional from the original implementation in 956ffe68587c8d5f21135b5ce4650af0c2dea933)  The issue seems to come from [`ContentDisposition.java#L354-L356`](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/http/ContentDisposition.java#L354-L356), which simply removes the outer quotes without unescaping: ```java String value = (part.startsWith(""\"""", eqIndex + 1) && part.endsWith(""\"""") ? 		part.substring(eqIndex + 2, part.length() - 1) : 		part.substring(eqIndex + 1)); ```  We noticed this issue because we were seeing `\""` from `MultipartFile.getOriginalFilename()`, whereas Servlet’s `Part.getSubmittedFileName()` returns the correct value.","open","in: web,","DidierLoiseau","2022-07-18T15:25:39Z","2022-08-01T09:40:44Z"
"","28546","Support Access-Control-Allow-Private-Network header","**Affects:** 5.3.19  --- https://developer.chrome.com/blog/private-network-access-preflight/ Chrome will want a Access-Control-Allow-Private-Network header from the application if Access-Control-Request-Private-Network is sent in the preflight request. It would be nice if the CrossOrigin annotation handled this.","open","status: waiting-for-triage,","sixcorners","2022-05-31T15:50:36Z","2022-05-31T16:31:00Z"
"","28396","wrong list of http methods when making a preflight request","**Affects:** 5.3.19  ---   ## Steps to reproduce  ### 1. start following code:  ```kotlin @SpringBootApplication class OptionsBugDemoApplication  fun main(args: Array) {     runApplication(*args) }  @RequestMapping(""foo"") @RestController class FooController {     @GetMapping(""{id}"")     fun get(@PathVariable id: String) = Unit      @DeleteMapping(""{id}"")     fun delete(@PathVariable id: String) = Unit      @PostMapping(""customAction"")     fun customAction() = Unit } ```  ### 2. run tests:  ```bash curl -L -X OPTIONS -v http://localhost:8080/foo/customAction ```  response: ``` *   Trying 127.0.0.1:8080... * Connected to localhost (127.0.0.1) port 8080 (#0) > OPTIONS /foo/customAction HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.82.0 > Accept: */* > * Mark bundle as not supporting multiuse < HTTP/1.1 200 < Allow: GET,HEAD,DELETE,POST,OPTIONS < Accept-Patch: < Content-Length: 0 < Date: Fri, 29 Apr 2022 09:00:31 GMT < * Connection #0 to host localhost left intact ```  ### 3. issue:  preflight return wrong method list there: `Allow: GET,HEAD,DELETE,POST,OPTIONS`. I expect `HEAD,POST,OPTIONS`.  ## puzzle  The path `/foo/customAction` seems to be overridden by the pattern `/foo/{id}`, and I'm confused about that.","closed","for: stackoverflow,","ymind","2022-04-29T09:14:28Z","2022-04-30T14:46:36Z"
"","28294","RequestLoggingFilter: `afterRequest` is executed before Async servlet finishes","**Affects:** 5.3.18 (via Spring Boot 2.6.6)  When I configure `org.springframework.web.filter.CommonsRequestLoggingFilter` I notice that servlet log messages appear **after** the lines from `afterRequest`:  ``` 2022-04-06 20:15:40,289 DEBUG [qtp2065957432-37] c.k.k.c.l.RequestLoggingFilter [73355343-b7fb-4e93-b82b-339009931d2c][]: Before request [POST /graphql, .... 2022-04-06 20:15:40,338 DEBUG [qtp2065957432-37] c.k.k.c.l.RequestLoggingFilter [73355343-b7fb-4e93-b82b-339009931d2c][]: After request [POST /graphql,  ... 2022-04-06 20:15:40,499 DEBUG [graphql-exec-1] o.a.i.l.j.BaseJdbcLogger [][]: ==>  Preparing: SELECT id, name, .... 2022-04-06 20:15:40,504 DEBUG [graphql-exec-1] o.a.i.l.j.BaseJdbcLogger [][]: ==> Parameters: .... 2022-04-06 20:15:40,513 DEBUG [graphql-exec-1] o.a.i.l.j.BaseJdbcLogger [][]: <==      Total: 1 ``` I expect the `After request ...` to appear after the `graphql-exec-1` thread which services the response.   I'm using [GraphQL Java](https://www.graphql-java.com/) which processes requests asynchronously.  If I add `javax.servlet.AsyncContext#addListener(javax.servlet.AsyncListener)` and I hook on `onComplete` to call `afterRequest`, it is properly called at the end of the request.  Digging deeper, it seems [this condition](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/filter/AbstractRequestLoggingFilter.java#L291-L294) is `true` because there is no  `this.asyncWebRequest` in [here](https://github.com/spring-projects/spring-framework/blob/main/spring-web/src/main/java/org/springframework/web/context/request/async/WebAsyncManager.java#L141-L143).  I think this out of order execution violates the contract of the `CommonsRequestLoggingFilter`.","closed","status: waiting-for-triage,","svilen-ivanov-kubit","2022-04-06T18:22:10Z","2022-04-07T13:12:36Z"
"","28321","Make WebClientException serializable","**Affects:** 5.3.17  ---   We use asynchronous workflows with a workflow engine (Camunda) and call REST services using `WebClient` in those workflows. If a non-successful HTTP code is returned by the service, a `WebClientException` is thrown. In this case, the workflow is suspended and the state including the exception is serialized to a database using standard Java serialization. This does not work for `WebClientException` because the following exception is thrown:  ``` java.io.NotSerializableException: org.springframework.http.client.reactive.NettyHeadersAdapter  	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1185) 	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553) 	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510) 	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433) 	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179) 	at java.base/java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1553) 	at java.base/java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1510) 	at java.base/java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1433) 	at java.base/java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1179) 	at java.base/java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:349) 	at com.example.nettyexceptionnotserializable.controller.ExampleControllerTest.example(ExampleControllerTest.java:29) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:725) 	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131) 	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140) 	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84) 	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45) 	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104) 	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$7(TestMethodTestDescriptor.java:214) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:210) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:135) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:66) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:151) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53) 	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) 	at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) 	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) 	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) ```  I created a minimal project (https://github.com/trettstadtnlb/netty-headers-not-serializable) that you can use to reproduce the problem by running `ExampleControllerTest`. The test makes a call to a REST endpoint that returns HTTP 422 and tries to serialize the exception that is thrown.","closed","type: enhancement,","trettstadtnlb","2022-04-11T07:13:43Z","2022-07-28T12:25:08Z"
"","28268","Webflux: invoked cancel() after Mono onComplete()","**Affects:** 5.3.17  ---   Hello,   I created a webflux project based on spring boot 2.6.5 with mogodb reactive.  During performance test, even if a load of 10 tps is given, cancel() is called after onComplete(). Condition is difficult to predict, but it comes out when you request about 10 tps sometime. It comes out even better with more traffic than that.  All requests were 100% successful, so I think it's a little strange that cancel() called.  This is the result of extracting the trace log. ``` 2022-04-01 14:07:02.296  INFO 1 --- [ntLoopGroup-3-8] reactor.Mono.Peek.603                    : onComplete() 2022-04-01 14:07:02.297 DEBUG 1 --- [or-http-epoll-1] r.n.http.server.HttpServerOperations     : [6b365b84-95, L:/10.240.5.189:9010 - R:/10.240.2.53:33018] Decreasing pending responses, now 0 2022-04-01 14:07:02.298 DEBUG 1 --- [or-http-epoll-1] r.n.http.server.HttpServerOperations     : [6b365b84-95, L:/10.240.5.189:9010 - R:/10.240.2.53:33018] Last HTTP packet was sent, terminating the channel 2022-04-01 14:07:02.298 TRACE 1 --- [or-http-epoll-1] reactor.netty.channel.ChannelOperations  : [6b365b84, L:/10.240.5.189:9010 - R:/10.240.2.53:33018] Disposing ChannelOperation from a channel  java.lang.Exception: ChannelOperation terminal stack 	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:465) 	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) 	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:469) 	at io.netty.channel.epoll.EpollEventLoop.run(EpollEventLoop.java:384) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:833)  2022-04-01 14:07:02.300  INFO 1 --- [or-http-epoll-1] reactor.Mono.Peek.603                    : cancel() ``` - The above API test to query the mongodb data. -  in the case of an API that simply returns Mono.just(""XXX""), it did not occur at all.  Can I get some help or hints related to this?","open","status: waiting-for-triage,","morenice","2022-04-01T09:37:58Z","2022-04-11T07:16:58Z"
"","28118","`ReflectUtils#getBeanProperties` does not support chained setter methods","**Affects:** 5.3.16  --- ```java public class TestBean {      private String name;      public String getName() {         return name;     }      public TestBean setName(String name) {         this.name = name;         return this;     }      public static void main(String[] args) {         PropertyDescriptor[] beanProperties = ReflectUtils.getBeanProperties(TestBean.class);         for (PropertyDescriptor beanProperty : beanProperties) {             if (Objects.equals(beanProperty.getName(), ""name"")) {                 Method writeMethod = beanProperty.getWriteMethod();                 System.out.println(""writeMethod = "" + writeMethod);             }         }     } } ``` result:","closed","status: feedback-provided,","Deycoesr","2022-03-01T11:03:41Z","2022-03-04T17:34:43Z"
"","28152","Broken link to webflux-cors.html in Spring WebFlux documentation","**Affects:** 5.3.16  ---   [Spring WebFlux](https://docs.spring.io/spring-framework/docs/5.3.16/reference/html/web-reactive.html#webflux-filters-cors) documentation on **CORS Filter** has broken link to [webflux-cors.html](https://docs.spring.io/spring-framework/docs/5.3.16/reference/html/webflux-cors.html#webflux-cors-webfilter).","closed","status: declined,","ikolomiets","2022-03-09T16:20:13Z","2022-03-10T14:23:14Z"
"","27949","Unexpected empty collection on Named collection type","**Affects:** 5.3.15  As introduced by https://github.com/spring-projects/spring-framework/issues/19901 and mentioned in https://github.com/spring-projects/spring-framework/issues/22735 it _is_ expected that a collection type in a factory constructor provides an empty collection. Thus the following will occur  ```java @Configuration  class SampleConfiguration {    @Bean     public TestClass testClass(Set sampleSet) {       return new TestClass(sampleSet); // In this case sampleSet will be an empty set if not found   } } ```  The suggested workaround if that was not desirable, was to check for empty methods and fail out.  In the following - more explicit - situation   ```java @Configuration  class SampleConfiguration {    @Bean     public TestClass testClass(@Named(""explicitName"") Set sampleSet) {       return new TestClass(sampleSet); // In this case sampleSet will be an empty set if not found   } } ```  the `sampleSet` has been explicitly named. In this case, we will still receive an empty collection in the case that the bean cannot be found. This is surprising as at this point there is an explicit ask for a specific bean name. This makes a possible spelling mistake in the named bean have a high impact - because if an empty collection is valid, there's _no way to tell if the bean was wired via the spring context, or if the default bean took its place_.  An expected behaviour could be that if a bean was explicitly named - that it would fail in the event that the bean name was not found. Or that there would be some way to make the `fallback` passed though to https://github.com/spring-projects/spring-framework/blob/main/spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java#L852 false if explicitly desireable (such as via another annotation).","open","in: core,","pault-t-canva","2022-01-19T01:25:34Z","2022-07-26T07:48:35Z"
"","27915","Spring fails to determine XML is XSD-based if DOCTYPE appears in a comment","**Affects:** 5.3.14 and earlier ---    If you want to load a DTD configuration file, `  ` will affect the loading of spring.  If my profile is written like this: ```xml         ```  Then, when Spring is used to load the configuration file, an exception will appear.   This is because there is a bug when determining the profile validation pattern.  In `org.springframework.util.xml.XmlValidationModeDetector`,Spring analyzes programs one line at a time.  However, each analysis focuses only on the first `= 0) {         result = line.substring(0, indexOfStartComment);         currLine = line.substring(indexOfStartComment);     }      while ((currLine = consume(currLine)) != null) {         if (!this.inComment && !currLine.trim().startsWith(START_COMMENT)) {             int index = result.indexOf(END_COMMENT);             if(index != -1) result = result.substring(index + END_COMMENT.length());             return result + currLine;         }     }     return null; } ```  It can be removed in front of '-->'.","closed","in: core,","shooye","2022-01-11T09:28:51Z","2022-01-13T15:28:36Z"
"","27899","ArrayIndexOutOfBoundsException with STOMP and Jetty 10","**Affects:** 5.3.14 ---  Jetty10RequestUpgradeStrategy throws ArrayIndexOutOfBoundsException if STOMP (or any other WS subprotocol) is used; the offending code is the block starting at https://github.com/spring-projects/spring-framework/blob/ccf95413ed41c7016bc57f92676716fc5c44e286/spring-websocket/src/main/java/org/springframework/web/socket/server/jetty/Jetty10RequestUpgradeStrategy.java#L159 which tries to reference the third argument to an invocation that only has two (classic off-by-one error).","closed","type: bug,","espenhw","2022-01-06T16:54:40Z","2022-01-12T15:06:40Z"
"","28043","SpEL fails to recover from error during MIXED mode compilation","**Affects:** 5.2.13.RELEASE  ---   I am testing spel performance, when I share a SpelExpression instance between multiple threads.  I tried set SpelCompilerMode to MIXED or IMMEDIATE and put a variable with different type in the context, then I triggered an exception.  If I set SpelCompilerMode to OFF, it works correctly. So I am confused, is spel thread safe?  I didn't find any description of spel's thread safety in the spring project document. I want to ask it's a spel thread safe bug or spel is not thread safe when compile is enable.  Here is my test code:  ```java import java.util.concurrent.atomic.AtomicInteger;  import org.springframework.expression.EvaluationContext; import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.SpelCompilerMode; import org.springframework.expression.spel.SpelParserConfiguration; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.expression.spel.support.DataBindingMethodResolver; import org.springframework.expression.spel.support.SimpleEvaluationContext;  import lombok.AllArgsConstructor; import lombok.Data;  /**  * @author happier233  * @version Main.java, v 0.1 2021年08月18日 10:02 上午 happier233  */ public class Main {      public static String                  name                    = ""default"";      public static Context                 root                    = new Context();      public static SpelParserConfiguration spelParserConfiguration = new SpelParserConfiguration(         SpelCompilerMode.MIXED, Main.class.getClassLoader());     public static ExpressionParser        parser                  = new SpelExpressionParser(         spelParserConfiguration);      public static Expression              expression              = parser         .parseExpression(""#bean.name + '234'"");      public static void main(String[] args) {         calc(() -> {             for (int i = 0; i < 10; i++) {                 calc(() -> run(true));             }         });         new Thread(Main::run).start();         new Thread(Main::run).start();     }      public static void run() {         calc(() -> {             for (int i = 0; i < 1000000; i++) {                 run(false);             }         });     }      private static final AtomicInteger cc = new AtomicInteger();      private static void run(boolean flag) {         EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding()             .withRootObject(root)             .withMethodResolvers(DataBindingMethodResolver.forInstanceMethodInvocation()).build();         if ((cc.incrementAndGet() & 1) == 0) {             context.setVariable(""bean"", new Bean(""test""));         } else {             context.setVariable(""bean"", new Bean2(123));         }         Object value = expression.getValue(context);         if (flag) {             System.out.println(value);         }     }      public static void calc(Runnable runnable) {         long start = System.currentTimeMillis();         runnable.run();         long end = System.currentTimeMillis();         System.out.println(""time["" + name + ""]: "" + (end - start));     }      @Data     public static class Context {         private String        title = ""233"";         private AtomicInteger count = new AtomicInteger(0);     }      @Data     @AllArgsConstructor     public static class Bean {         private String name;     }      @Data     @AllArgsConstructor     public static class Bean2 {         private Integer name;     } } ```  Here is the excpetion stack: ``` Exception in thread ""Thread-1"" java.lang.IllegalStateException: Failed to instantiate CompiledExpression 	at org.springframework.expression.spel.standard.SpelCompiler.compile(SpelCompiler.java:113) 	at org.springframework.expression.spel.standard.SpelExpression.compileExpression(SpelExpression.java:526) 	at org.springframework.expression.spel.standard.SpelExpression.checkCompile(SpelExpression.java:497) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:273) 	at org.example.acm.Main.run(Main.java:65) 	at org.example.acm.Main.lambda$run$2(Main.java:49) 	at org.example.acm.Main.calc(Main.java:73) 	at org.example.acm.Main.run(Main.java:47) 	at java.lang.Thread.run(Thread.java:750) Caused by: java.lang.VerifyError: (class: spel/Ex27, method: getValue signature: (Ljava/lang/Object;Lorg/springframework/expression/EvaluationContext;)Ljava/lang/Object;) Incompatible object argument for function call 	at java.lang.Class.getDeclaredConstructors0(Native Method) 	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671) 	at java.lang.Class.getConstructor0(Class.java:3075) 	at java.lang.Class.getDeclaredConstructor(Class.java:2178) 	at org.springframework.util.ReflectionUtils.accessibleConstructor(ReflectionUtils.java:185) 	at org.springframework.expression.spel.standard.SpelCompiler.compile(SpelCompiler.java:110) 	... 8 more ```","closed","in: core,","happier233","2022-02-12T05:44:26Z","2022-02-18T14:48:30Z"
"","28859","Improve documentation about deprecation for APPLICATION_JSON[-VALUE] but for programmatic clients","**Affects:** 5 and 6  Currently about [MediaType](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/MediaType.html) javadoc - for  `APPLICATION_JSON_UTF8` and `APPLICATION_JSON_UTF8_VALUE` - both are **deprecated** according with the following description for each one respectively:  ``` Deprecated. as of 5.2 in favor of APPLICATION_JSON  since major browsers like Chrome now comply with the specification and interpret correctly UTF-8 special characters  without requiring a charset=UTF-8 parameter.  Deprecated. as of 5.2 in favor of APPLICATION_JSON_VALUE  since major browsers like Chrome now comply with the specification and interpret correctly UTF-8 special characters  without requiring a charset=UTF-8 parameter. ```  Even assuming if this situation applies perfectly to all the web browsers around the globe   * What about when the **client** is a programmatic type? It about **REST** such as `RestTemplate`   Because my native speaking is Spanish - is normal have data with `ñ` and others such as `é á ó`   Therefore was normal use `APPLICATION_JSON_UTF8` or `APPLICATION_JSON_UTF8_VALUE` according the case at:   * For the `@Controller` - either `@RequestMapping` - or `@GetMapping`  with the _produces_ attribute and `@PostMapping/@PutMapping` with the _consumes_ attribute - where is possible use `MediaType`   * `RestTemplate` programmatic configuration through [RequestEntity.HeadersBuilder](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/RequestEntity.HeadersBuilder.html) with `accept(MediaType... acceptableMediaTypes)` and [ResponseEntity.BodyBuilder](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.BodyBuilder.html) with `contentType(MediaType contentType)`.  So is not clear how _now_ should be configured UTF-8 to be handle/support by programmatic clients for **rest**.","closed","status: invalid,","manueljordan","2022-07-22T17:34:11Z","2022-07-23T07:36:24Z"
"","28291","Add support for HEAD methods in Spring's Resource handling","**Affects:**  Spring Web 5.3.18 **Tested with:** Tomcat and Jetty **Tested with:** Linux and Windows  ---  I want to download large files (>10GB) from a Spring Web Server, before I start the download I want to know the size of the remote file, so, therefore, I make a HEAD request on the remote file.  Static files are served via ResourceHandlers, eg.  ``` Java @Configuration public class MvcConfig implements WebMvcConfigurer {      @Override     public void addResourceHandlers(ResourceHandlerRegistry registry) {         registry             .addResourceHandler(""/**"")             .addResourceLocations(""file:download/"");     }  } ```  and then when I make a HEAD request on a large file (> 10 GB), on the first try I get the response within milliseconds but when I try again the response takes seconds ( >10s).","closed","type: enhancement,","hannosgit","2022-04-06T13:08:05Z","2022-04-07T11:53:29Z"
"","28223","request(converters): allow RequestParam conversion from null values.","**Affects:**  Spring 5.3. 16 and below  Currently in Spring, there is only one class `Optional` that can be populated by a null value when annotated with @RequestParam in a given RestControllerMapping.  This is allowed because within Spring a private method checks to see if the class of the type Optional and will immediately return an Optional.empty() when a null value is received.  In my case, I would like to use the class Option from the arrow library so I can differentiate between an incoming request to query for null vs a request never being sent.  this allows me to do something like this  @RequestMapping age: Option  Where   `Option.none()` is equivalent to not querying by age `Option.some(null)` is equivalent to querying for entries where age is null `Option.some(123)` is equivalent to querying for entries where age is 123  This allows me to dynamically build SQL predicates  In all cases except for Optional however, Spring will throw an exception if the parameter is not passed.","closed","in: web,","codymikol","2022-03-23T17:54:28Z","2022-05-09T13:10:26Z"
"","28248","RCE 0 Day","**Affects:**   All Spring Framework version   ---","closed","status: invalid,","PlexPt","2022-03-29T15:10:18Z","2022-03-29T15:28:36Z"
"","28429","Option to toggle off CSRF token as url parameter","---   When activating CSRF protection you have the option to send in the token as either a header or a URL parameter. It should be possible to introduce a toggle that toggles the option of sending in the CSRF token as a URL parameter, and only allows for it as a header.","closed","for: external-project,","Asskali","2022-05-09T07:52:34Z","2022-05-09T07:56:06Z"
"","27944","Consider making `ContentNegotiatingViewResolver`'s algorithm for `getMediaTypes` public","**Affects:** Spring Framework `v5.3.14`  ---   **Context**  If I have an `@ExceptionHandler` and want to be able to perform content-type negotiation based on the incoming `accept` header, and what the method itself supports, I currently need to set up this logic myself, or delegate to an external [non-Spring library](https://gitlab.com/jamietanna/content-negotiation/) to handle the logic.  **Feature Request**  Considering that `ContentNegotiatingViewResolver` has a good algorithm for doing this, it would be great to have this made `public`, or moved into a separate class to allow for easier content-negotiation where necessary.  **Other information**  [Specific code snippets](https://github.com/spring-projects/spring-framework/blob/v5.3.14/spring-webmvc/src/main/java/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.java#L250-L301)","closed","status: declined,","jamietanna","2022-01-17T18:06:15Z","2022-02-01T07:15:03Z"
"","27917","I have this issue with the entity manager without any fix","2022-01-11 13:34:38.593 ERROR 22092 --- [  restartedMain] o.s.boot.SpringApplication               : Application run failed  org.springframework.context.ApplicationContextException: Failed to start bean 'documentationPluginsBootstrapper'; nested exception is java.lang.NullPointerException: Cannot invoke ""org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getPatterns()"" because ""this.condition"" is null 	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:181) ~[spring-context-5.3.14.jar:5.3.14] 	at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:54) ~[spring-context-5.3.14.jar:5.3.14] 	at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:356) ~[spring-context-5.3.14.jar:5.3.14] 	at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na] 	at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:155) ~[spring-context-5.3.14.jar:5.3.14] 	at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:123) ~[spring-context-5.3.14.jar:5.3.14] 	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:935) ~[spring-context-5.3.14.jar:5.3.14] 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:586) ~[spring-context-5.3.14.jar:5.3.14] 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) ~[spring-boot-2.6.2.jar:2.6.2] 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:730) ~[spring-boot-2.6.2.jar:2.6.2] 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:412) ~[spring-boot-2.6.2.jar:2.6.2] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:302) ~[spring-boot-2.6.2.jar:2.6.2] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[spring-boot-2.6.2.jar:2.6.2] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1290) ~[spring-boot-2.6.2.jar:2.6.2] 	at app.ryadha.v1.RyadhaApplication.main(RyadhaApplication.java:12) ~[classes/:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na] 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na] 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na] 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na] 	at org.springframework.boot.devtools.restart.RestartLauncher.run(RestartLauncher.java:49) ~[spring-boot-devtools-2.6.2.jar:2.6.2] Caused by: java.lang.NullPointerException: Cannot invoke ""org.springframework.web.servlet.mvc.condition.PatternsRequestCondition.getPatterns()"" because ""this.condition"" is null 	at springfox.documentation.spring.web.WebMvcPatternsRequestConditionWrapper.getPatterns(WebMvcPatternsRequestConditionWrapper.java:56) ~[springfox-spring-webmvc-3.0.0.jar:3.0.0] 	at springfox.documentation.RequestHandler.sortedPaths(RequestHandler.java:113) ~[springfox-core-3.0.0.jar:3.0.0] 	at springfox.documentation.spi.service.contexts.Orderings.lambda$byPatternsCondition$3(Orderings.java:89) ~[springfox-spi-3.0.0.jar:3.0.0] 	at java.base/java.util.Comparator.lambda$comparing$77a9974f$1(Comparator.java:473) ~[na:na] 	at java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355) ~[na:na] 	at java.base/java.util.TimSort.sort(TimSort.java:220) ~[na:na] 	at java.base/java.util.Arrays.sort(Arrays.java:1307) ~[na:na] 	at java.base/java.util.ArrayList.sort(ArrayList.java:1721) ~[na:na] 	at java.base/java.util.stream.SortedOps$RefSortingSink.end(SortedOps.java:392) ~[na:na] 	at java.base/java.util.stream.Sink$ChainedReference.end(Sink.java:258) ~[na:na] 	at java.base/java.util.stream.Sink$ChainedReference.end(Sink.java:258) ~[na:na] 	at java.base/java.util.stream.Sink$ChainedReference.end(Sink.java:258) ~[na:na] 	at java.base/java.util.stream.Sink$ChainedReference.end(Sink.java:258) ~[na:na] 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:510) ~[na:na] 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) ~[na:na] 	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921) ~[na:na] 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na] 	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682) ~[na:na] 	at springfox.documentation.spring.web.plugins.WebMvcRequestHandlerProvider.requestHandlers(WebMvcRequestHandlerProvider.java:81) ~[springfox-spring-webmvc-3.0.0.jar:3.0.0] 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197) ~[na:na] 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625) ~[na:na] 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509) ~[na:na] 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) ~[na:na] 	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921) ~[na:na] 	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na] 	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682) ~[na:na] 	at springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.withDefaults(AbstractDocumentationPluginsBootstrapper.java:107) ~[springfox-spring-web-3.0.0.jar:3.0.0] 	at springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.buildContext(AbstractDocumentationPluginsBootstrapper.java:91) ~[springfox-spring-web-3.0.0.jar:3.0.0] 	at springfox.documentation.spring.web.plugins.AbstractDocumentationPluginsBootstrapper.bootstrapDocumentationPlugins(AbstractDocumentationPluginsBootstrapper.java:82) ~[springfox-spring-web-3.0.0.jar:3.0.0] 	at springfox.documentation.spring.web.plugins.DocumentationPluginsBootstrapper.start(DocumentationPluginsBootstrapper.java:100) ~[springfox-spring-web-3.0.0.jar:3.0.0] 	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:178) ~[spring-context-5.3.14.jar:5.3.14] 	... 19 common frames omitted   Process finished with exit code 0","closed","for: external-project,","imjmakki","2022-01-11T10:43:39Z","2022-01-11T12:52:29Z"
"","28358","NettyHeadersAdapter may  be cause Cors problem","1、version： org.springframework:spring-web:jar:5.3.18:compile org.springframework.cloud:spring-cloud-starter-gateway:jar:3.1.1:compile 2、core case： NettyRoutingFilter use the：【NettyHeadersAdapter#putAll】but【this.headers::add switch to this.headers::set】   3、eg： gateway server：set the Access-Control-Allow-Origin：http://gateway.com gateway NettyRoutingFilter：return another  Access-Control-Allow-Origin：http://upstream.com NettyHeadersAdapter#putAll：rewrite the Access-Control-Allow-Origin to：http://upstream.com","closed","status: invalid,","scuhzq","2022-04-20T04:22:33Z","2022-04-20T07:24:26Z"
"","28373","5.0.x","11","closed","status: invalid,","kuojean","2022-04-24T09:54:57Z","2022-04-24T10:10:51Z"
"","28605","nested exception is java.lang.ArrayIndexOutOfBoundsException: 23309","1.spring version spring-context-3.0.5.RELEASE.jar  2.error code ![image](https://user-images.githubusercontent.com/49397581/173047166-3cef2e64-c16c-489b-a238-5ccbef38c7f5.png)  3.exception ""D:\Program Files\Java\jdk1.8.0_202\bin\java.exe"" ""-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2021.3.2\lib\idea_rt.jar=50379:D:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2021.3.2\bin"" -Dfile.encoding=UTF-8 -classpath ""D:\Program Files\Java\jdk1.8.0_202\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar;D:\worksapce\vsim-core\vsim-apps\vsim-dse\target\classes;D:\worksapce\vsim-core\vsim-base\base-cfg\target\classes;D:\work\apache-maven-3.8.4\repo\commons-configuration\commons-configuration\1.10\commons-configuration-1.10.jar;D:\work\apache-maven-3.8.4\repo\commons-lang\commons-lang\2.6\commons-lang-2.6.jar;D:\work\apache-maven-3.8.4\repo\commons-logging\commons-logging\1.1.1\commons-logging-1.1.1.jar;D:\work\apache-maven-3.8.4\repo\commons-jxpath\commons-jxpath\1.3\commons-jxpath-1.3.jar;D:\work\apache-maven-3.8.4\repo\org\apache\commons\commons-vfs2\2.0\commons-vfs2-2.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\maven\scm\maven-scm-api\1.4\maven-scm-api-1.4.jar;D:\work\apache-maven-3.8.4\repo\org\codehaus\plexus\plexus-utils\1.5.6\plexus-utils-1.5.6.jar;D:\work\apache-maven-3.8.4\repo\org\apache\maven\scm\maven-scm-provider-svnexe\1.4\maven-scm-provider-svnexe-1.4.jar;D:\work\apache-maven-3.8.4\repo\org\apache\maven\scm\maven-scm-provider-svn-commons\1.4\maven-scm-provider-svn-commons-1.4.jar;D:\work\apache-maven-3.8.4\repo\regexp\regexp\1.3\regexp-1.3.jar;D:\work\apache-maven-3.8.4\repo\commons-httpclient\commons-httpclient\3.1\commons-httpclient-3.1.jar;D:\work\apache-maven-3.8.4\repo\com\jcraft\jsch\0.1.50\jsch-0.1.50.jar;D:\work\apache-maven-3.8.4\repo\commons-net\commons-net\3.3\commons-net-3.3.jar;D:\work\apache-maven-3.8.4\repo\commons-collections\commons-collections\3.2.1\commons-collections-3.2.1.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-beans\3.0.5.RELEASE\spring-beans-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\cglib\cglib-nodep\2.1_3\cglib-nodep-2.1_3.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-context-support\3.0.5.RELEASE\spring-context-support-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-core\3.0.5.RELEASE\spring-core-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-test\3.0.5.RELEASE\spring-test-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springmodules\spring-modules-jakarta-commons\0.8\spring-modules-jakarta-commons-0.8.jar;D:\work\apache-maven-3.8.4\repo\commons-validator\commons-validator\1.1.4\commons-validator-1.1.4.jar;D:\work\apache-maven-3.8.4\repo\commons-chain\commons-chain\1.1\commons-chain-1.1.jar;D:\work\apache-maven-3.8.4\repo\javax\portlet\portlet-api\1.0\portlet-api-1.0.jar;D:\work\apache-maven-3.8.4\repo\myfaces\myfaces-api\1.1.0\myfaces-api-1.1.0.jar;D:\work\apache-maven-3.8.4\repo\commons-el\commons-el\1.0\commons-el-1.0.jar;D:\work\apache-maven-3.8.4\repo\commons-fileupload\commons-fileupload\1.0\commons-fileupload-1.0.jar;D:\work\apache-maven-3.8.4\repo\oro\oro\2.0.8\oro-2.0.8.jar;D:\work\apache-maven-3.8.4\repo\javax\servlet\jstl\1.1.2\jstl-1.1.2.jar;D:\work\apache-maven-3.8.4\repo\commons-digester\commons-digester\1.6\commons-digester-1.6.jar;D:\work\apache-maven-3.8.4\repo\javax\servlet\servlet-api\2.3\servlet-api-2.3.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-tx\3.0.5.RELEASE\spring-tx-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\aopalliance\aopalliance\1.0\aopalliance-1.0.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-aop\3.0.5.RELEASE\spring-aop-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-jdbc\3.0.5.RELEASE\spring-jdbc-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-orm\3.0.5.RELEASE\spring-orm-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-oxm\3.0.5.RELEASE\spring-oxm-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\mysql\mysql-connector-java\5.1.25\mysql-connector-java-5.1.25.jar;D:\work\apache-maven-3.8.4\repo\commons-dbcp\commons-dbcp\1.4\commons-dbcp-1.4.jar;D:\work\apache-maven-3.8.4\repo\commons-pool\commons-pool\1.6\commons-pool-1.6.jar;D:\work\apache-maven-3.8.4\repo\javax\annotation\javax.annotation-api\1.3.2\javax.annotation-api-1.3.2.jar;D:\work\apache-maven-3.8.4\repo\org\apache\logging\log4j\log4j-core\2.17.0\log4j-core-2.17.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\logging\log4j\log4j-api\2.17.0\log4j-api-2.17.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\logging\log4j\log4j-slf4j-impl\2.17.0\log4j-slf4j-impl-2.17.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\logging\log4j\log4j-1.2-api\2.17.0\log4j-1.2-api-2.17.0.jar;D:\work\apache-maven-3.8.4\repo\javax\activation\activation\1.1\activation-1.1.jar;D:\work\apache-maven-3.8.4\repo\javax\mail\mail\1.4\mail-1.4.jar;D:\work\apache-maven-3.8.4\repo\org\apache\logging\log4j\log4j-flume-ng\2.17.0\log4j-flume-ng-2.17.0.jar;D:\work\apache-maven-3.8.4\repo\com\sleepycat\je\5.0.73\je-5.0.73.jar;D:\work\apache-maven-3.8.4\repo\org\apache\flume\flume-ng-sdk\1.9.0\flume-ng-sdk-1.9.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\avro\avro\1.7.4\avro-1.7.4.jar;D:\work\apache-maven-3.8.4\repo\com\thoughtworks\paranamer\paranamer\2.3\paranamer-2.3.jar;D:\work\apache-maven-3.8.4\repo\org\apache\avro\avro-ipc\1.7.4\avro-ipc-1.7.4.jar;D:\work\apache-maven-3.8.4\repo\org\mortbay\jetty\jetty\6.1.26\jetty-6.1.26.jar;D:\work\apache-maven-3.8.4\repo\org\mortbay\jetty\jetty-util\6.1.26\jetty-util-6.1.26.jar;D:\work\apache-maven-3.8.4\repo\org\apache\velocity\velocity\1.7\velocity-1.7.jar;D:\work\apache-maven-3.8.4\repo\org\apache\thrift\libthrift\0.9.3\libthrift-0.9.3.jar;D:\work\apache-maven-3.8.4\repo\org\slf4j\jcl-over-slf4j\1.7.0\jcl-over-slf4j-1.7.0.jar;D:\work\apache-maven-3.8.4\repo\com\lmax\disruptor\3.3.0\disruptor-3.3.0.jar;D:\work\apache-maven-3.8.4\repo\commons-beanutils\commons-beanutils\1.8.1\commons-beanutils-1.8.1.jar;D:\work\apache-maven-3.8.4\repo\commons-codec\commons-codec\1.8\commons-codec-1.8.jar;D:\work\apache-maven-3.8.4\repo\com\google\inject\guice\3.0\guice-3.0.jar;D:\work\apache-maven-3.8.4\repo\javax\inject\javax.inject\1\javax.inject-1.jar;D:\worksapce\vsim-core\vsim-base\base-clustering\target\classes;D:\work\apache-maven-3.8.4\repo\org\apache\zookeeper\zookeeper\3.4.6\zookeeper-3.4.6.jar;D:\work\apache-maven-3.8.4\repo\jline\jline\0.9.94\jline-0.9.94.jar;D:\work\apache-maven-3.8.4\repo\io\netty\netty\3.7.0.Final\netty-3.7.0.Final.jar;D:\work\apache-maven-3.8.4\repo\org\apache\curator\curator-framework\4.0.1\curator-framework-4.0.1.jar;D:\work\apache-maven-3.8.4\repo\org\apache\curator\curator-client\4.0.1\curator-client-4.0.1.jar;D:\work\apache-maven-3.8.4\repo\org\apache\curator\curator-recipes\4.0.1\curator-recipes-4.0.1.jar;D:\worksapce\vsim-core\vsim-base\base-clustering-dubbo\target\classes;D:\work\apache-maven-3.8.4\repo\com\alibaba\dubbo\2.5.5\dubbo-2.5.5.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-web\4.3.10.RELEASE\spring-web-4.3.10.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\com\github\sgroschupf\zkclient\0.1\zkclient-0.1.jar;D:\work\apache-maven-3.8.4\repo\org\projectlombok\lombok\1.18.10\lombok-1.18.10.jar;D:\worksapce\vsim-core\vsim-apps\vsim-api\target\classes;D:\work\apache-maven-3.8.4\repo\com\simo\vsim\biz\vsim-external-api\1.0.43\vsim-external-api-1.0.43.jar;D:\worksapce\vsim-core\vsim-base\base-data-access\target\classes;D:\worksapce\vsim-core\vsim-base\base-protocol\target\classes;D:\work\apache-maven-3.8.4\repo\org\apache\commons\commons-compress\1.9\commons-compress-1.9.jar;D:\worksapce\vsim-core\vsim-base\base-common\target\classes;D:\work\apache-maven-3.8.4\repo\org\apache\mina\mina-core\2.0.7\mina-core-2.0.7.jar;D:\work\apache-maven-3.8.4\repo\joda-time\joda-time\2.9.4\joda-time-2.9.4.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-context\3.0.5.RELEASE\spring-context-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-expression\3.0.5.RELEASE\spring-expression-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-asm\3.0.5.RELEASE\spring-asm-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\codehaus\jackson\jackson-core-asl\1.8.5\jackson-core-asl-1.8.5.jar;D:\work\apache-maven-3.8.4\repo\org\codehaus\jackson\jackson-mapper-asl\1.8.5\jackson-mapper-asl-1.8.5.jar;D:\worksapce\vsim-core\vsim-base\base-redis\target\classes;D:\work\apache-maven-3.8.4\repo\redis\clients\jedis\2.9.0\jedis-2.9.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\commons\commons-pool2\2.4.2\commons-pool2-2.4.2.jar;D:\worksapce\vsim-core\vsim-base\base-msgq\target\classes;D:\work\apache-maven-3.8.4\repo\org\apache\activemq\activemq-core\5.7.0\activemq-core-5.7.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\geronimo\specs\geronimo-jms_1.1_spec\1.1.1\geronimo-jms_1.1_spec-1.1.1.jar;D:\work\apache-maven-3.8.4\repo\org\apache\activemq\kahadb\5.7.0\kahadb-5.7.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\activemq\protobuf\activemq-protobuf\1.1\activemq-protobuf-1.1.jar;D:\work\apache-maven-3.8.4\repo\org\fusesource\mqtt-client\mqtt-client\1.3\mqtt-client-1.3.jar;D:\work\apache-maven-3.8.4\repo\org\fusesource\hawtdispatch\hawtdispatch-transport\1.11\hawtdispatch-transport-1.11.jar;D:\work\apache-maven-3.8.4\repo\org\fusesource\hawtdispatch\hawtdispatch\1.11\hawtdispatch-1.11.jar;D:\work\apache-maven-3.8.4\repo\org\fusesource\hawtbuf\hawtbuf\1.9\hawtbuf-1.9.jar;D:\work\apache-maven-3.8.4\repo\org\apache\geronimo\specs\geronimo-j2ee-management_1.1_spec\1.0.1\geronimo-j2ee-management_1.1_spec-1.0.1.jar;D:\work\apache-maven-3.8.4\repo\org\jasypt\jasypt\1.9.0\jasypt-1.9.0.jar;D:\work\apache-maven-3.8.4\repo\org\springframework\spring-jms\3.0.5.RELEASE\spring-jms-3.0.5.RELEASE.jar;D:\work\apache-maven-3.8.4\repo\org\apache\activemq\activemq-pool\5.7.0\activemq-pool-5.7.0.jar;D:\work\apache-maven-3.8.4\repo\org\apache\geronimo\specs\geronimo-jta_1.0.1B_spec\1.0.1\geronimo-jta_1.0.1B_spec-1.0.1.jar;D:\worksapce\vsim-core\vsim-base\base-resource\target\classes;D:\work\apache-maven-3.8.4\repo\com\alibaba\druid\1.0.16\druid-1.0.16.jar;D:\Program Files\Java\jdk1.8.0_202\lib\jconsole.jar;D:\Program Files\Java\jdk1.8.0_202\lib\tools.jar;D:\work\apache-maven-3.8.4\repo\com\baomidou\mybatis-plus\2.3\mybatis-plus-2.3.jar;D:\work\apache-maven-3.8.4\repo\com\baomidou\mybatis-plus-support\2.3\mybatis-plus-support-2.3.jar;D:\work\apache-maven-3.8.4\repo\com\baomidou\mybatis-plus-core\2.3\mybatis-plus-core-2.3.jar;D:\work\apache-maven-3.8.4\repo\com\github\jsqlparser\jsqlparser\1.1\jsqlparser-1.1.jar;D:\work\apache-maven-3.8.4\repo\org\mybatis\mybatis-spring\1.3.2\mybatis-spring-1.3.2.jar;D:\work\apache-maven-3.8.4\repo\org\mybatis\mybatis\3.4.6\mybatis-3.4.6.jar;D:\work\apache-maven-3.8.4\repo\com\baomidou\mybatis-plus-generate\2.3\mybatis-plus-generate-2.3.jar;D:\work\apache-maven-3.8.4\repo\com\google\guava\guava\19.0-rc2\guava-19.0-rc2.jar;D:\work\apache-maven-3.8.4\repo\com\baidu\disconf\disconf-client\2.6.36\disconf-client-2.6.36.jar;D:\work\apache-maven-3.8.4\repo\commons-io\commons-io\1.4\commons-io-1.4.jar;D:\work\apache-maven-3.8.4\repo\com\google\code\gson\gson\2.2.4\gson-2.2.4.jar;D:\work\apache-maven-3.8.4\repo\org\apache\commons\commons-lang3\3.4\commons-lang3-3.4.jar;D:\work\apache-maven-3.8.4\repo\org\reflections\reflections\0.9.9-RC1\reflections-0.9.9-RC1.jar;D:\work\apache-maven-3.8.4\repo\dom4j\dom4j\1.6.1\dom4j-1.6.1.jar;D:\work\apache-maven-3.8.4\repo\xml-apis\xml-apis\1.0.b2\xml-apis-1.0.b2.jar;D:\work\apache-maven-3.8.4\repo\org\aspectj\aspectjtools\1.7.4\aspectjtools-1.7.4.jar;D:\work\apache-maven-3.8.4\repo\com\baidu\disconf\disconf-core\2.6.36\disconf-core-2.6.36.jar;D:\work\apache-maven-3.8.4\repo\org\apache\httpcomponents\httpclient\4.5.1\httpclient-4.5.1.jar;D:\work\apache-maven-3.8.4\repo\org\apache\httpcomponents\httpcore\4.4.3\httpcore-4.4.3.jar;D:\work\apache-maven-3.8.4\repo\org\slf4j\slf4j-api\1.7.6\slf4j-api-1.7.6.jar;D:\work\apache-maven-3.8.4\repo\org\aspectj\aspectjrt\1.8.9\aspectjrt-1.8.9.jar;D:\work\apache-maven-3.8.4\repo\org\aspectj\aspectjweaver\1.8.9\aspectjweaver-1.8.9.jar;D:\work\apache-maven-3.8.4\repo\jaxen\jaxen\1.1.4\jaxen-1.1.4.jar;D:\work\apache-maven-3.8.4\repo\com\alibaba\fastjson\1.2.59\fastjson-1.2.59.jar;D:\work\apache-maven-3.8.4\repo\org\apache\kafka\kafka-clients\2.3.0\kafka-clients-2.3.0.jar;D:\work\apache-maven-3.8.4\repo\com\github\luben\zstd-jni\1.4.0-1\zstd-jni-1.4.0-1.jar;D:\work\apache-maven-3.8.4\repo\org\lz4\lz4-java\1.6.0\lz4-java-1.6.0.jar;D:\work\apache-maven-3.8.4\repo\org\xerial\snappy\snappy-java\1.1.7.3\snappy-java-1.1.7.3.jar;D:\work\apache-maven-3.8.4\repo\org\powermock\powermock-reflect\1.5.6\powermock-reflect-1.5.6.jar;D:\work\apache-maven-3.8.4\repo\org\objenesis\objenesis\2.1\objenesis-2.1.jar;D:\work\apache-maven-3.8.4\repo\org\javassist\javassist\3.18.2-GA\javassist-3.18.2-GA.jar;D:\work\apache-maven-3.8.4\repo\org\powermock\powermock-api-support\1.5.6\powermock-api-support-1.5.6.jar;D:\work\apache-maven-3.8.4\repo\org\powermock\powermock-classloading-base\1.5.6\powermock-classloading-base-1.5.6.jar;D:\work\apache-maven-3.8.4\repo\org\powermock\powermock-classloading-xstream\1.5.6\powermock-classloading-xstream-1.5.6.jar;D:\work\apache-maven-3.8.4\repo\com\thoughtworks\xstream\xstream\1.4.2\xstream-1.4.2.jar;D:\work\apache-maven-3.8.4\repo\xmlpull\xmlpull\1.1.3.1\xmlpull-1.1.3.1.jar;D:\work\apache-maven-3.8.4\repo\xpp3\xpp3_min\1.1.4c\xpp3_min-1.1.4c.jar"" com.simo.vsim.dse.startup.DseServerMain 2022-06-10 18:21:34.176 [main] INFO  com.simo.vsim.dse.startup.DseServerMain() - *************** Dse Server is starting ...*************** 2022-06-10 18:21:34.230 [main] INFO  org.springframework.context.support.ClassPathXmlApplicationContext() - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@62230c58: startup date [Fri Jun 10 18:21:34 CST 2022]; root of context hierarchy 2022-06-10 18:21:34.309 [main] INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader() - Loading XML bean definitions from class path resource [appContext.xml] 2022-06-10 18:21:34.450 [main] INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader() - Loading XML bean definitions from class path resource [loadDisConfig.xml] 2022-06-10 18:21:34.486 [main] INFO  org.springframework.context.annotation.ClassPathBeanDefinitionScanner() - JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning 2022-06-10 18:21:34.486 [main] INFO  org.springframework.context.annotation.ClassPathBeanDefinitionScanner() - JSR-330 'javax.inject.Named' annotation found and supported for component scanning Exception in thread ""main"" org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [D:\worksapce\vsim-core\vsim-apps\vsim-dse\target\classes\com\simo\vsim\dse\sim\SimResource.class]; nested exception is java.lang.ArrayIndexOutOfBoundsException: 23309 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:237) 	at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:204) 	at org.springframework.context.annotation.ComponentScanBeanDefinitionParser.parse(ComponentScanBeanDefinitionParser.java:84) 	at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73) 	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1335) 	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1325) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:135) 	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:93) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334) 	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:143) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:178) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:149) 	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:212) 	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:126) 	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:92) 	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:130) 	at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:467) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:397) 	at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:139) 	at org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:83) 	at com.simo.vsim.dse.startup.DseServerMain.main(DseServerMain.java:15) Caused by: java.lang.ArrayIndexOutOfBoundsException: 23309 	at org.springframework.asm.ClassReader.(Unknown Source) 	at org.springframework.asm.ClassReader.(Unknown Source) 	at org.springframework.asm.ClassReader.(Unknown Source) 	at org.springframework.core.type.classreading.SimpleMetadataReader.(SimpleMetadataReader.java:48) 	at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:80) 	at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:101) 	at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:213) 	... 23 more  Process finished with exit code 1","closed","status: invalid,","2509569172","2022-06-10T10:26:22Z","2022-06-10T11:17:40Z"
"","28472","Improve test coverage of RdbmsOperation","1. getSql() 2. tooManyMapParameters()","closed","type: enhancement,","JiayiLi1999","2022-05-18T02:53:54Z","2022-07-29T15:39:23Z"
"","28480","add two more test cases for jdbc","1.  I add test case for getting ket with different key rows in KeyHolderTests.java 2. I add test case for testing query for list in JdbcTemplateQueryTests.java","closed","status: declined,","Robin11223","2022-05-19T05:43:01Z","2022-07-29T15:23:01Z"
"","28096","Support dollar quoting and round brackes to splitSqlScript","- spring-r2dbc `ScriptUtils.splitSqlScript`: Change not to use ; character between $$ ... $$ or ( ... ) as statement separator - [Existing Issue](https://github.com/spring-projects/spring-framework/issues/28090) - Reopen PR with branch issue. sorry. [Existing PR](https://github.com/spring-projects/spring-framework/pull/28091)","open","in: data,","wickedev","2022-02-22T23:15:17Z","2022-04-21T06:56:55Z"
"","28409","Documentation needs to be updated with instructions for STOMP Client","- In https://docs.spring.io/spring-framework/docs/6.0.0-M3/reference/html/web.html#websocket-stomp-enable , the documentation mentions that `JSteunou/webstomp-client` is `jmesnil/stomp-websocket` , which library's most active and maintained development successor. But actually `JSteunou/webstomp-client` stopped updating in 2018 and archived the Git repository. This means that `JSteunou/webstomp-client` will no longer be maintained, I think it should be marked as `JSteunou/webstomp-client` and `jmesnil/stomp-websocket` is no longer maintained. - ![image](https://user-images.githubusercontent.com/20187731/166458366-7ce3e9e9-a022-443a-aafc-becf4ec31a43.png) - ![image](https://user-images.githubusercontent.com/20187731/166458975-e04152c0-8b7f-48a2-81a4-64044f00c86c.png)","open","in: web,","linghengqian","2022-05-03T13:12:37Z","2022-05-09T12:20:52Z"
"","28125","Document that transaction rollback rules may result in unintentional matches","- Follow up to #28098.  - [x] Document that transaction rollback rules may result in unintentional matches for similarly named exceptions and nested classes.","closed","type: documentation,","sbrannen","2022-03-02T16:06:30Z","2022-03-04T15:56:10Z"
"","28876","Fix links in javadoc and documentations","- fix broken links (using their new URL, an alternative URL or a Wayback Machine link), - use HTTPS where possible, - remove https://issuetracker.springsource.com/browse/EBR-349 : this link is dead and is also mentioned in https://jira.spring.io/browse/SPR-8093, - cleanup nohttp `allowlist.lines`.","open","type: documentation,","marcwrobel","2022-07-26T13:48:34Z","2022-08-01T08:53:56Z"
"","28488","Clarify docs on JNDI properties in Servlet environment","- Clarified that JndiPropertySource is always enabled. Previous statement ""can optionally enable"" might have been before #13189 - Mentioned global off switch JndiLocatorDelegate.IGNORE_JNDI_PROPERTY_NAME in StandardServletEnvironment","closed","type: documentation,","arend-von-reinersdorff","2022-05-19T19:36:10Z","2022-07-29T22:59:06Z"
"","28091","Support dollar quoting and round brackes to splitSqlScript","- `ScriptUtils.splitSqlScript`: Change not to use ; character between $$ ... $$ or ( ... ) as statement separator - [Existing Issue](https://github.com/spring-projects/spring-framework/issues/28090)","closed","status: duplicate,","wickedev","2022-02-22T06:13:45Z","2022-02-23T07:34:54Z"
"","28749","Potential Refactoring Estimate","**Summary** I have identified a few classes with refactoring potential along with its estimated time to refactor, specifically ObjectToObjectConverter.java. The estimated time is based on historical commits up to 2021 containing refactoring and the complexity of the involved classes. The class is recently refactored once in commit 97854d9fec8b89783443dd9571c0ce76efd041aa. I would like to know if the estimated time for refactoring matches the actual development time for refactoring.  1. ObjectToObjectConverter.java - 3.5 hours  Thank you.  Regards, Alvin","closed","status: declined,","alvintanjianjia","2022-07-03T02:13:33Z","2022-07-03T12:09:30Z"
"","28003","RabbitMQ clustering - multiple TCP connection not working : springBootVersion = '1.5.11.RELEASE'","**springBootVersion = '1.5.11.RELEASE'** **spring Version = '4.3.15.RELEASE'** **Dependencies used for reabbitmq brocker connection :**  ```  compile group: 'io.projectreactor', name: 'reactor-core', version: '2.0.8.RELEASE'  compile group: 'io.projectreactor', name: 'reactor-net', version: '2.0.8.RELEASE'  compile group: 'io.netty', name: 'netty-all', version: '4.1.22.Final' ``` I'm using RabbitMQ clustering and adding these nodes address in a round-robin fashion using the below code    ``` private Reactor2TcpClient createTcpClient() {         final List addressList = new ArrayList<>();         for (String hostnamesWithPort:hostnamesWithPorts) {             String[] hostNameAndPort = StringUtils.split(hostnamesWithPort,':');  // consider there are 3 nodes added here             addressList.add(new InetSocketAddress(hostNameAndPort[0], Integer.parseInt(hostNameAndPort[1])));         }         final RoundRobinList addresses = new RoundRobinList<>(addressList);         Supplier addressSupplier = new Supplier() {             @Override             public InetSocketAddress get() {                return addresses.get();             }         };         StompDecoder decoder = new StompDecoder();         Reactor2StompCodec codec = new Reactor2StompCodec(new StompEncoder(), decoder);         return new Reactor2TcpClient<>(addressSupplier, codec);     } ```  **The application works fine and it is connecting to one of the nodes first, but if that node failed the application is not picking another address for connection so the clustering is useless. Is there anything that I'm missing here?**","closed","for: external-project,","sharunthomas","2022-02-04T04:42:19Z","2022-02-04T09:37:31Z"
"","28302","Request stucked when multipart streaming enable in webflux","**Spring : 5.3.12 Java : 1.8**  I'm trying to forward the multipart data to another API. I'm successfully able to do it.  ``` 2022-04-07 22:26:06,822 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    Content Type of this request multipart/form-data;boundary=--------------------------011142320810236414887622 2022-04-07 22:26:06,822 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | onSubscribe([Fuseable] FluxMapFuseable.MapFuseableSubscriber) 2022-04-07 22:26:06,822 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | request(unbounded) 2022-04-07 22:26:06,825 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | onNext({res3=[DefaultFormFieldPart{res3}], res2=[DefaultFilePart{res2 (test.txt)}]}) 2022-04-07 22:26:06,825 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    Total size 2 2022-04-07 22:26:06,825 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    FormFieldPart: res3 2022-04-07 22:26:06,825 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    FilePart: res2 2022-04-07 22:26:06,831 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | onComplete() ```  However, I want to enable streaming for multipart so that data directly streamed to backend through webclient. So, Added following configuration  ``` @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer {    @Override   public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {     configurer.defaultCodecs().multipartReader(new MultipartHttpMessageReader(defaultPartHttpMessageReader()));    }      public DefaultPartHttpMessageReader defaultPartHttpMessageReader() {       DefaultPartHttpMessageReader defaultPartHttpMessageReader = new DefaultPartHttpMessageReader();       defaultPartHttpMessageReader.setStreaming(true);       return defaultPartHttpMessageReader;   } } ``` After adding above configuration, if I attach file in multipart request then request get stuck for forever and never completes. Referring to application log, could see following :  ``` 2022-04-07 22:23:27,109 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    Content Type of this request multipart/form-data;boundary=--------------------------227791809638103619563128 2022-04-07 22:23:27,126 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.1""    | onSubscribe([Fuseable] FluxMapFuseable.MapFuseableSubscriber) 2022-04-07 22:23:27,128 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.1""    | request(unbounded) ``` Comparing with working scenario (very first log), `onNext` was not triggered in this scenario. However, if I just send form data as part of multipart request, then it successfully get completed.  ``` 2022-04-07 22:22:06,822 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    Content Type of this request multipart/form-data;boundary=--------------------------227791809638103619563128 2022-04-07 22:22:06,822 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | onSubscribe([Fuseable] FluxMapFuseable.MapFuseableSubscriber) 2022-04-07 22:22:06,822 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | request(unbounded) 2022-04-07 22:22:06,825 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | onNext({res3=[DefaultFormFieldPart{res3}]}) 2022-04-07 22:22:06,825 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    Total size 1 2022-04-07 22:22:06,825 LL=""INFO""  TR=""loopClient-nio-3"" LN=""com.example.demo.MainController""    FormFieldPart: res3 2022-04-07 22:22:06,831 LL=""INFO""  TR=""loopClient-nio-3"" LN=""reactor.Mono.MapFuseable.2""    | onComplete() ```  Could you share input for above issue ?","open","status: waiting-for-triage,","jweavers","2022-04-07T19:09:48Z","2022-04-19T13:41:32Z"
"","28296","No HttpMessageReader for ""multipart/form-data"" and ""org.springframework.http.codec.multipart.Part""","**Spring : 5.3.12 Java   : 1.8**  I'm trying to stream multipart data to another backend service API, which received through ServerRequest in webflux. To ensure data/file gets directly streamed to backend API without saving or holding into the memory. I was trying to enable multipart streaming as described [WebFlux multipart streaming not work](https://github.com/spring-projects/spring-framework/issues/26567#issuecomment-1068415130). But, I'm getting following exception :  ``` LN=""o.s.b.a.w.r.e.AbstractErrorWebExceptionHandler""    [c92f5530-3]  500 Server Error for HTTP POST ""/"" java.lang.IllegalStateException: No HttpMessageReader for ""multipart/form-data"" and ""org.springframework.http.codec.multipart.Part""     at org.springframework.web.reactive.function.BodyExtractors.lambda$findReader$19(BodyExtractors.java:247)     Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  Error has been observed at the following site(s):     |_ checkpoint ⇢ com.example.demo.filter.LoggingWebFilter [DefaultWebFilterChain]     |_ checkpoint ⇢ org.springframework.boot.actuate.metrics.web.reactive.server.MetricsWebFilter [DefaultWebFilterChain]     |_ checkpoint ⇢ HTTP POST ""/"" [ExceptionHandlingWebHandler] Stack trace:         at org.springframework.web.reactive.function.BodyExtractors.lambda$findReader$19(BodyExtractors.java:247)         at java.util.Optional.orElseThrow(Optional.java:290)         at org.springframework.web.reactive.function.BodyExtractors.findReader(BodyExtractors.java:247)         at org.springframework.web.reactive.function.BodyExtractors.lambda$toParts$8(BodyExtractors.java:161)         at org.springframework.web.reactive.function.server.DefaultServerRequest.bodyInternal(DefaultServerRequest.java:167)         at org.springframework.web.reactive.function.server.DefaultServerRequest.body(DefaultServerRequest.java:157)         at com.example.demo.MainController.lambda$2(MainController.java:78)         at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:125)         at reactor.core.publisher.FluxDoOnEach$DoOnEachSubscriber.onNext(FluxDoOnEach.java:173)         at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816)         at reactor.core.publisher.MonoFlatMap$FlatMapInner.onNext(MonoFlatMap.java:249)         at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:120)         at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:101)         at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79)         at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816)         at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:151)         at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)         at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:295)         at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)         at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816)         at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:159)         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142)         at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)         at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:142)         at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:400)         at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:419)         at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:473)         at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:684)         at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:93)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)         at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)         at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) ```   I'm extracting the Parts and creating multipart body to upload to backend using webclient  ``` response = serverRequest.body(BodyExtractors.toParts()).collectList().flatMap(mapper -> {      WebClient webClient = webClientBuilder.build();     return webClient.post()           .uri(""/service/backend"")           .contentType(MediaType.MULTIPART_FORM_DATA)           .body(BodyInserters.fromMultipartData(getMultipartBody(mapper)))           .retrieve();      });     private MultiValueMap> getMultipartBody(List mapper) {   MultipartBodyBuilder builder = new MultipartBodyBuilder();   mapper.stream().forEach(s -> {     if (s instanceof FilePart) {       builder.asyncPart(s.name(), ((FilePart) s).content(), DataBuffer.class)           .filename(((FilePart) s).filename());     } else if (s instanceof FormFieldPart) {       builder.asyncPart(s.name(), ((FormFieldPart) s).content(), DataBuffer.class);     }   });   return builder.build(); } ```  Above code works fine as long as I have not enabled streaming for multipart. What am I missing here ?","closed","status: invalid,","jweavers","2022-04-07T06:35:59Z","2022-04-08T11:54:43Z"
"","28613","EOFException in HttpMessageConverterExtractor while extracting data of a empty GZiped response","**Problem**: When calling RestTemplate#exchange with response type != Void.class, if  - The server responds with   - an _empty body_ and   - _Content-Encoding: gzip_  we get a EOFException in the RestTemplate client.  **Solution**: IntrospectingClientHttpResponse#hasEmptyMessageBody should not throw an exception when the response body is an empty lazy gzip stream.  After reading the first byte, if it receives an EOFException, it should understand it as a signal of the end of the stream, thus returning true to the question ""Has an empty message body?"", not EOFException to the RestTemplate client.  Related issue: https://github.com/spring-projects/spring-framework/issues/12671","open","status: feedback-provided,","davidvieiratrustly","2022-06-13T15:13:29Z","2022-06-30T14:15:41Z"
"","28102","Client ID not set on connection when using Apache Camel with JtaTransactionManager (XA)","**Affects:** v5.3.15 (detected there)  Complete setup involved Apache Camel in conjunction with Narayana Transaction Manager and RedHat Quarkus.  Example project is here:  https://github.com/cquoss/camel-quarkus-xa-from-jms-to-db/tree/topic  Look into the topic branch.  When trying to consume from this durable subscription error 'client id has not been set' is raised: ``` 2022-02-23 18:04:23,097 [Camel (camel-1) thread #1 - JmsConsumer[foo]] [{camel.contextId=camel-1}] DEBUG org.apache.camel.component.jms.DefaultJmsMessageListenerContainer Initiating transaction rollback on listener exception: javax.jms.IllegalStateException: Cannot create durable subscription - client ID has not been set         at org.apache.activemq.artemis.jms.client.ActiveMQSession.createConsumer(ActiveMQSession.java:876)         at org.apache.activemq.artemis.jms.client.ActiveMQSession.createDurableSubscriber(ActiveMQSession.java:596)         at org.springframework.jms.listener.AbstractMessageListenerContainer.createConsumer(AbstractMessageListenerContainer.java:863)         at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.createListenerConsumer(AbstractPollingMessageListenerContainer.java:224)         at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:300)         at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:245)         at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1237)         at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1227)         at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1120)         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)         at java.base/java.lang.Thread.run(Thread.java:829) ```  Problem lies before in establishing the (non-shared) connection: ``` 2022-02-23 18:04:22,840 [Camel (camel-1) thread #1 - JmsConsumer[foo]] [{camel.contextId=camel-1}] TRACE org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryImpl getConnectionWithRetry::1 with retryInterval = 2000 multiplier = 1.0: java.lang.Exception: trace         at org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryImpl.getConnectionWithRetry(ClientSessionFactoryImpl.java:818)         at org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryImpl.connect(ClientSessionFactoryImpl.java:252)         at org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryImpl.connect(ClientSessionFactoryImpl.java:268)         at org.apache.activemq.artemis.core.client.impl.ServerLocatorImpl.createSessionFactory(ServerLocatorImpl.java:688)         at org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory.createConnectionInternal(ActiveMQConnectionFactory.java:884)         at org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory.createConnection(ActiveMQConnectionFactory.java:299)         at org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory.createConnection(ActiveMQConnectionFactory.java:294)         at org.springframework.jms.support.JmsAccessor.createConnection(JmsAccessor.java:196)         at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.access$100(AbstractPollingMessageListenerContainer.java:77)         at org.springframework.jms.listener.AbstractPollingMessageListenerContainer$MessageListenerContainerResourceFactory.createConnection(AbstractPollingMessageListenerContainer.java:490)         at org.springframework.jms.connection.ConnectionFactoryUtils.doGetTransactionalSession(ConnectionFactoryUtils.java:325)         at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:281)         at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:245)         at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1237)         at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1227)         at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:1120)         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)         at java.base/java.lang.Thread.run(Thread.java:829) ``` Code of setting the client id on connection has to be moved to a `prepareConnection(...)` method as i provided here:  https://github.com/cquoss/spring-framework/blob/c42b73cf4bf4147e2b6190f98d5efa8038816534/spring-jms/src/main/java/org/springframework/jms/listener/AbstractJmsListeningContainer.java#L424  I left `prepareSharedConnection(...)` in place, but empty, for compatibility:  https://github.com/cquoss/spring-framework/blob/c42b73cf4bf4147e2b6190f98d5efa8038816534/spring-jms/src/main/java/org/springframework/jms/listener/AbstractJmsListeningContainer.java#L459  Please suggest, comment or complain.","open","in: data,","cquoss","2022-02-24T15:48:51Z","2022-02-25T15:16:29Z"
"","28878","AbstractApplicationContext.refresh() leaves bean resources uncleaned for special cases of faulty start-up","**Affects:** Tested with 5.3.22 and 5.2.20.RELEASE  **Problem description:** For some configuration issues during application context creation the AbstractApplicationContext.refresh() method is not executing the catch(BeansException ex)/clean block. In this cleanup-block already created beans are getting destroyed by calling their close method. Especially for JUnit 5 annotated classes with @ExtendWith(SpringExtension.class) this may cause potential resource leaks as for every test method depending on a faulty context the context will be tried to recreated without previous clean-up of resources which stay alive.  In a real world project the faulty, not destroyed, test contexts consumed all database connections of a shared DBMS as the created Hikari CP DataSource Pool was not closed/freed by AbstractApplicationContext.refresh(). At the end the amount of not cleaned up test contexts also caused an OutOfMemoryError as Hikari CP makes use of background threads and so references survive the garbage collector for the no longer used AbstractApplicationContext.  I attached a sample project   [test-app.zip](https://github.com/spring-projects/spring-framework/files/9198706/test-app.zip) with two ""test samples/cases"" (src/test/java/app) which will both cause a not successful application context creation but with two different behaviours of the clean-up:  1. For ""LeakTest"" the close method of ""DummyDbcp"" will not be called by AbstractApplicationContext, also the bean was created in the application context. The text ""Pool closed, db connections released"" is not printed to STDOUT via logger. 2. For ""NonCausingLeakTest"" the close method of ""DummyDbcp"" will be called by AbstractApplicationContext, preventing against resource leaks. The text ""Pool closed, db connections released"" is printed to STDOUT via logger.  The pom.xml of the project makes use of spring-boot-starter's, but only spring-framework components are really used.  Best regards, Philipp Förmer","open","in: core,","pfoermer","2022-07-27T12:30:54Z","2022-07-27T12:41:13Z"
"","28456","SPEL: Not unique cache key for PropertyOrFieldReference when evaluating fragment","**Affects:** SpringBoot 2.6.6, Spring Expression 5.3.18  ---  Hi, engineers.  I think I have found an issue regarding PropertyCacheKey. An exception is thrown when I load a login page (containing following fragment) for the first time an application is started.  I am using following template in spring:  ```           ``` The difference between two scripts is the IF attribute, which contains **authentication.principal.class.name** or **authentication.class.name**. And the order matters.  Problem with this is that both attributes are represented by the same cacheKey (className(=AnonymousAuth class) and propertyName(=name)). So, when the second part of fragment is being evaluated, there is an exception thrown **java.lang.IllegalArgumentException: object is not an instance of declaring class.** because a getNameOfPrincipal method getter has been returned from a cache, which is an invalid invocation on a AnonymousAuthentication.  There is a simple workaround, I can use canonicalName for a second part of fragment, but anyway, I would expect this to work. I consider this to be low severity and maybe there would be simpler more convinient way how to achieve this behaviour.  Exception: ``` java.lang.IllegalArgumentException: object is not an instance of declaring class 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:704) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:204) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference.access$000(PropertyOrFieldReference.java:51) 	at org.springframework.expression.spel.ast.PropertyOrFieldReference$AccessorLValue.getValue(PropertyOrFieldReference.java:406) 	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:92) 	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:42) 	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:32) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:188) 	at org.springframework.expression.spel.ast.OpAnd.getBooleanValue(OpAnd.java:57) 	at org.springframework.expression.spel.ast.OpAnd.getValueInternal(OpAnd.java:52) 	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) 	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:338) 	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:265) 	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) 	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) 	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:125) 	at org.thymeleaf.standard.processor.StandardIfTagProcessor.isVisible(StandardIfTagProcessor.java:59) 	at org.thymeleaf.standard.processor.AbstractStandardConditionalVisibilityTagProcessor.doProcess(AbstractStandardConditionalVisibilityTagProcessor.java:61) 	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) 	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) 	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) 	at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) 	at org.thymeleaf.engine.Model.process(Model.java:282) 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) 	at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) 	at org.thymeleaf.engine.Model.process(Model.java:282) 	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1587) 	at org.thymeleaf.engine.OpenElementTag.beHandled(OpenElementTag.java:205) 	at org.thymeleaf.engine.TemplateModel.process(TemplateModel.java:136) 	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:592) 	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) 	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) 	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:366) 	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:190) 	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1401) 	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1145) 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1084) 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) 	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:655) 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:204) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.saml.SAMLLogoutFilter.processLogout(SAMLLogoutFilter.java:168) 	at org.springframework.security.saml.SAMLLogoutFilter.doFilter(SAMLLogoutFilter.java:110) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.saml.SAMLLogoutProcessingFilter.processLogout(SAMLLogoutProcessingFilter.java:209) 	at org.springframework.security.saml.SAMLLogoutProcessingFilter.doFilter(SAMLLogoutProcessingFilter.java:107) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:219) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:213) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:219) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:213) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.saml.metadata.MetadataDisplayFilter.doFilter(MetadataDisplayFilter.java:84) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.saml.metadata.MetadataGeneratorFilter.doFilter(MetadataGeneratorFilter.java:87) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.saml.SAMLDiscovery.doFilter(SAMLDiscovery.java:137) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.saml.SAMLEntryPoint.doFilter(SAMLEntryPoint.java:102) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:219) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:213) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter.doFilter(ResourceUrlEncodingFilter.java:67) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:239) 	at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:215) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at com.xxxx.utils.BizUrlFilter.doFilter(BizUrlFilter.java:62) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:115) 	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:81) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:122) 	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:116) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at com.xxxx.utils.SecurityGroupsFilter.doFilterInternal(SecurityGroupsFilter.java:125) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126) 	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:109) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:136) 	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:93) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:204) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:219) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:213) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:219) 	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:213) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103) 	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.csrf.CsrfFilter.doFilterInternal(CsrfFilter.java:117) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90) 	at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110) 	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.saml.metadata.MetadataGeneratorFilter.doFilter(MetadataGeneratorFilter.java:87) 	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336) 	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211) 	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183) 	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:354) 	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:267) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:142) 	at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:82) 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) 	at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:96) ```  I really appretiate your time, thank you for your amazing work!","open","status: waiting-for-triage,","dbydzovsky","2022-05-12T12:46:23Z","2022-05-12T12:53:28Z"
"","28008","Jetty10RequestUpgradeStrategy - WebSocketCreatorInterceptor IndexOutOfBoundsException","**Affects:** spring-websocket: 5.3.14, Jetty 10.0.7 --- When using the Jetty10RequestUpgradeStrategy for websocket support in Jetty 10.0.7 i get the following exception on the upgrade call:   ` Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2 	at org.springframework.web.socket.server.jetty.Jetty10RequestUpgradeStrategy$WebSocketCreatorInterceptor.invoke(Jetty10RequestUpgradeStrategy.java:161) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215) 	at com.sun.proxy.$Proxy161.createWebSocket(Unknown Source) 	at org.eclipse.jetty.websocket.server.JettyWebSocketServerContainer.lambda$upgrade$2(JettyWebSocketServerContainer.java:173) 	at org.eclipse.jetty.websocket.core.server.internal.CreatorNegotiator.lambda$negotiate$0(CreatorNegotiator.java:64) 	at org.eclipse.jetty.server.handler.ContextHandler.handle(ContextHandler.java:1445) 	at org.eclipse.jetty.server.handler.ContextHandler.handle(ContextHandler.java:1482) 	at org.eclipse.jetty.websocket.core.server.internal.CreatorNegotiator.negotiate(CreatorNegotiator.java:63) 	at org.eclipse.jetty.websocket.core.server.internal.AbstractHandshaker.upgradeRequest(AbstractHandshaker.java:76) 	at org.eclipse.jetty.websocket.core.server.internal.HandshakerSelector.upgradeRequest(HandshakerSelector.java:39) 	at org.eclipse.jetty.websocket.server.JettyWebSocketServerContainer.upgrade(JettyWebSocketServerContainer.java:177) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:282) 	at org.springframework.web.socket.server.jetty.Jetty10RequestUpgradeStrategy.upgrade(Jetty10RequestUpgradeStrategy.java:118) 	... 96 common frames omitted `  The reason seems to be the WebSocketCreatorInterceptor and in here the   ` @Nullable @Override    public Object invoke(@NonNull MethodInvocation invocation) {       if (this.protocol != null) {           ReflectionUtils.invokeMethod( 						setAcceptedSubProtocol, invocation.getArguments()[2], this.protocol); 			} 		return this.adapter; 	} `  The proxy is created from the jetty based interface  `JettyWebSocketCreator` which has only two arguments.","closed","status: duplicate,","mreiterer","2022-02-04T11:28:53Z","2022-02-07T11:02:49Z"
"","28587","Avoid parsing request body in DispatcherServlet for ""parameters={masked}"" log message","**Affects:** spring-webmvc-5.3.20 and possibly many more  When having trace logging enabled... e.g. ``` logging:   level:     org.springframework.web: TRACE ```  and sending a **POST** request with content type **application/x-www-form-urlencoded**, the body of the request may be consumed by trace logging and only an empty stream or reader be available for the application.  The reason seems to be this line: https://github.com/spring-projects/spring-framework/blob/main/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L988  Even though it only attempts to check for existence of parameters it also triggers parsing of parameters which seems to consume the request body.","closed","type: enhancement,","mibollma","2022-06-08T19:05:11Z","2022-07-01T08:42:34Z"
"","28348","ActiveProfile is not picked up, if customize the Environment before it starts","**Affects:** spring-core 5.3.18  I'm tried to set active profile by customizing the Environmvent. Created simple spring-boot application 2.6.6 as below.  ``` @SpringBootApplication public class Spring5318activeprofileApplication { 	public static void main(String[] args) { 		new SpringApplicationBuilder(Spring5318activeprofileApplication.class) 				.listeners(new MyListener()) 				.build(args) 				.run(args); 	} } ```  Add listener, based on sample https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.application.customize-the-environment-or-application-context ``` public class MyListener implements ApplicationListener {      private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();      @Override     public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {         ConfigurableEnvironment environment = event.getEnvironment();         Resource path = new ClassPathResource(""cfg.yml"");         PropertySource propertySource = loadYaml(path);         environment.getPropertySources().addLast(propertySource);     }      private PropertySource loadYaml(Resource path) {         Assert.isTrue(path.exists(), () -> ""Resource "" + path + "" does not exist"");         try {             return this.loader.load(""custom-resource"", path).get(0);         } catch (IOException ex) {             throw new IllegalStateException(""Failed to load yaml configuration from "" + path, ex);         }     } } ```  cfg.yml is simple ``` spring:   profiles:     active: p1 ```  This profile is not picked up (if debug) by org\springframework\core\env\AbstractEnvironment.java after adding custom PropertySource ``` protected Set doGetActiveProfiles() { 		synchronized (this.activeProfiles) { 			if (this.activeProfiles.isEmpty()) { 				String profiles = doGetActiveProfilesProperty(); 				if (StringUtils.hasText(profiles)) { 					setActiveProfiles(StringUtils.commaDelimitedListToStringArray( 							StringUtils.trimAllWhitespace(profiles))); 				} 			} 			return this.activeProfiles; 		} 	} ```  Variable profiles is **null** because doGetActiveProfilesProperty() return **null**. So active profile is not set.  **Looks like it's incorrect behaviour.**   In earlier version, for example in spring-core 5.1.7, there is little difference in getting profile variable but it worked.  org\springframework\core\env\AbstractEnvironment was: ``` protected Set doGetActiveProfiles() {         synchronized(this.activeProfiles) {             if (this.activeProfiles.isEmpty()) {                 String profiles = this.getProperty(""spring.profiles.active"");                 if (StringUtils.hasText(profiles)) {                     this.setActiveProfiles(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(profiles)));                 }             }              return this.activeProfiles;         }     } ```  In debug for spring-core 5.3.18 ``` String profiles = doGetActiveProfilesProperty();                 --> gives null     -- it's INCORRECT String profiles = this.getProperty(""spring.profiles.active""); ---> gives p1     -- it's correct ```   pom.xml ```  		org.springframework.boot 		spring-boot-starter-parent 		2.6.6 		  	  	com.and 	spring5318activeprofile 	0.0.1-SNAPSHOT 	spring5318activeprofile 	check active profile  	 		1.8 	  	 		 			org.springframework.boot 			spring-boot-starter-web 		  		 			org.springframework.boot 			spring-boot-starter-test 			test 		 	  	 		 			 				org.springframework.boot 				spring-boot-maven-plugin 			 		 	 ```   ---","open","status: waiting-for-triage,","alexandgit","2022-04-15T12:04:28Z","2022-04-15T12:07:31Z"
"","28357","Spring Data: query with null handling not working","**Affects:** spring-boot 2.6.6  While trying to write a query via Spring Data, I found a confusing bug:  Look at following two methods. Only difference is the order in the `where` block  ``` // not working @RestResource(path = ""description1"") @Query(""select u from User u where description like %:description% or :description is null"") List findByDescription1(String description);  // working @RestResource(path = ""description2"") @Query(""select u from User u where :description is null or description like %:description%"") List findByDescription2(String description); ```  Calling them both give different results: - Calling both without any parameter results the same - `/api/widgetTeamDaten/search/description1?description=test`   - 0 results - `/api/widgetTeamDaten/search/description2?description=test`   - 2 results  Looking up, what Hibernate is doing whith the parameters, in description1 the parameter is bound with `test`, in description2 with `%test%`: ``` /api/userDaten/search/description1 -> 3 matches select user0_.id as id1_211_, user0_.version as version2_211_,  user0_.name as name3_211_, user0_.description as descript4_211_ from users user0_ where user0_.description like ? or ? is null binding parameter [1] as [VARCHAR] - [null] binding parameter [2] as [VARCHAR] - [null]  /api/userDaten/search/description1?description=test -> 0 matches select user0_.id as id1_211_, user0_.version as version2_211_,  user0_.name as name3_211_, user0_.description as descript4_211_ from users user0_ where user0_.description like ? or ? is null binding parameter [1] as [VARCHAR] - [test] binding parameter [2] as [VARCHAR] - [test]  /api/userDaten/search/description2?description=test -> 2 matches select user0_.id as id1_211_, user0_.version as version2_211_,  user0_.name as name3_211_, user0_.description as descript4_211_ from users user0_ where ? is null or user0_.description like ? binding parameter [1] as [VARCHAR] - [%test%] binding parameter [2] as [VARCHAR] - [%test%]  /api/userDaten/search/description2 -> 3 matches select user0_.id as id1_211_, user0_.version as version2_211_,  user0_.name as name3_211_, user0_.description as descript4_211_ from users user0_ where ? is null or user0_.description like ? binding parameter [1] as [VARCHAR] - [null] binding parameter [2] as [VARCHAR] - [null] ```  There should be the same results, independent on the order in the where statement.","open","status: waiting-for-triage,","bastianschott","2022-04-19T08:26:25Z","2022-04-19T09:08:24Z"
"","28405","jsonPath().value ResultMatcher fails for nested objects","**Affects:** Spring Test 5.3.17  Trying to set an expectation on a JSON body returned by a `@RestController`'s endpoint inside its dedicated `MockMvc` test fails unexpectedly when trying to match whole JSON object instead of a single property.  This is the method for reproduction ```java @GetMapping(""/test"")   public ResponseEntity testJson() {     return new ResponseEntity(""{\""root\"":{\""prop1\"":\""1\"",\""prop2\"":\""2\""}}"", HttpStatus.OK);  } ``` And this is its test with two different expectations issued alternatively and with an explicit wrong match to let console show extracted node. ## The first one was supposed to simply return the complete node ```java  @Test void fail_json_path() throws Exception {   mockMvc.perform(get(""/test"")     .contentType(MediaType.APPLICATION_JSON))   .andExpect(jsonPath(""$.root"").value(""wrong_match"")); } ``` but it returns `null` as if `root` node wasn't present at all  `java.lang.AssertionError: JSON path ""$.root"" expected: but was:`  ## The second one should have identical output in this case inserted as single element inside a list ```java @Test void fail_json_path() throws Exception {   mockMvc.perform(get(""/test"")     .contentType(MediaType.APPLICATION_JSON))   .andExpect(jsonPath(""$..root"").value(""wrong_match"")); } ``` instead it surprisingly works almost as expected, but strips quotes and doesn't push result inside the list, and most of all turn colons `:` into equal signs `=`  `JSON path ""$..root"" expected: but was:<{prop1=1, prop2=2}>`  #### To show what I expected as output for the first example, this is a screen from [this testing app](http://jsonpath.herokuapp.com) with the same context ![immagine](https://user-images.githubusercontent.com/459381/166168745-3a53e6ad-d12f-4919-9c8f-11d40e7a3eaf.png)  I think the quotes stripping can be considered an implementation choice, but first result looks like a bug.","closed","status: waiting-for-triage,","4javier","2022-05-01T23:35:21Z","2022-05-03T23:52:22Z"
"","28175","Kotlin delegation compiler issue when trying to override","**Affects:** Spring Boot JPA v 2.6.4  There appears to be a compiler issue when attempting to override interface methods with Spring for a Kotlin class using delegation. I cannot reproduce the issue with pure Kotlin interfaces so guessing it's something to do with the Spring plugins.  Brief overview below. Full repro [here](https://github.com/irishshagua/SpringKotlin-BugRepro)  ```kotlin package kotlincompilerbug  import org.springframework.data.jpa.repository.JpaRepository import java.util.*  interface SomeRepo : JpaRepository  class ConcreteImplWithOverrides(val springGeneratedSomeRepoImpl: SomeRepo) : SomeRepo by springGeneratedSomeRepoImpl {      // This is allowed by the compiler     override fun  save(entity: S): S { TODO(""Not yet implemented"") }      // This fails to compile     // Conflicting overloads: public open fun findById(id: Long): Optional defined in ConcreteImplWithOverrides,     // public open fun findById(id: Long): Optional defined in ConcreteImplWithOverrides     override fun findById(id: Long): Optional { TODO(""Not yet implemented"") } } ```","closed","in: kotlin,","irishshagua","2022-03-13T13:53:01Z","2022-03-15T10:15:12Z"
"","28058","Improve documentation for uri(URI) method in WebTestClient regarding base URI","**Affects:** Spring Boot 2.6.3 and below  ---  During one of my integration tests, to test one endpoint I encountered the following error:  > org.springframework.web.reactive.function.client.WebClientRequestException: Connection refused  I'm using the webflux starter version 2.6.3, but the problem I'm describing is reproducible with lower version.  These are the annotations applied to my test:   ```java @SpringBootTest(webEnvironment = RANDOM_PORT) @ActiveProfiles(""test"") @Sql(""classpath:sql/my_sql.sql"") @Import(TestConfig.class) ```  and this is the code is raising the issue:  ```java         URI uri = UriComponentsBuilder                 .fromUriString(MY_URL)                 .queryParam(""year"", 2005)                 .buildAndExpand()                 .toUri();          client.get()                 .uri(uri)                 .exchange()                 .expectStatus()                 .is2xxSuccessful(); ```  After analyzing the problem, I found out that the issue is caused by the use of `@SpringBootTest(webEnvironment = RANDOM_PORT)` without `@AutoConfigureWebTestClient` (this should be possible since `@SpringBootTest` registers a `WebTestClient`) and the use of the `S uri(URI uri);` implementation in the `UriSpec` interface inside the `WebTestClient` interface.   In other words by rewriting the test as:  ```java         URI uri = UriComponentsBuilder                 .fromUriString(MY_URL)                 .queryParam(""year"", 2005)                 .buildAndExpand()                 .toUri();          client.get()                 .uri(uri.toString) // Using another method to specify the URI                 .exchange()                 .expectStatus()                 .is2xxSuccessful(); ```  The `DefaultWebTestClient` is injected with a `uriBuilderFactory` (`DefaultUriBuilderFactory`) where its field `private final UriComponentsBuilder baseUri;` is not null.  In the first case the URI returned is missing the base URI (`http//host:port/` -- for example, `/myUrl?year=2005`), whilst in the second case the URI returned contains the base URI (`http//host:port/myUrl?year=2005`).  Another workaround is to put (a redundant) annotation:  ```java @SpringBootTest(webEnvironment = RANDOM_PORT) @ActiveProfiles(""test"") @Sql(value = ""classpath:sql/my_sql.sql"") @Import({TestConfig.class}) @AutoConfigureWebTestClient // the DefaultWebTestClient will be injected with different property values. ```  In this case the `DefaultWebTestClient` is injected with `private final UriComponentsBuilder baseUri;` equals to null, then the methods:  ```java S uri(URI uri);  S uri(String uri, Object... uriVariables); ```  are consistent: both return the URI without the base URI, but in this case everything works.","closed","in: web,","SimoneGiusso","2022-02-16T08:30:47Z","2022-02-16T11:18:11Z"
"","27963","@Around advice doesn't work with OncePerRequestFilter","**Affects:** Spring Boot 2.5.6 (Both AOP and Web are 2.5.6)  Greetings,  I'm relatively new to Spring, but after a bit of Googling this seems like an issue with interconnection between different Spring components. Or maybe I'm just using them wrong? Please advise if so, otherwise this just might be an unfortunate bug?  I'm trying to add a traceId entry to our logs via MDC.  I've created a filter that extends `OncePerRequestFilter` which doesn't really do anything, except serves as a place to attach an advice to.  ```kotlin @Component class TraceIdFilter : OncePerRequestFilter() {      @Traceable     override fun doFilterInternal(         request: HttpServletRequest,         response: HttpServletResponse,         filterChain: FilterChain     ) {         filterChain.doFilter(request, response)     } } ```  I have an `@Around` advice:  ```kotlin @Aspect @Component class TraceableRequestAspect(private val uuid: () -> UUID) {      @Around(""@annotation(Traceable)"")     fun advice(joinPoint: ProceedingJoinPoint) {         try {             MDC.put(LogstashField.TRACE_ID, ""${uuid()}"")             joinPoint.proceed()         } finally {             MDC.remove(LogstashField.TRACE_ID)         }     } } ```  I expect that the Around advice will 'wrap' the filter method and attach an MDC entry to all HTTP request logs and then clean up after itself.  In reality, this is what I'm seeing:  ``` 2022-01-20 14:42:54.147  INFO 23739 --- [           main] o.s.aop.framework.CglibAopProxy          : Unable to proxy interface-implementing method [public final void org.springframework.web.filter.OncePerRequestFilter.doFilter(javax.servlet.ServletRequest,javax.servlet.ServletResponse,javax.servlet.FilterChain) throws javax.servlet.ServletException,java.io.IOException] because it is marked as final: Consider using interface-based JDK proxies instead! 2022-01-20 14:42:54.147  INFO 23739 --- [           main] o.s.aop.framework.CglibAopProxy          : Unable to proxy interface-implementing method [public final void org.springframework.web.filter.GenericFilterBean.init(javax.servlet.FilterConfig) throws javax.servlet.ServletException] because it is marked as final: Consider using interface-based JDK proxies instead! 2022-01-20 14:42:54.211 ERROR 23739 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Exception starting filter [traceIdFilter]  java.lang.NullPointerException: null 	at org.springframework.web.filter.GenericFilterBean.init(GenericFilterBean.java:241) 	at org.apache.catalina.core.ApplicationFilterConfig.initFilter(ApplicationFilterConfig.java:270) 	at org.apache.catalina.core.ApplicationFilterConfig.(ApplicationFilterConfig.java:105) 	at org.apache.catalina.core.StandardContext.filterStart(StandardContext.java:4613) 	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5256) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:835) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1396) 	at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1386) 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) 	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75) 	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:140) 	at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:919) 	at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:263) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardService.startInternal(StandardService.java:432) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:927) 	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:183) 	at org.apache.catalina.startup.Tomcat.start(Tomcat.java:486) 	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:123) 	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.(TomcatWebServer.java:104) 	at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:450) 	at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:199) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:182) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:160) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:577) 	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:145) 	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) 	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:434) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:338) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1332) 	at net.leoncorp.ft.integration.ApplicationKt.main(Application.kt:14)  2022-01-20 14:42:54.212 ERROR 23739 --- [           main] o.apache.catalina.core.StandardContext   : One or more Filters failed to start. Full details will be found in the appropriate container log file 2022-01-20 14:42:54.212 ERROR 23739 --- [           main] o.apache.catalina.core.StandardContext   : Context [] startup failed due to previous errors 2022-01-20 14:42:54.254  INFO 23739 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat] ```  I'm not sure whether I can follow the advice the error message throws as none of the code responsible for this is under my purview.  Thanks in advance for any assistance.","closed","status: invalid,","nexsja","2022-01-20T12:53:00Z","2022-07-23T07:40:00Z"
"","27975","Bean 'org.springframework.retry.annotation.RetryConfiguration' not eligible for getting processed by all BeanPostProcessors","**Affects:** Spring Boot 2.3.12.RELEASE  ---  Given these dependencies:  ```groovy plugins { 	id 'org.springframework.boot' version '2.3.12.RELEASE' 	id 'io.spring.dependency-management' version '1.0.11.RELEASE' 	id 'java' }  group = 'com.example' version = '0.0.1-SNAPSHOT' sourceCompatibility = '11'  repositories { 	mavenCentral() }  dependencies { 	implementation 'org.springframework.boot:spring-boot-starter-actuator' 	implementation 'org.springframework.boot:spring-boot-starter' 	implementation 'org.springframework.retry:spring-retry' 	implementation 'org.springframework:spring-aspects'  	testImplementation 'org.springframework.boot:spring-boot-starter-test' }  tasks.named('test') { 	useJUnitPlatform() }  ```  and having retry mechanism enabled:  ```java @SpringBootApplication @EnableRetry public class DemoApplication {  	public static void main(String[] args) { 		SpringApplication.run(DemoApplication.class, args); 	}  } ```  I receive   ``` 2022-01-25 13:37:51.354  INFO 7056 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.retry.annotation.RetryConfiguration' of type [org.springframework.retry.annotation.RetryConfiguration$$EnhancerBySpringCGLIB$$4b28449d] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying) ```  and **retry mechanism isn't working**. Similar bug has been fixed in `5.2.4` as mentioned [here](https://github.com/spring-projects/spring-framework/issues/24508). I have newer spring-context version `5.2.15.RELEASE` and it still reproduces.  Looks like actuator dependency is in conflict with retry.","closed","for: external-project,","mbadziong","2022-01-25T12:45:39Z","2022-01-26T09:34:52Z"
"","28856","Spring Reactive Web uses kotlin serialization over jackson for its own classes, and it's very hard to change","**Affects:** Spring 5.3.21  This is somewhat related to #26321 - Spring using kotlin serialization over jackson  (but not the same, as that's for WebMVC).  In Reactive Web, Kotlin classes that are tagged as `@Serializable` use Kotlin Serializers, not Jackson. This is a reasonable default, but changing the behaviour is very difficult, and has a few surprising side effects.  In Spring WebMVC, we could re-order the `HttpMessageConverter<>`, and put Jackson first:  ```kotlin // The approach we've used for WebMVC - there's no analogus support in WebFlux. @Configuration class WebConfig : WebMvcConfigurationSupport() {   override fun configureMessageConverters(converters: MutableList?>) {     super.addDefaultHttpMessageConverters(converters)     converters.sortBy { converter -> if (converter is KotlinSerializationJsonHttpMessageConverter) 1000 else 0 }   } } ```  The contract of `WebFluxConfigurer` doesn't allow modification of the list - because the `BaseCodecConfigurer` returns a new list each time:  ``` 	@Override 	public List> getWriters() { 		this.defaultCodecs.applyDefaultConfig(this.customCodecs);  		List> result = new ArrayList<>(); 		result.addAll(this.customCodecs.getTypedWriters().keySet()); 		result.addAll(this.defaultCodecs.getTypedWriters()); 		result.addAll(this.customCodecs.getObjectWriters().keySet()); 		result.addAll(this.defaultCodecs.getObjectWriters()); 		result.addAll(this.defaultCodecs.getCatchAllWriters()); 		return result; 	} ```  Therefore, adding any sort like in WebMVC has no effect.  Changing the Kotlin encoder to null (to try to disable), doesn't work, as `BaseDefaultCodecs` simply adds it back:  ``` 	@Override 	public void kotlinSerializationJsonEncoder(Encoder encoder) { 		this.kotlinSerializationJsonEncoder = encoder; 		initObjectWriters(); // triggers a call to getBaseObjectWriters() 	}         final List> getBaseObjectWriters() { 		List> writers = new ArrayList<>(); 		if (kotlinSerializationJsonPresent) { 			addCodec(writers, new EncoderHttpMessageWriter<>(getKotlinSerializationJsonEncoder())); 		} 		...snip... 		return writers; 	} ```  The workaround I've used is to put a decorator around the configurer to re-order every single time.  However, this seems awkward.  ```kotlin @Configuration class CustomerWebFluxConfigSupport : WebFluxConfigurationSupport() {    override fun serverCodecConfigurer(): ServerCodecConfigurer {       return ReOrderingServerCodecConfigurer(super.serverCodecConfigurer())    }     class ReOrderingServerCodecConfigurer(private val configurer: ServerCodecConfigurer) :       ServerCodecConfigurer by configurer {        override fun getWriters(): MutableList> {          val writers = configurer.writers          val jacksonWriterIndex =             configurer.writers.indexOfFirst { it is EncoderHttpMessageWriter && it.encoder is Jackson2JsonEncoder }          val kotlinSerializationWriterIndex =             configurer.writers.indexOfFirst { it is EncoderHttpMessageWriter && it.encoder is KotlinSerializationJsonEncoder }           if (kotlinSerializationWriterIndex == -1 || jacksonWriterIndex == -1) {             return writers          }           if (kotlinSerializationWriterIndex < jacksonWriterIndex) {             Collections.swap(writers, jacksonWriterIndex, kotlinSerializationWriterIndex)          }          return writers       }    } } ```  ### Expected / Desired Behaviour It'd be nice if there was an easier way to configure this.  At the very least, where `BaseDefaultCodecs` overwrites the changed Kotlin serializer feels like a bug.","open","in: kotlin,","martypitt","2022-07-22T13:25:49Z","2022-08-01T09:15:31Z"
"","28123","Sending message to ActiveMQ takes longer than the specified timeout","**Affects:** org.springframework:spring-jms:5.3.14  ### Setup  - Service with Spring Version 5.3.14 - ActiveMQ mq.t3.micro with no free space - application.config:  ```yaml   activemq:     broker-url: failover:(ssl://:61617,ssl://:61617)?randomize=true&maxReconnectAttempts=1&startupMaxReconnectAttempts=1&maxReconnectDelay=2000     user:     password:      send-timeout: 3000     pool:       enabled: true       max-connections: 20   jms:     template:       qos-enabled: true       time-to-live: 86400000     pub-sub-domain: true     cache:       enabled: false ```  ### Expected behavior  If the method  `public void send(final String destinationName, final MessageCreator messageCreator) throws JmsException` in the `JmsTemplate` class is executed, the maximum running time is as in send-timeout configured, about 3 seconds.  ### Observed behavior  We see some calls that go up to 5 minutes in execution time, when this jms method is called.  It is interesting, however, as soon as a TCP connection to the MQ is established, the 3 seconds are running out and the Lib then throws a timeout as expected `org.apache.activemq.transport.RequestTimedOutIOException` the activemq log does not contain any useful information. The only warnings we see are:  ``` 2022-03-02 06:58:12,093 | WARN | Transport Connection to: tcp://:40600 failed | org.apache.activemq.broker.TransportConnection.Transport | ActiveMQ InactivityMonitor Worker java.net.SocketException: Connection reset at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:115)[:1.8.0_322] at java.net.SocketOutputStream.write(SocketOutputStream.java:155)[:1.8.0_322] at sun.security.ssl.SSLSocketOutputRecord.deliver(SSLSocketOutputRecord.java:319)[:1.8.0_322] at sun.security.ssl.SSLSocketImpl$AppOutputStream.write(SSLSocketImpl.java:1214)[:1.8.0_322] at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.flush(TcpBufferedOutputStream.java:115)[activemq-client-5.15.15.jar:5.15.15] at java.io.DataOutputStream.flush(DataOutputStream.java:123)[:1.8.0_322] at org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:194)[activemq-client-5.15.15.jar:5.15.15] at org.apache.activemq.transport.AbstractInactivityMonitor.doOnewaySend(AbstractInactivityMonitor.java:335)[activemq-client-5.15.15.jar:5.15.15] at org.apache.activemq.transport.AbstractInactivityMonitor.access$800(AbstractInactivityMonitor.java:42)[activemq-client-5.15.15.jar:5.15.15] at org.apache.activemq.transport.AbstractInactivityMonitor$4.run(AbstractInactivityMonitor.java:201)[activemq-client-5.15.15.jar:5.15.15] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)[:1.8.0_322] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)[:1.8.0_322] at java.lang.Thread.run(Thread.java:750)[:1.8.0_322]  2022-03-02 06:58:12,093 | WARN | Transport Connection to: tcp://:40600 failed | org.apache.activemq.broker.TransportConnection.Transport | ActiveMQ InactivityMonitor Worker java.net.SocketException: Connection reset at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:115)[:1.8.0_322] at java.net.SocketOutputStream.write(SocketOutputStream.java:155)[:1.8.0_322] at sun.security.ssl.SSLSocketOutputRecord.deliver(SSLSocketOutputRecord.java:319)[:1.8.0_322] at sun.security.ssl.SSLSocketImpl$AppOutputStream.write(SSLSocketImpl.java:1214)[:1.8.0_322] at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.flush(TcpBufferedOutputStream.java:115)[activemq-client-5.15.15.jar:5.15.15] at java.io.DataOutputStream.flush(DataOutputStream.java:123)[:1.8.0_322] at org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:194)[activemq-client-5.15.15.jar:5.15.15] at org.apache.activemq.transport.AbstractInactivityMonitor.doOnewaySend(AbstractInactivityMonitor.java:335)[activemq-client-5.15.15.jar:5.15.15] at org.apache.activemq.transport.AbstractInactivityMonitor.access$800(AbstractInactivityMonitor.java:42)[activemq-client-5.15.15.jar:5.15.15] at org.apache.activemq.transport.AbstractInactivityMonitor$4.run(AbstractInactivityMonitor.java:201)[activemq-client-5.15.15.jar:5.15.15] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)[:1.8.0_322] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)[:1.8.0_322] at java.lang.Thread.run(Thread.java:750)[:1.8.0_322] ```  However, we could not determine any temporal connection between these warnings and the behavior that occurred. In our application are also no debug logs which could help us to identify the root cause.  ### Conclusion  There seems to be something in the `send messag` methode, that in some cases is taking too much time, till it starts to connect to the ActiveMQ  Edit: There seems to be a connection to failover of an mq. We could observe the same behavior when we changed our broker's configuration (disable multi-A-Z).  Thank you in advance for your help. :)","open","in: messaging,","Bean900","2022-03-02T08:58:34Z","2022-03-21T09:22:19Z"
"","28366","PathMatchingResourcePatternResolver.getResources(...) is not working properly with Java-17","**Affects:** org.springframework.boot version **2.5.9**  org.springframework.core.io.support.PathMatchingResourcePatternResolver.getResources(...) is not working properly with **Java-17 or 16**  `Exception in thread ""main"" java.lang.RuntimeException: Unable to get URL from application.properties: Invalid URI [jar:file:C:\work\DEMO\demo-0.0.1-SNAPSHOT\lib\demo-0.0.1-SNAPSHOT-plain.jar!/application.properties]; nested exception is java.net.URISyntaxException: Illegal character in opaque part at index 11: jar:file:C:\work\DEMO\demo-0.0.1-SNAPSHOT\lib\demo-0.0.1-SNAPSHOT-plain.jar!/application.properties`  **Java-17 path** : `jar:file:C:\work\DEMO\demo-0.0.1-SNAPSHOT\lib\demo-0.0.1-SNAPSHOT-plain.jar!/application.properties` **Java-8 path** : `file:/C:/work/DEMO/demo-0.0.1-SNAPSHOT/lib/demo-0.0.1-SNAPSHOT-plain.jar!/application.properties`  it looks like the path is not correct with java-17 and it is working fine with Java-8, could you please help with this issue?  PFA. [demo.zip](https://github.com/spring-projects/spring-framework/files/8532293/demo.zip) [demo-0.0.1-SNAPSHOT.zip](https://github.com/spring-projects/spring-framework/files/8532297/demo-0.0.1-SNAPSHOT.zip)  Thanks,  -Himanshu K.","open","status: waiting-for-triage,","HimanshuKumbhani-Calypso","2022-04-21T15:35:13Z","2022-04-21T15:37:34Z"
"","28260","Backports for PropertyDescriptor filtering","**Affects:** Major and minor versions other than 5.3.x  ---  Can we please have the PropertyDescriptor filtering commit https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15 backported to 4.x branches?","closed","status: declined,","magJ","2022-03-31T10:22:05Z","2022-04-06T00:41:37Z"
"","28490","ServerHttpRequest.getCookies() can only get the first cookie value when multiple cookies with the same name exist","**Affects:** main  The way to confirm:  Modify two lines in `CookieIntegrationTests` and the test will fail.  ```java  	@ParameterizedHttpServerTest 	public void basicTest(HttpServer httpServer) throws Exception { 		startServer(httpServer);  		URI url = new URI(""http://localhost:"" + port); 		// Modified line 1:add lang=zh-CN 		String header = ""SID=31d4d96e407aad42; lang=en-US; lang=zh-CN""; 		ResponseEntity response = new RestTemplate().exchange( 				RequestEntity.get(url).header(""Cookie"", header).build(), Void.class);  		Map> requestCookies = this.cookieHandler.requestCookies; 		assertThat(requestCookies.size()).isEqualTo(2);  		List list = requestCookies.get(""SID""); 		assertThat(list.size()).isEqualTo(1); 		assertThat(list.iterator().next().getValue()).isEqualTo(""31d4d96e407aad42"");  		list = requestCookies.get(""lang""); 		// Modified line 2:add this line 		assertThat(list.size()).isEqualTo(2); 		assertThat(list.iterator().next().getValue()).isEqualTo(""en-US"");  		List headerValues = response.getHeaders().get(""Set-Cookie""); 		assertThat(headerValues.size()).isEqualTo(2);  		List cookie0 = splitCookie(headerValues.get(0)); 		assertThat(cookie0.remove(""SID=31d4d96e407aad42"")).as(""SID"").isTrue(); 		assertThat(cookie0.stream().map(String::toLowerCase)) 				.containsExactlyInAnyOrder(""path=/"", ""secure"", ""httponly""); 		List cookie1 = splitCookie(headerValues.get(1)); 		assertThat(cookie1.remove(""lang=en-US"")).as(""lang"").isTrue(); 		assertThat(cookie1.stream().map(String::toLowerCase)) 				.containsExactlyInAnyOrder(""path=/"", ""domain=example.com""); 	} ```  According to [rfc 6265](https://www.rfc-editor.org/rfc/rfc6265#section-4.2.2)，server should be able to handle cookies with the same name instead of parsing the first one and ignoring the others. I think it is more reasonable for `spring-web` to give all values to application and let application decide how to handle multiple values.  By the way, the bottom frameworks Reactor-netty, Jetty, and Tomcat can parse multiple cookie values with the same name in their newer versions, wish spring can support soon.    ### Related Issues  - https://github.com/reactor/reactor-netty/issues/1641","open","in: web,","jsonwan","2022-05-20T01:43:13Z","2022-06-01T18:02:59Z"
"","28545","MockMvcWebTestClient forces HTTP POST for multipart requests","**Affects:** latest (6.0.0, 5.3.20) ---  When making a `multipart/form-data` request using `WebTestClient`, the HTTP method of the request is overwritten to `POST`:  For example, the following test:  ```java         @Test         void returns_no_content_on_success() {             var builder = new MultipartBodyBuilder();             builder.part(""file"", TestResources.JPEG_IMAGE, MediaType.IMAGE_JPEG);             webTestClient.put()                 .uri(""/test"")                 .bodyValue(builder.build())                 .exchange()                 .expectStatus().isNoContent();         } ```  generates the following log output: ``` > PUT /test > WebTestClient-Request-Id: [1] > Content-Type: [multipart/form-data;boundary=1TV9nXkH1G9MW2IM7_NyhWx2AJYVwdNGd]  159180 bytes of content.  < 405 METHOD_NOT_ALLOWED Method Not Allowed < Allow: [PUT,DELETE] < Content-Type: [application/problem+json]  156 bytes of content.  ======================  MockMvc (Server) ===============================  MockHttpServletRequest:       HTTP Method = POST       Request URI = /test        Parameters = {}           Headers = [Content-Type:""multipart/form-data;charset=UTF-8"", WebTestClient-Request-Id:""1""]              Body = null ```  I've traced this to a some code that implies that Multipart requests are always `POST`: * https://github.com/spring-projects/spring-framework/blob/279f9647ab4e3b2f875ab397a911d34edfbf3dce/spring-test/src/main/java/org/springframework/test/web/servlet/request/MockMultipartHttpServletRequestBuilder.java#L81 * https://github.com/spring-projects/spring-framework/blob/279f9647ab4e3b2f875ab397a911d34edfbf3dce/spring-test/src/main/java/org/springframework/test/web/servlet/client/MockMvcHttpConnector.java#L157","closed","type: enhancement,","kewne","2022-05-31T15:05:52Z","2022-06-08T09:55:38Z"
"","28554","TransactionAwareCacheDecorator renders CacheErrorHandler useless","**Affects:** All Versions since 3.2?  When configuring a custom cache error handler via `CachingConfigurer::errorHandler` and having transaction-aware caching enabled (for example, via `RedisCacheManager.RedisCacheManagerBuilder::transactionAware`, which decorates with `TransactionAwareCacheDecorator`), the cache error handler is never called when the put fails in `TransactionSynchronization::afterCommit` once the transaction was committed. In particular, this prevents users to suppress runtime exceptions from the cache backend by using the `LoggingCacheErrorHandler`, such as connection problems or command timeouts from Redis.  To illustrate the problem, I've created a [simple demo project using Redis](https://github.com/neiser/spring-cache-transaction-aware-error-handling/tree/master/src/main/java/com/example/demo) as a cache backend (which cannot connect as there's no Redis running on `localhost:6379`)  The [test where I did not enable transaction-awareness does **not**  throw any exception](https://github.com/neiser/spring-cache-transaction-aware-error-handling/blob/master/src/test/java/com/example/demo/TestWithoutTransactionAwareness.java), whereas the [test with transaction-awareness does](https://github.com/neiser/spring-cache-transaction-aware-error-handling/blob/master/src/test/java/com/example/demo/TestWithTransactionAwareness.java), rather unexpectedly, as [I've installed a `LoggingCacheErrorHandler`](https://github.com/neiser/spring-cache-transaction-aware-error-handling/blob/master/src/main/java/com/example/demo/CachingConfiguration.java#L25).  Note that I've configured a [very dummy transaction handling](https://github.com/neiser/spring-cache-transaction-aware-error-handling/blob/master/src/main/java/com/example/demo/TransactionConfiguration.java) to make the bug appear.  A workaround for the bug would be to not enable transaction-awareness via `RedisCacheManager.RedisCacheManagerBuilder::transactionAware`, but to instrument the cache manually. I did this with AOP on any cache instance by decorating the `CacheManager::getCache` with a BeanPostProcessor, but this is quite ugly:  ```java @Aspect @RequiredArgsConstructor @EqualsAndHashCode public class CacheTransactionAwareAspect {     private final CacheErrorHandler cacheErrorHandler;     private final Cache cache;      private static Object proceedAfterCommit(ProceedingJoinPoint pjp, Consumer errorHandler) throws Throwable {         if (TransactionSynchronizationManager.isSynchronizationActive()) {             TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronization() {                 @Override                 public void afterCommit() {                     try {                         pjp.proceed();                     } catch (RuntimeException e) {                         errorHandler.accept(e);                     } catch (Throwable e) {                         throw new RuntimeException(e);                     }                 }             });             return null;         } else {             return pjp.proceed();         }     }      @Around(""execution(* org.springframework.cache.Cache.put(..))"")     public Object wrapPutMethod(ProceedingJoinPoint pjp) throws Throwable {         return proceedAfterCommit(pjp, e -> {             var args = pjp.getArgs();             cacheErrorHandler.handleCachePutError(e, cache, args[0], args[1]);         });     }      @Around(""execution(* org.springframework.cache.Cache.evict(..))"")     public Object wrapEvictMethod(ProceedingJoinPoint pjp) throws Throwable {         return proceedAfterCommit(pjp, e -> {             var args = pjp.getArgs();             cacheErrorHandler.handleCacheEvictError(e, cache, args[0]);         });     }      @Around(""execution(* org.springframework.cache.Cache.clear(..))"")     public Object wrapClearMethod(ProceedingJoinPoint pjp) throws Throwable {         return proceedAfterCommit(pjp, e -> {             cacheErrorHandler.handleCacheClearError(e, cache);         });     } } ```  Let me know if you need further information to reproduce the bug.   [I've also just tried a fix](https://github.com/neiser/spring-framework/commit/cbc673df090f526acfbaf1ae21c8cf9cdbec1bf8), but I don't know how to get the error handler (which should be kind of a singleton from `CachingConfigurer`) into the `AbstractTransactionSupportingCacheManager`. Any hints would be appreciated and I'd create a PR if this attempt goes into the right direction.","open","status: feedback-provided,","neiser","2022-06-02T06:48:39Z","2022-07-08T13:52:09Z"
"","28307","Feature request: @Autowired final variables","**Affects:** All versions  In a Java constructor, the JLS requires: * No touching `this` prior to invoking the superclass constructor * Superclass constructor must be the first statement (syntatically)  However, the JVM is more lenient: constructors may perform arbitrary work prior to invoking the superclass constructor, as long as that work either doesn't touch `this` **except** for assignments to final variables.  This means that, in theory, by tweaking the bytecode weaving that occurs, `@Autowired` fields could be marked `final` and their values assigned prior to invoking the superclass constructor.  This would be a great feature and a much cleaner way to avoid problems where `@Autowired` fields are not set before use due to superclass method invocation or whatever (i.e., the same problems that `preConstruction = true` only partially addresses).  Also, adding this support would be backward compatible, because `final` and `@Autowired` are currently not possible together.  It would also make Spring look cool because it would show how Spring developers really know their bytecode.","closed","status: declined,","archiecobbs","2022-04-07T22:46:54Z","2022-04-08T19:34:04Z"
"","28692","No way to sort all known outstanding issues (and only these) by importance","**Affects:** All  ---  The Spring community manages numerous projects and sub-projects, affected by an even larger number of issues. It is difficult to grasp the importance of these issues, both individually and as a whole. For example, the lack of discussion forums documentation is tracked by ticket #27599, which stands among something in the order of 100 000 other tickets, hopefully much less important on average.  Allowing to list all known (reported) issues, and only those which are not solved, would already be a huge improvement. Supporting listings ordered by issue importance would be incredibly better. While allowing to list issues from all Spring projects together would be very useful, individual lists would also be useful, and this issue can be considered solved even if the implementation allows only per-project rankings, only a global ranking, or both. I let those familiar with the ITS(-s) decide which approach they prefer. In case it is decided to work on a per-project basis, some work has been started, as can be seen in [Spring Data Common's ticket #2458](https://github.com/spring-projects/spring-data-commons/issues/2458).  Importance is of course relative and I do not expect a perfect ranking. A field tracking it with 5 possible values (like YouTrack's default) would already suffice for our needs. Reaching this goal may involve several jobs (enabling ranking, [fixing search](https://github.com/spring-projects/spring-framework/issues/27532#event-5433281528) and enabling marking of resolved issues), which may require considerable work, but each step of the path can be deployed individually and will considerably facilitate evaluation and the other use cases.","closed","status: duplicate,","Chealer","2022-06-23T21:39:44Z","2022-06-24T01:45:36Z"
"","28276","PathMatchingResourcePatternResolver gives different results with classpath in JAR manifest","**Affects:** `spring-core` 5.3.18  When looking up a resource that's contained in the root of a dependency jar with a path wildcard, `PathMatchingResourcePatternResolver` gives different results depending on the way the classpath is given to `java`.  Taking the JUnit 4 JAR as a readily available example, from what I would expect from the docs,  ``` new PathMatchingResourcePatternResolver().getResources(""classpath*:**/LICENSE-junit.txt"") ```  and   ``` getClass().getClassLoader().getResources(""LICENSE-junit.txt"") ```  should find the same resource. However, if the `java` process is called with the classpath given in a JAR file containing the dependency JAR in its manifest, `PathMatchingResourcePatternResolver` does not find the resource.  See https://github.com/cnaj/path-matching-resource-pattern-resolver-demo for a demo of this behavior.  Please run the two scripts `demo-normal-cp.sh` and `demo-jar-cp.sh` in the demo repository to see the difference in behavior.  Tested with Java 8 and Java 11 on Windows, Linux, and Mac.  This behavior has already been reported previously with #24480, but it was apparently mistaken for a VS Code behavior.","open","in: core,","cnaj","2022-04-02T08:05:33Z","2022-04-02T12:55:22Z"
"","28849","Custom hibernate field conversion failing in spring-boot v3.0.0-M4","**Affects:** \v3.0.0-M4  ---  Thsi issue might be hibernate related, since between M3 and M4 it switched from hibernate 5.x to 6.1.1. If that is the case, I apologize in advance.  I have a mapped superclass containing an `id` field that is used by all my entities, and an actual entity object with the rest of the business-related fields. The `id` is `UUID`, which on the database side is mapped into a 16 character long blob. To do the conversion, I use a custom `AttributeConverter`. DB is initialized by Spring, based on the entities.  When I try to save such an object, I receive one of two exceptions. It is either:  ``` class java.util.UUID cannot be cast to class [B (java.util.UUID and [B are in module java.base of loader 'bootstrap') java.lang.ClassCastException: class java.util.UUID cannot be cast to class [B (java.util.UUID and [B are in module java.base of loader 'bootstrap') 	at org.hibernate.type.descriptor.java.PrimitiveByteArrayJavaType.areEqual(PrimitiveByteArrayJavaType.java:28) ```  or  ``` org.springframework.dao.InvalidDataAccessApiUsageException: Value was not an array [java.util.UUID] 	at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:371) ... Caused by: java.lang.IllegalArgumentException: Value was not an array [java.util.UUID] 	at org.hibernate.type.descriptor.java.ArrayMutabilityPlan.deepCopyNotNull(ArrayMutabilityPlan.java:23) ```  Full logs: [v1.log](https://github.com/spring-projects/spring-framework/files/9160982/v1.log) [v2.log](https://github.com/spring-projects/spring-framework/files/9160981/v2.log)   Now, for some specific code:  ```java @MappedSuperclass @Getter @Accessors(chain = true) @EqualsAndHashCode public class Id> {   @Column(unique = true, length = 16, nullable = false)   @jakarta.persistence.Id   @Convert(converter = UuidBase64Type.class)   private UUID id = UUID.randomUUID();    @SuppressWarnings(""unchecked"")   public T setId(UUID id) {     this.id = id;     return (T) this;   } }   @Getter @Setter @Accessors(chain = true) @Entity public class Image extends Id {   @Column(unique = true, length = 16, nullable = false)   @Convert(converter = UuidBase64Type.class)   private UUID thumbId = UUID.randomUUID();    private int position;   private int size;   private int thumbnailSize; }  @Slf4j public class UuidBase64Type implements AttributeConverter {   @Override   public byte[] convertToDatabaseColumn(UUID attribute) {     return toBytes(attribute);   }    @Override   public UUID convertToEntityAttribute(byte[] dbData) {     return toUuid(dbData);   }    private UUID toUuid(byte[] bytes) {     if (bytes == null || bytes.length == 0) {       return null;     }     long mostSignificantBits =         Longs.fromBytes(             bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]);     long leastSignificantBits =         Longs.fromBytes(             bytes[8], bytes[9], bytes[10], bytes[11], bytes[12], bytes[13], bytes[14], bytes[15]);     return new UUID(mostSignificantBits, leastSignificantBits);   }    private byte[] toBytes(UUID uuid) {     if (uuid == null)  {       return new byte[]{};     }     ByteBuffer bb = ByteBuffer.wrap(new byte[16]);     bb.putLong(uuid.getMostSignificantBits());     bb.putLong(uuid.getLeastSignificantBits());     return bb.array();   } }  @Repository public interface ImageRepository extends JpaRepository {}  class TheIntegrationTestThatIsFailing {   @Test   void teacher_can_delete_gallery() {     // GIVEN     imageRepository.saveAndFlush(         new Image()             .setPosition(0)             .setSize(10)             .setThumbnailSize(1));   } } ```  The strange part is, not all of my entities are failing (but still, quite a lot of them). The above example can be made to work with a single change, namely the removal of the `thumbId` field from the `Image` class:  ``` @Getter @Setter @Accessors(chain = true) @Entity public class Image extends Id {   private int position;   private int size;   private int thumbnailSize; } ```  This exact same code works fine if I switch back to spring-boot v3.0.0-M3.","closed","for: external-project,","whydoievenneedthis","2022-07-21T16:11:50Z","2022-07-27T13:48:08Z"
"","28848","REST endpoint resolution changed (broke?) from spring-boot v3.0.0-M3","**Affects:** \spring-boot v3.0.0-M4  --- I have the following REST endpoint specification: GET /v1/thingy/{thingyId}  Then I make a call, in the context of an integration test, to MockMvc.perform(GET, '/v1/thingy/'). Note the last forward slash in the URL.  What happened in spring-boot v3.0.0-M3: the endpoint above was found, and the handleMissingServletRequestParameter method was triggered on the ResponseEntityExceptionHandler controller advice.  What happens in spring-boot v3.0.0-M4: the endpoint above is not found, and the call is redirected to the static resource handler.  I did not find any indication in the changelog that such a change in behaviour is expected.","closed","for: external-project,","whydoievenneedthis","2022-07-21T15:31:10Z","2022-07-21T16:36:04Z"
"","28121","Configuring DataBuffer capacity for FilePart PartGenerator","**Affects:** \5.3.12  Hello @poutsma,  The problem :  when generating the `FilePart#content()`, the `PartGenerator`  uses the following code  ``` private Flux partContent() { 	return DataBufferUtils 			.readByteChannel( 					() -> Files.newByteChannel(this.file, StandardOpenOption.READ), 					DefaultDataBufferFactory.sharedInstance, 1024) 			.subscribeOn(PartGenerator.this.blockingOperationScheduler);   } ```  the generated `Flux` contains data buffers with a capacity of 1024 bytes. This becomes a performance issue when dealing with big files because the call to `FilePart#transferTo` take a significant amout of time (too many databuffers). For example, the call to `FilePart#transferTo` for a 90 MB file takes 6.6 seconds with a capacity 1024 bytes. I used ByteBuddy to intercept the call to `DataBufferUtils#readByteChannel` and set the capacity to 32 KB and the operation took 312 milliseconds.  What I propose as an enhancement is to make it possible to configure the bufferSize either (by using properties or `ServerCodecConfigurer`) or at least use the **server.netty.max-chunk-size** as a basis. Other suggestions are also welcome.  Thank you and keep up the awesome work!  PS : I think the provided code has been moved to `DefaultParts` in newer versions of the Framework","closed","status: invalid,","saad14092","2022-03-01T17:13:46Z","2022-03-24T22:23:58Z"
"","28092","Expression.setValue cannot parse complex expressions","**Affects:** \5.3.10，The same goes for the latest version 5.3.16   The source code for the last step is ```java package org.springframework.expression.spel.ast.SpelNodeImpl  @Override 	public void setValue(ExpressionState expressionState, @Nullable Object newValue) throws EvaluationException { 		throw new SpelEvaluationException(getStartPosition(), SpelMessage.SETVALUE_NOT_SUPPORTED, getClass()); 	} ```  Why does this method throw an exception directly? Why does the same expression, getValue, work correctly, while setValue reports an error? As follow: ![BC5951CE-DEA3-4474-BD89-3EE290E48872.png](https://user-images.githubusercontent.com/45144964/155083367-01c8f3c3-f3fe-4d0a-a364-3acabc4c2af7.png) This part of the logic works fine, but the latter part does not ![75F1390F-9D2D-45c3-881E-48EC7531BCC1.png](https://user-images.githubusercontent.com/45144964/155083388-32a1613e-5478-4a30-8590-44fa448c8bdc.png)","closed","for: stackoverflow,","AresYoungLs","2022-02-22T07:29:21Z","2022-02-25T14:01:59Z"
"","28275","spring-web - Exchange response header values are overridden from the downstream calls","**Affects:** \<5.3.16 & up> (don't have this issue in 5.3.13)    As far as I've tested back, atleast beginning 5.3.16 this issue is occurring. To be specific, observed this issue in both spring-web 5.3.16 & spring-web 5.3.18  Issue Description: **_Sequence of steps:_** 1. Spring Cloud Gateway(SCG) received the request 2. SCG added set of response headers to the exchange object  3. SCG makes the downstream call 4. Downstream sets the same exact headers that were set in step#2 but with different values  What should've happened (and this is what happens with spring-web 5.3.13)? - The response headers added by the downstream gets saved into exchange. If the downstream is setting the same response headers which are already present in the exchange, then the response header values from downstream saved into the ""value"" array  What's happening (and this is what happens at least beginning spring-web 5.3.16)? - If the downstream is setting the same response headers which are already present in the exchange, then the response header values are not added to the header ""value"" object but overrides the response header values that was already set on the exchange prior to making a downstream call  Notes: I've tested this scenario in different combinations and below are the findings  Springboot 2.5.7 (spring-web: 5.3.13) - No issue Springboot 2.5.12 with spring-web: 5.3.18 - Issue present Springboot 2.5.12 with spring-web: 5.3.16 - Issue present Springboot 2.5.7 (spring-web: 5.3.18/16) - Issue present Springboot 2.6.4 (spring-web: 5.3.16) - Issue present   Please advise and let me know if you have any questions.  Thanks.","open","status: feedback-provided,","explorer-fullstack","2022-04-02T02:03:47Z","2022-04-06T22:12:37Z"
"","28529","Pageable request query column name mismatch in sortBy section","**Affects:** \<2.7.0>  --- Hello!  I've tried to make pageable request on JpaRepository with sort by argument, which led to PropertyReferenceException  At first glance behavior was unexpected to me, since I declared @Column annotation on field with name property, and I was expecting a query, generated by pageable request, to use this name as sort parameter in request, but this didnt' happen, since actually on query creation spring init PropertyPath, which tries to read a non-existing field from @Entity annotated class owner, which leads to this exception.  I consider this a bug since user expects name declared in @Column annotation to match query requests.  Example code:  ``` package pckg;  import javax.persistence.*;  @Entity  @Table(name = ""example"") class Example {          @Column(name = ""id"")     public int id;          @Column(name = ""old"")     public int old; }  ```  ``` package repo;  import org.springframework.data.jpa.repository.JpaRepository; import pckg.Example;  public interface ExampleRepository extends JpaRepository {     Example findById(long id); } ```  ``` package controller;  import repo.ExampleRepository import pckg.Example  import org.springframework.beans.factory.annotation.Autowired import org.springframework.data.domain.{Page, PageRequest, Sort} import org.springframework.web.bind.annotation.{GetMapping, RequestParam, RestController}  class ExampleController {    @Autowired   private var repo: ExampleRepository = _    @GetMapping(value = Array(""/example""))   def getPage(@RequestParam(value = ""page"",   defaultValue = ""0"")  page:   String,               @RequestParam(value = ""size"",   defaultValue = ""10"") size:   String,               @RequestParam(value = ""sort"",   defaultValue = ""id"") sortBy: String) Array[Example] = try {     val pageNumber = page.toInt     val requestedSize = size.toInt     val sort = Sort.by(sortBy)          val pageable = PageRequest.of(pageNumber, requestedSize, sort)     val resultPage: Page[Example] = repo.findAll(pageable)      resultPage.getContent.asScala.toArray   } catch {     case e: Throwable => Array.empty   } } ```  ``` import org.springframework.boot.{CommandLineRunner, SpringApplication} import org.springframework.boot.autoconfigure.SpringBootApplication  @SpringBootApplication class App {}  object App {   def main(args: Array[String]): Unit = {     SpringApplication.run(classOf[App], args: _*)   } } ```  ``` spring.datasource.url=jdbc:postgresql://localhost:5432/example spring.datasource.username=example spring.datasource.password=example spring.datasource.driver-class-name=org.postgresql.Driver spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect  spring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto=create ```  At this point I try to execute localhost:8080/example?sort=old which works fine And after that I modify Example class:  ``` package pckg;  import javax.persistence.*;  @Entity  @Table(name = ""example) class Example {      @Column(name = ""id"")     public int id;   //    @Column(name = ""old"")     @Column(name = ""bold"")     public int old; } ```  And then execute localhost:8080/example?sort=bold, which leads to an exception","open","status: waiting-for-triage,","JulianIsFree","2022-05-27T00:37:30Z","2022-05-27T00:40:18Z"
"","27988","JdbcTemplate.queryForStream() does not return connection to the pool, causing the connection leak.","**Affects:** \ ---  Please refer to the [demo project](https://github.com/arciszewski/spring-jdbc-bug-demo) that replicates the issue. When using `JdbcTemplate.queryForObject()` and subsequently calling the `.findFirst()` method, the connection is not getting closed, hense the connection pool runs dry very quickly. ```java jdbcTemplate.queryForStream(""SELECT VALUE FROM TEST WHERE KEY = ?"",                 (rs, i) -> rs.getString(""VALUE""), key)                 .findFirst(); ``` The result of the execution of the following code is: ``` 2022-01-30 13:00:38.783 DEBUG 19628 --- [l-1 housekeeper] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Pool stats (total=10, active=10, idle=0, waiting=1) 2022-01-30 13:00:38.783 DEBUG 19628 --- [l-1 housekeeper] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Fill pool skipped, pool is at sufficient level. 2022-01-30 13:00:39.585 DEBUG 19628 --- [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Timeout failure stats (total=10, active=10, idle=0, waiting=0) 2022-01-30 13:00:39.585  INFO 19628 --- [           main] ConditionEvaluationReportLoggingListener :   Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-01-30 13:00:39.616 ERROR 19628 --- [           main] o.s.boot.SpringApplication               : Application run failed  java.lang.IllegalStateException: Failed to execute CommandLineRunner 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:772) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:753) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:309) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1303) ~[spring-boot-2.6.3.jar:2.6.3] 	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1292) ~[spring-boot-2.6.3.jar:2.6.3] 	at demo.Demo.main(Demo.java:21) ~[main/:na] Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30018ms. 	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:83) ~[spring-jdbc-5.3.15.jar:5.3.15] 	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:646) ~[spring-jdbc-5.3.15.jar:5.3.15] 	at org.springframework.jdbc.core.JdbcTemplate.queryForStream(JdbcTemplate.java:834) ~[spring-jdbc-5.3.15.jar:5.3.15] 	at org.springframework.jdbc.core.JdbcTemplate.queryForStream(JdbcTemplate.java:863) ~[spring-jdbc-5.3.15.jar:5.3.15] 	at demo.JdbcRepo.getFromStream(JdbcRepo.java:32) ~[main/:na] 	at demo.JdbcRepo$$FastClassBySpringCGLIB$$87a3d4d8.invoke() ~[main/:na] 	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.3.15.jar:5.3.15] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:783) ~[spring-aop-5.3.15.jar:5.3.15] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.3.15.jar:5.3.15] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.15.jar:5.3.15] 	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:137) ~[spring-tx-5.3.15.jar:5.3.15] 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.15.jar:5.3.15] 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) ~[spring-aop-5.3.15.jar:5.3.15] 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:698) ~[spring-aop-5.3.15.jar:5.3.15] 	at demo.JdbcRepo$$EnhancerBySpringCGLIB$$c0949ac4.getFromStream() ~[main/:na] 	at demo.Demo.run(Demo.java:49) ~[main/:na] 	at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:769) ~[spring-boot-2.6.3.jar:2.6.3] 	... 5 common frames omitted Caused by: java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 30018ms. 	at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696) ~[HikariCP-4.0.3.jar:na] 	at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197) ~[HikariCP-4.0.3.jar:na] 	at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:162) ~[HikariCP-4.0.3.jar:na] 	at com.zaxxer.hikari.HikariDataSource.getConnection(HikariDataSource.java:128) ~[HikariCP-4.0.3.jar:na] 	at org.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:159) ~[spring-jdbc-5.3.15.jar:5.3.15] 	at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:117) ~[spring-jdbc-5.3.15.jar:5.3.15] 	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80) ~[spring-jdbc-5.3.15.jar:5.3.15] 	... 21 common frames omitted ```","closed","status: invalid,","arciszewski","2022-01-30T12:02:35Z","2022-02-26T01:32:26Z"
"","28229","Small planning suggest - spring-core-5.3.16","**Affects:** \  Now i need invoke method(org.springframework.util.ReflectionUtils#getDeclaredFields), The method cache is used to precisely cache parsed class instances at application startup, but this method is not public, so I need to write a similar method and the cache can not be managed uniformly. Can you go public with it?  My brother, thanks!","closed","status: declined,","dylan-tao","2022-03-24T12:11:48Z","2022-03-24T16:03:20Z"
"","28523","When initializing DispatcherServlet multiple times, its internal states like handlerAdapters etc. will be cleared first and then set","**Affects:** \  Background:  Tomcat 8.5, using Spring Boot 2.6.8 and Spring 5.3.20 to setup one DispatcherServlet instance to multiple servlet mapping paths.  For example: map it to both ""/a_path/\*"" and ""/b_path/\*"", the ""loadOnStartUp"" are not set.  Steps to reproduce the problem:  **Step 1** start the service  **Step 2** request to ""/a_path/api1""   It's the first time to access ""/a_path/*"",  Tomcat will initialize the DispatcherServlet instance by invoking its method `DispatcherServlet#initStrategies`.  Then its internal states like `handlerMappings`, `handlerAdapters` will be set.  **Step 3** request to ""/b_path/api2""   It's the first time to access ""/b_path/*"",  Tomcat will initialize the same DispatcherServlet instance by invoking its method `DispatcherServlet#initStrategies` again.     The problem is here, the initialization methods like `DispatcherServlet#initHandlerAdapters` will clear previous state first before set them again: ```   private void initHandlerAdapters(ApplicationContext context) {         //Step 3a:clear handlerAdapters first  	this.handlerAdapters = null;           ...         //Step 3b: set handlerAdapters again          ...    } ``` Assume now Step 3 processing is between step 3a and step 3b, the `handlerAdapters` is cleared as null at this moment, it happens a new request ""/a_path/api3"" just comes, it will be processed in ```DispatcherServlet#doDispatch``` and found no ```handlerAdapters``` here, so it will end up with an error: ""No adapter for handler [xxx]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler""","open","status: waiting-for-triage,","shuodashen","2022-05-25T12:03:25Z","2022-05-25T12:38:39Z"
"","28676","A configuration class superclass that is skipped due to register bean phase conditions is ignored when another configuration class that extends it is processed","**Affects:** 6.0.x. I expect 5.3.x to also be affected.  I think @mbhave and I have found a bug in configuration class processing related to condition evaluation. It's hopefully illustrated by the following tests:  ```java import org.junit.jupiter.api.Test;  import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ConditionContext; import org.springframework.context.annotation.Conditional; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.ConfigurationCondition; import org.springframework.context.annotation.Import; import org.springframework.core.type.AnnotatedTypeMetadata;  import static org.assertj.core.api.Assertions.assertThat;  class ConfigurationPhasesKnownSuperclassesTests {  	@Test 	void superclassSkippedInParseConfigurationPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass() { 		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( 				ParseConfigurationPhase.class)) { 			assertThat(context.getBean(""subclassBean"")).isEqualTo(""bravo""); 			assertThat(context.getBean(""superclassBean"")).isEqualTo(""superclass""); 		} 	}  	@Test 	void superclassSkippedInRegisterBeanPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass() { 		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( 				RegisterBeanPhase.class)) { 			assertThat(context.getBean(""subclassBean"")).isEqualTo(""bravo""); 			assertThat(context.getBean(""superclassBean"")).isEqualTo(""superclass""); 		} 	}  	@Configuration(proxyBeanMethods = false) 	static class Example {  		@Bean 		String superclassBean() { 			return ""superclass""; 		}  	}  	@Configuration(proxyBeanMethods = false) 	@Import({ RegisterBeanPhaseExample.class, BravoExample.class }) 	static class RegisterBeanPhase {  	}  	@Conditional(NonMatchingRegisterBeanPhaseCondition.class) 	@Configuration(proxyBeanMethods = false) 	static class RegisterBeanPhaseExample extends Example {  		@Bean 		String subclassBean() { 			return ""alpha""; 		}  	}  	@Configuration(proxyBeanMethods = false) 	@Import({ ParseConfigurationPhaseExample.class, BravoExample.class }) 	static class ParseConfigurationPhase {  	}  	@Conditional(NonMatchingParseConfigurationPhaseCondition.class) 	@Configuration(proxyBeanMethods = false) 	static class ParseConfigurationPhaseExample extends Example {  		@Bean 		String subclassBean() { 			return ""alpha""; 		}  	}  	@Configuration(proxyBeanMethods = false) 	static class BravoExample extends Example {  		@Bean 		String subclassBean() { 			return ""bravo""; 		}  	}  	static class NonMatchingRegisterBeanPhaseCondition implements ConfigurationCondition {  		@Override 		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { 			return false; 		}  		@Override 		public ConfigurationPhase getConfigurationPhase() { 			return ConfigurationPhase.REGISTER_BEAN; 		}  	}  	static class NonMatchingParseConfigurationPhaseCondition implements ConfigurationCondition {  		@Override 		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { 			return false; 		}  		@Override 		public ConfigurationPhase getConfigurationPhase() { 			return ConfigurationPhase.PARSE_CONFIGURATION; 		}  	}  } ```  `superclassSkippedInParseConfigurationPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass` passes but `superclassSkippedInRegisterBeanPhaseShouldNotPreventSubsequentProcessingOfSameSuperclass` fails.  The register bean phase test fails due to the `knownSuperclasses` map in `ConfigurationClassParser` being polluted. Due to the parse configuration phase conditions matching an entry is added to the map for `Example -> RegisterBeanPhaseExample`. Subsequently, the register bean phase condition on `RegisterBeanPhaseExample` does not match, so neither it nor `Example` are processed. When `BravoExample` is then parsed, `ConfigurationClassParser` considers its superclass `Example`. It's skipped due to the existing entry in the `knownSuperclasses` map, despite the fact that `Example` was never actually processed due to the conditions on `RegisterBeanPhaseExample`. The end result is that the context is left without a bean named `superclassBean`.","open","status: waiting-for-triage,","wilkinsona","2022-06-22T11:13:24Z","2022-06-22T14:12:20Z"
"","28492","Support property placeholders in url attribute of @HttpExchange","**Affects:** 6.0.0-SNAPSHOT  --- Hi Spring Team,  Can you please add the ability to reference properties for `@HttpExchange`, `@GetExchange`, and `@PostExchange` defined in `application.yaml`?  Right now, I have to hard code my URL in the annotation:  ```java @HttpExchange(url = ""/multitenant/public/api"") public interface CumulusRepository {      @GetExchange(""/get_stuff"")     Cumulus getCumulusAlerts(@RequestHeader Map headers);      @PostExchange(""/getAccessToken"")     Token getAccessToken(@RequestBody String credential); } ```  But I wish to define my URL in `application.yaml` and reference it in the annotations like this:  ```java @HttpExchange(url = ""${cumulus.baseUrl}"") public interface CumulusRepository {      @GetExchange(""${cumulus.alertUrl}"")     Cumulus getCumulusAlerts(@RequestHeader Map headers);      @PostExchange(""${cumulus.tokenUrl}"")     Token getAccessToken(@RequestBody String credential); } ```","closed","type: enhancement,","xuan","2022-05-20T04:11:24Z","2022-05-23T10:30:40Z"
"","28864","R2dbc InitialScripts caused  Integer to Long cast exceptions","**Affects:** 6.0.0-M5, Java 17, R2dbc Borca-SR1  I added a `ConnectionFactoryInitializer` to initialize the sample data in my example project: https://github.com/hantsy/spring6-sandbox/tree/master/r2dbc.   ```java   @Bean   public ConnectionFactoryInitializer initializer(ConnectionFactory connectionFactory) {        ConnectionFactoryInitializer initializer = new ConnectionFactoryInitializer();       initializer.setConnectionFactory(connectionFactory);        CompositeDatabasePopulator populator = new CompositeDatabasePopulator();       populator.addPopulators(new ResourceDatabasePopulator(new ClassPathResource(""schema.sql"")));       populator.addPopulators(new ResourceDatabasePopulator(new ClassPathResource(""data.sql"")));       initializer.setDatabasePopulator(populator);        return initializer;   } ```  When running the [repository test](https://github.com/hantsy/spring6-sandbox/blob/master/r2dbc/src/test/java/com/example/demo/domain/PostRepositoryTest.java), and got the following exception.  ```bash  Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'initializer' defined in com.example.demo.domain.R2dbcConfig: Failed to execute SQL script statement #1 of class path resource [data.sql]: DELETE FROM posts 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1753) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:604) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) 	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:127) 	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:276) 	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:244) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:123) 	... 71 common frames omitted Caused by: org.springframework.r2dbc.connection.init.ScriptStatementFailedException: Failed to execute SQL script statement #1 of class path resource [data.sql]: DELETE FROM posts 	at org.springframework.r2dbc.connection.init.ScriptUtils.lambda$runStatement$9(ScriptUtils.java:571) 	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:94) 	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableSubscriber.onError(FluxPeekFuseable.java:234) 	at reactor.core.publisher.MonoStreamCollector$StreamCollectorSubscriber.onError(MonoStreamCollector.java:150) 	at reactor.core.publisher.MonoStreamCollector$StreamCollectorSubscriber.onNext(MonoStreamCollector.java:137) 	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmit(FluxFlatMap.java:543) 	at reactor.core.publisher.FluxFlatMap$FlatMapInner.onNext(FluxFlatMap.java:984) 	at reactor.core.publisher.FluxHandleFuseable$HandleFuseableSubscriber.onNext(FluxHandleFuseable.java:191) 	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1816) 	at reactor.core.publisher.MonoCollectList$MonoCollectListSubscriber.onComplete(MonoCollectList.java:129) 	at reactor.core.publisher.FluxHandleFuseable$HandleFuseableSubscriber.onComplete(FluxHandleFuseable.java:236) 	at reactor.core.publisher.FluxWindowPredicate$WindowFlux.checkTerminated(FluxWindowPredicate.java:766) 	at reactor.core.publisher.FluxWindowPredicate$WindowFlux.drainRegular(FluxWindowPredicate.java:660) 	at reactor.core.publisher.FluxWindowPredicate$WindowFlux.drain(FluxWindowPredicate.java:746) 	at reactor.core.publisher.FluxWindowPredicate$WindowFlux.onComplete(FluxWindowPredicate.java:812) 	at reactor.core.publisher.FluxWindowPredicate$WindowPredicateMain.onNext(FluxWindowPredicate.java:241) 	at io.r2dbc.postgresql.util.FluxDiscardOnCancel$FluxDiscardOnCancelSubscriber.onNext(FluxDiscardOnCancel.java:91) 	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107) 	at reactor.core.publisher.FluxCreate$BufferAsyncSink.drain(FluxCreate.java:814) 	at reactor.core.publisher.FluxCreate$BufferAsyncSink.next(FluxCreate.java:739) 	at reactor.core.publisher.FluxCreate$SerializedFluxSink.next(FluxCreate.java:161) 	at io.r2dbc.postgresql.client.ReactorNettyClient$Conversation.emit(ReactorNettyClient.java:635) 	at io.r2dbc.postgresql.client.ReactorNettyClient$BackendMessageSubscriber.emit(ReactorNettyClient.java:887) 	at io.r2dbc.postgresql.client.ReactorNettyClient$BackendMessageSubscriber.onNext(ReactorNettyClient.java:761) 	at io.r2dbc.postgresql.client.ReactorNettyClient$BackendMessageSubscriber.onNext(ReactorNettyClient.java:667) 	at reactor.core.publisher.FluxHandle$HandleSubscriber.onNext(FluxHandle.java:126) 	at reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber.onNext(FluxPeekFuseable.java:854) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onNext(FluxMap.java:224) 	at reactor.core.publisher.FluxMap$MapConditionalSubscriber.onNext(FluxMap.java:224) 	at reactor.netty.channel.FluxReceive.drainReceiver(FluxReceive.java:279) 	at reactor.netty.channel.FluxReceive.onInboundNext(FluxReceive.java:388) 	at reactor.netty.channel.ChannelOperations.onInboundNext(ChannelOperations.java:411) 	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:93) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:327) 	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:314) 	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:435) 	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:279) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357) 	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379) 	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365) 	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919) 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166) 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584) 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) 	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997) 	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.base/java.lang.Thread.run(Thread.java:833) 	Suppressed: java.lang.Exception: #block terminated with an error 		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:99) 		at reactor.core.publisher.Mono.block(Mono.java:1675) 		at org.springframework.r2dbc.connection.init.ConnectionFactoryInitializer.execute(ConnectionFactoryInitializer.java:112) 		at org.springframework.r2dbc.connection.init.ConnectionFactoryInitializer.afterPropertiesSet(ConnectionFactoryInitializer.java:97) 		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1799) 		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1749) 		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:604) 		at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:526) 		at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:326) 		at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 		at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:324) 		at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) 		at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:930) 		at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:926) 		at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:592) 		at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:127) 		at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60) 		at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:276) 		at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:244) 		at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) 		at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:123) 		at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) 		at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:118) 		at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) 		at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:248) 		at org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:138) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$8(ClassBasedTestDescriptor.java:363) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.executeAndMaskThrowable(ClassBasedTestDescriptor.java:368) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$9(ClassBasedTestDescriptor.java:363) 		at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197) 		at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179) 		at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625) 		at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509) 		at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499) 		at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:310) 		at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735) 		at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734) 		at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestInstancePostProcessors(ClassBasedTestDescriptor.java:362) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$instantiateAndPostProcessTestInstance$6(ClassBasedTestDescriptor.java:283) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:282) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$4(ClassBasedTestDescriptor.java:272) 		at java.base/java.util.Optional.orElseGet(Optional.java:364) 		at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$5(ClassBasedTestDescriptor.java:271) 		at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:31) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:102) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:101) 		at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:66) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$2(NodeTestTask.java:123) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:123) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:90) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 		at java.base/java.util.ArrayList.forEach(ArrayList.java:1511) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 		at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 		at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 		at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 		at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 		at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 		at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 		at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 		at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 		at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53) 		at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:71) 		at com.intellij.rt.junit.IdeaTestRunner$Repeater$1.execute(IdeaTestRunner.java:38) 		at com.intellij.rt.execution.junit.TestsRepeater.repeat(TestsRepeater.java:11) 		at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:35) 		at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235) 		at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54) Caused by: java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.Long (java.lang.Integer and java.lang.Long are in module java.base of loader 'bootstrap') 	at java.base/java.util.stream.Collectors.lambda$summingLong$23(Collectors.java:699) 	at reactor.core.publisher.MonoStreamCollector$StreamCollectorSubscriber.onNext(MonoStreamCollector.java:132) 	... 51 common frames omitted ```","closed","status: invalid,","hantsy","2022-07-25T06:13:43Z","2022-07-27T12:42:15Z"
"","28718","Create well-known non-interface types in CollectionFactory without using reflection","**Affects:** 6.0  As [discussed with @sdeleuze](https://github.com/spring-projects/spring-boot/issues/31517#issuecomment-1168553144), it would be useful for native images if `CollectionFactory` could create instances of well-known non-interface collection types without using reflection. Aligning with the types that the factory creates for different interfaces, these well-known implementations could be `LinkedHashSet`, `TreeSet`, and `ArrayList`. Similar changes could be made for map creation as well.","closed","type: enhancement,","wilkinsona","2022-06-28T12:17:20Z","2022-07-13T09:20:53Z"
"","28298","findAnnotationOnBean finds annotations from a static @Bean method's enclosing class","**Affects:** 5.3.x  When a bean is defined using a static method, `findAnnotationOnBean` finds an annotation from the `@Configuration` class to which the static `@Bean` method belongs. The annotation is not found if the `@Bean` method is not static.  The following tests illustrate this behavior:  ```java package com.example;  import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  import org.junit.jupiter.api.Test;  import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;  import static org.assertj.core.api.Assertions.assertThat;  class FindAnnotationOnBeanTests {      @Test     void beanDefinedInInstanceMethodDoesNotHaveAnnotationsFromItsConfigurationClass() {         beanDoesNotHaveAnnotationsFromItsConfigurationClass(InstanceBeanMethodConfiguration.class);     }      @Test     void beanDefinedInStaticMethodDoesNotHaveAnnotationsFromItsConfigurationClass() {         beanDoesNotHaveAnnotationsFromItsConfigurationClass(StaticBeanMethodConfiguration.class);     }      void beanDoesNotHaveAnnotationsFromItsConfigurationClass(Class config) {         try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(config)) {             ExampleAnnotation annotation = context.getBeanFactory().findAnnotationOnBean(""exampleBean"",                     ExampleAnnotation.class);             assertThat(annotation).isNull();         }     }      @Configuration     @ExampleAnnotation     static class StaticBeanMethodConfiguration {          @Bean         static String exampleBean() {             return ""example"";         }      }      @Configuration     @ExampleAnnotation     static class InstanceBeanMethodConfiguration {          @Bean         String exampleBean() {             return ""example"";         }      }      @Target(ElementType.TYPE)     @Retention(RetentionPolicy.RUNTIME)     static @interface ExampleAnnotation {      }  } ```  `beanDefinedInInstanceMethodDoesNotHaveAnnotationsFromItsConfigurationClass` passes but `beanDefinedInStaticMethodDoesNotHaveAnnotationsFromItsConfigurationClass` fails.","closed","in: core,","wilkinsona","2022-04-07T12:18:26Z","2022-06-14T12:04:25Z"
"","28679","Change in noRollbackFor transaction behavior with H2 database 2.x","**Affects:** 5.3.x  Issue identified while upgrading from Spring 5.0.x to 5.3.x  ```java public class CustomException extends RuntimeException {        public CustomException(String message, Throwable th) {        super(message, th);    } } ```  ```java public interface UserDAO {    void updateUser(); } ```  ```java @Repository public class UserDAOImpl implements UserDAO {        // inject entity manager (hibernate provider underneath)     @Override    public void updateUser() {        // update db throws some runtime exception (org.hibernate.HibernateException for example)    } } ```  ```java public interface MyService {    void makeUpdate(); } ```  ```java @Service public class MyServiceImpl implements MyService {     @Autowired    UserDAO userDAO;     @Transactional(noRollbackFor = CustomException.class)    public void makeUpdate() {         try {             userDAO.updateUser();         } catch (Exception ex) {             Throwable rootCause = org.apache.commons.lang3.exception.ExceptionUtils.getRootCause(ex);             if (rootCause instanceof SQLException) {                  // get sql error code (specific error codes used in db stored procedures)                  if (errorCode == x) {                      throw new CustomException(ex.getMessage(), ex);                  }             }             throw ex;         }    } } ```  The above setup works as expected in Spring 5.0.x where the transaction is not rolled back when `CustomException` is thrown. But on upgrading to 5.3.x, an exception thrown in `UserDAO` marks the transaction for rollback. This looks to be working in Spring 5.0.x because Spring does not track / parse class `UserDAO` and method `updateUser` for `@Transactional`. So there is NO `TransactionInfo` (within `TransactionAspectSupport`) created before invoking the `updateUser` method and hence no attempt to mark the transaction for rollback.  In 5.3.x, Spring is able to source `TransactionAttribute` for `UserDAO` because `SpringTransactionAnnotationParser` identifies it as a candidate for `@Transactional` and hence `TransactionInfo` is created before the method is invoked, and the transaction is marked for rollback when `RuntimeException` is thrown.  This would work if `updateUser` method in `UserDAO` is annotated with `@Transactional(noRollbackFor...)`, but I would like to start transaction in the service layer.","open","in: data,","kiranshm973","2022-06-22T18:31:26Z","2022-07-13T09:34:50Z"
"","27903","Stop defining a TaskScheduler bean in WebSocketConfigurationSupport","**Affects:** 5.3.x  `WebSocketConfigurationSupport` defines a `TaskScheduler` bean which causes [problems in Boot](https://github.com/spring-projects/spring-boot/issues/28449) as using `@EnableWebSocket` causes auto-configuration of a `ThreadPoolTaskScheduler` to back off, for example. My feeling is that this a very general contract for something that's more specific and largely an implementation detail. It would be helpful to Boot if Framework's WebSocket support could avoid defining a bean at all for its task scheduler or could use a different, WebSocket-specific type to do so.  While this affects 5.3.x, [we think](https://github.com/spring-projects/spring-boot/issues/28449#issuecomment-952632352) it may be a change that can't be made till 6.0.","closed","type: enhancement,","wilkinsona","2022-01-07T16:53:58Z","2022-01-11T10:17:20Z"
"","28227","RequestInfo combine not working if either info is null","**Affects:** 5.3.X  ### Motivation  I am currently trying to implement a feature, which allows to use nested RequestMapping classes to assemble the path:  ``` @RequestMapping(""/api/v1"") class ApiV1 {}  @RequestMapping(""/entity"") @RestController class EntityController extends ApiV1 {}  ``` so that endpoints defined in EntityController get path `/api/v1/entity..`.  **If you do not like what I am trying to accomplish here, move to section ""The Bug"", as in my opinion this needs to get fixed either way.**  ### My Approaches  I am trying to accomplish this by providing my own implementation of `RequestMappingHandlerMapping`.  #### Override `resolveEmbeddedValuesInPatterns`  My initial thought was overriding the method which is assembling the path: [RequestMappingHandlerMapping.resolveEmbeddedValuesInPatterns(String[] patterns](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java#L386)  However, the only argument is the `String[] patterns` and I do not have the handler class available (**could this be changed?**)  #### Override `getMappingForMethod`  My next attempt was overriding method [getMappingForMethod(Method method, Class handlerType)](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java#L283). My implementation would first call `super.getMappingForMethod` to receive a RequestMappingInfo, then iterate through the handlerType's superClasses and assembles the path according to the found `@RequestMapping` annotations:  (Simplified, some error checking etc. is happening here as well) ``` protected RequestMappingInfo getMappingForMethod(Method method, Class handlerType) {     RequestMappingInfo methodMapping = super.getMappingForMethod(method, handlerType);     List superclassUrlPatterns = new ArrayList();     for (Class clazz = handlerType; clazz != Object.class; clazz = clazz.getSuperclass()) {       // assemble url from found annotations            superclassUrlPatterns.add(...)     }     RequestMappingInfo superclassRequestMappingInfo = RequestMappingInfo           .paths(String.join("""", superclassUrlPatterns))           .build();     return superclassRequestMappingInfo.combine(methodMapping);    return methodMapping;   } ``` As you can see, as I already have a `methodMapping` (which I cannot modify) from the super call, I need to assemble a new one (`superclassRequestMappingInfo`) and combine these two.  ### The Bug  Combining does not work, as I am running into an [assertion error](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfo.java#L165-L166). This is caused by [some if clauses](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/RequestMappingInfo.java#L332-L338) which will only combine the two infos, if **both** are not null. In my opinion, combine should be done even if only **one** of both is not null. This can be safely done, as the called method is [doing additional checks](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/condition/PathPatternsRequestCondition.java#L161-L169).  ### The fix  Update: I locally tried to just change the `&&` to `||`, but this will fail later, due to `other` being null. What is working for me now is this (not very pretty) code:  ``` PathPatternsRequestCondition pathPatterns = null; if(this.pathPatternsCondition != null && other.pathPatternsCondition == null){     pathPatterns = this.pathPatternsCondition; } else if(this.pathPatternsCondition == null && other.pathPatternsCondition != null){     pathPatterns = other.pathPatternsCondition; } else if(this.pathPatternsCondition != null && other.pathPatternsCondition != null){     pathPatterns = this.pathPatternsCondition.combine(other.pathPatternsCondition); }  PatternsRequestCondition patterns = null; if(this.patternsCondition != null && other.patternsCondition == null){     patterns = this.patternsCondition; } else if(this.patternsCondition == null && other.patternsCondition != null){     patterns = other.patternsCondition; } else if(this.patternsCondition != null && other.patternsCondition != null){     patterns = this.patternsCondition.combine(other.patternsCondition); } ```   ### Notes  While I believe the mentioned `if` statements are a bug alone, my preferred way to accomplish my task would rather be to override `resolveEmbeddedValuesInPatterns` and have the **handler included as a parameter**. If this is not something you'd consider, I can proceed with my 2nd approach as soon as the bug got fixed.","closed","in: web,","ericlacher","2022-03-24T10:41:59Z","2022-05-09T11:10:24Z"
"","28871","Method level @RequestMapping does not seem to narrow the HTTP method of type level mapping","**Affects:** 5.3.22  --- According to my understanding of the Spring MVC documentation, annotating a controller method with @RequestMapping(method=X) has a narrowing effect on @RequestMapping  applied to the controller class. To quote from the docs:  > public abstract RequestMethod[] method > The HTTP request methods to map to, narrowing the primary mapping: GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE. > Supported at the type level as well as at the method level! When used at the type level, all method-level mappings inherit this HTTP method restriction. >   Yet, with Http method, this doesn't seem to be the case - it seems that if both class and method are annotated with @RequestMapping, and both annotations have a method parameter, the method will be used to serve HTTP request of HTTP methods pertaining to the union of the annotations.  For example this passes:      @RestController     @RequestMapping(value = ""/multi"", method = RequestMethod.POST)     public class MultiAnno {         @RequestMapping(value = ""/rm"", method = RequestMethod.PATCH)         public String getFoo() {             return ""Foo"";         }     }      @RunWith(SpringJUnit4ClassRunner.class)     @ContextConfiguration(classes = MvcConfig.class)     @WebAppConfiguration     @AutoConfigureWebClient     public class MappingsExampleIntegrationTest {                  private MockMvc mockMvc;                  @Autowired         private WebApplicationContext webApplicationContext;              @Before         public void setUp() {             mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();         }                  @Test         public void whenMultiRM() throws Exception{             mockMvc.perform(post(""/multi/rm""))                     .andExpect(status().isOk());             mockMvc.perform(patch(""/multi/rm""))                     .andExpect(status().isOk());             mockMvc.perform(put(""/multi/rm""))                     .andExpect(status().is(not(HttpStatus.OK)));         }     }","closed","status: invalid,","urisimchoni","2022-07-25T21:34:49Z","2022-07-27T06:11:53Z"
"","28806","Typo in `SockJsServiceRegistration#setSupressCors`","**Affects:** 5.3.21  --- There is a typo in `org.springframework.web.socket.config.annotation.SockJsServiceRegistration#setSupressCors`: the method should be named `setSuppressCors`.","closed","status: superseded,","marcwrobel","2022-07-12T18:09:43Z","2022-07-22T07:45:06Z"
"","28660","Add support in MockRestServiceServer to verify header values with an Iterable Matcher","**Affects:** 5.3.21  ---  The current API for `MockRestServiceServer` and `MockRestRequestMatchers` does not allow a test to validate that all values of a certain header key satisfy a matcher. Trying to do  ```java .andExpect(header(""Accept"", endsWith(""json""))) ```  does not work because it passes if the first value for the header ends with `""json""`. I would like to be able to do something like this:  ```java .andExpect(header(""Accept"", allMatch(endsWith(""json"")))) ```  or something to that effect.","open","type: enhancement,","mspiess","2022-06-20T07:49:05Z","2022-07-05T22:28:39Z"
"","28904","GenericTypeResolver resolves to an incorrect type if a class implements multiple generic interfaces depending on the order of definition of the interfaces.","**Affects:** 5.3.20  GenericTypeResolver#resolveVariable(TypeVariable typeVariable, ResolvableType contextType) eventually resorts to recursively resolving the type of typeVariable by iterating over contextType.getInterfaces(). The first generic interface will hit the ""// Fallback to bounds""-branch in ResolvableType#resolveType() even though this interface (and its generic type) might have nothing to do with typeVariable.  Workaround for us: omitting the type bound ""F extends Number"" at FooService  **Minimal working example:**  **Output**: java.lang.Integer java.lang.Number  **Expected output**: java.lang.Integer java.lang.Integer  **Code**: ``` import java.lang.reflect.Type;  import org.springframework.core.GenericTypeResolver;  public class Main {      public static class BaseParam {     }      public static class FooParam extends BaseParam {     }      public interface FooService {          default void foo(F f) {             // ...         }     }      public interface BarService {          default void bar(B b) {             // ...         }     }      public static class FooBarService implements FooService, BarService {     }      public static class BarFooService implements BarService, FooService {     }      public static void printType(Class cls) {          Type f = FooService.class.getTypeParameters()[0];         System.out.println(GenericTypeResolver.resolveType(f, cls).getTypeName());     }      public static void main(String[] args) throws Exception {          printType(FooBarService.class);         printType(BarFooService.class);     } } ```","open","status: waiting-for-triage,","arneschweenbs","2022-08-01T14:59:05Z","2022-08-01T15:00:49Z"
"","28830","null Integer value causing java.lang.IllegalStateException ... no multi-part configuration ...","**Affects:** 5.3.20  - org.springframework.boot 2.7.0 - spring-boot-starter-jersey-2.7.0.jar - jersey-media-multipart-2.35.jar  ---  > java.lang.IllegalStateException: Unable to process parts as no multi-part configuration has been provided  this exception happens when I send a null Integer as part of a multipart_form_data.  Client uses axios, so it seems unlikely there is anything wrong with the request format.  Even if a null Integer is not legit in mulitpart_form_data, I would expect a more meaningful exception message.  browser code: ```javascript var formData = new FormData(); formData.set(""maybenull"", null); axios.post(""http://127.0.0.1:8000/rest/lognull"", formData, { headers: { 'Content-Type': 'multipart/form-data' } } )  var formData = new FormData(); formData.set(""maybenull"", null); axios.post(""http://127.0.0.1:8000/rest/testnull"", formData, { headers: { 'Content-Type': 'multipart/form-data' } } ) ```  below are the two REST methods. ""/lognull"" logs the message as text so we can see exactly what the browser sent.  ""/testnull"" attempts to handle the message as multipart_form_data, causing ""java.lang.IllegalStateException: Unable to process parts as no multi-part configuration has been provided"" I copied the logging below each REST method  ```java   @javax.ws.rs.Path(""/lognull"")   @POST   @Consumes({MediaType.MULTIPART_FORM_DATA})   @Produces(MediaType.APPLICATION_JSON)   public Response logNull(String message) {     logger.info(""message: "" + message);     ResponseBuilder rBldr = Response.status(javax.ws.rs.core.Response.Status.OK);     rBldr.entity(""{ \""message\"": \""OK\"" }"" );     return rBldr.build();   } ```  > message: ------WebKitFormBoundaryQRiHpL9ktT5imsBc > Content-Disposition: form-data; name=""maybenull"" >  > null > ------WebKitFormBoundaryQRiHpL9ktT5imsBc--   ```java   @javax.ws.rs.Path(""/testnull"")   @POST   @Consumes({MediaType.MULTIPART_FORM_DATA})   @Produces(MediaType.APPLICATION_JSON)   public Response testNull(@FormDataParam(""maybenull"") Integer maybenull) {       System.out.println(""maybenull: "" + maybenull);       ResponseBuilder rBldr = Response.status(javax.ws.rs.core.Response.Status.OK);       rBldr.entity(""{ \""message\"": \""OK\"" }"" );       return rBldr.build();   } ```  ``` 2022-07-17 10:18:36.387 ERROR 380463 --- [nio-8000-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] threw exception  java.lang.IllegalStateException: Unable to process parts as no multi-part configuration has been provided 	at org.apache.catalina.connector.Request.parseParts(Request.java:2866) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.connector.Request.getParts(Request.java:2834) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.connector.RequestFacade.getParts(RequestFacade.java:1098) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at javax.servlet.http.HttpServletRequestWrapper.getParts(HttpServletRequestWrapper.java:361) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.parseRequest(StandardMultipartHttpServletRequest.java:95) ~[spring-web-5.3.20.jar!/:5.3.20] 	at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.(StandardMultipartHttpServletRequest.java:88) ~[spring-web-5.3.20.jar!/:5.3.20] 	at org.springframework.web.multipart.support.StandardServletMultipartResolver.resolveMultipart(StandardServletMultipartResolver.java:122) ~[spring-web-5.3.20.jar!/:5.3.20] 	at org.springframework.web.servlet.DispatcherServlet.checkMultipart(DispatcherServlet.java:1205) ~[spring-webmvc-5.3.20.jar!/:5.3.20] 	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) ~[spring-webmvc-5.3.20.jar!/:5.3.20] 	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.20.jar!/:5.3.20] 	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.3.20.jar!/:5.3.20] 	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) ~[spring-webmvc-5.3.20.jar!/:5.3.20] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:681) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.3.20.jar!/:5.3.20] 	at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.3.20.jar!/:5.3.20] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) ~[spring-web-5.3.20.jar!/:5.3.20] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:102) ~[spring-web-5.3.20.jar!/:5.3.20] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:102) ~[spring-web-5.3.20.jar!/:5.3.20] 	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:711) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:461) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:385) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:313) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:403) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:249) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:360) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:890) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1743) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.63.jar!/:na] 	at java.base/java.lang.Thread.run(Thread.java:833) ~[na:na] ```","closed","for: external-project,","nfin","2022-07-17T14:51:05Z","2022-07-27T15:55:39Z"
"","28522","Creating relative resource for URL resource does not create relative Resource if relative path has URL in it","**Affects:** 5.3.19 (most likely any version)  We were using the combination of `ResourcePatternResolver#getResources` and `Resource#createRelative` for something and received a bug report from a client that doing `Resource#createRelative` was resolving to an entirely different resource.  e.g.  We have an empty folder named `reports` on the classpath and if we run the test below it is going to fail because the creation of a relative resource for ""http://localhost:8080"" will be a resource pointing to that URL and not relative to ""classpath*:reports/""  ``` public class UrlResourceTest {      @Test     void testRelativeResource() throws IOException {         PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();         for (Resource resource : resolver.getResources(""classpath*:reports/"")) {             Resource relative = resource.createRelative(""image.png"");             assertThat(relative.getURL().toString())                     .contains(""reports"");             Resource relativeUrl = resource.createRelative(""http://localhost:8080"");              assertThat(relativeUrl.getURL().toString())                     .contains(""reports"");          }     } } ```  We realized that in this example the resolved resource for ""classpath*:reports/"" is a `UrlResource` and doing `createRelative` on it will delegate to the JDK `new URL(this.url, relativePath)`.   We were expecting that doing `Resource#createRelative` will treat the passed relative path as relative, irregardless whether it is a URL, or something else. Were we wrong with our expectations?","open","status: waiting-for-triage,","filiphr","2022-05-25T10:21:22Z","2022-05-25T10:25:17Z"
"","28671","NullPointerException in UrlPathHelper.getSanitizedPath","**Affects:** 5.3.19 ---  The following exception appeared in our central error logging. I don't know what the input URL was exactly; unfortunately the following stack trace is all the information I have on this issue.  Java Version: 17  **Stack Trace:**  ``` java.lang.NullPointerException: Cannot invoke ""String.indexOf(String)"" because ""path"" is null     at org.springframework.web.util.UrlPathHelper.getSanitizedPath(UrlPathHelper.java:408)     at org.springframework.web.util.UrlPathHelper.decodeAndCleanUriString(UrlPathHelper.java:551)     at org.springframework.web.util.UrlPathHelper.getOriginatingRequestUri(UrlPathHelper.java:496)     at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.addContentDispositionHeader(AbstractMessageConverterMethodProcessor.java:431)     at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:288)     at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:183)     at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:78)     at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:135)     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895)     at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)     at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067)     at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963)     at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)     at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)     at javax.servlet.http.HttpServlet.service(HttpServlet.java:681)     at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)     at javax.servlet.http.HttpServlet.service(HttpServlet.java:764)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)     at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:327)     at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:122)     at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:116)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:126)     at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:81)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:109)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:149)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.txture.microservice.common.compression.GzipFilter.doFilter(GzipFilter.kt:22)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.txture.microservice.common.security.JwtAuthenticationFilter.doFilterInternal(JwtAuthenticationFilter.kt:68)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:103)     at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:89)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:91)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)     at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:110)     at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:55)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)     at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:336)     at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:211)     at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:183)     at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:354)     at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:267)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)     at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)     at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)     at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)     at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197)     at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)     at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:540)     at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135)     at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)     at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)     at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:769)     at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:359)     at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399)     at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)     at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:889)     at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1735)     at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)     at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)     at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)     at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)     at java.lang.Thread.run(Thread.java:833) ```","open","in: web,","MartinHaeusler","2022-06-21T11:06:40Z","2022-07-26T07:12:31Z"
"","28278","MockRestServiceServer.verify() did not work with single API testing if project has more than one API","**Affects:** 5.3.18 --- MockRestServiceServer.verify() did not work with single API testing if project has more than one API.  Example:  ``` @Component public class Test {  	@Autowired 	private RestTemplate restTemplate;  	@Scheduled(fixedDelay = 3000) 	public void schedule1() { 		restTemplate.getForEntity(URI.create(""http://localhost:9090/api1""), String.class); 	} 	 	@Scheduled(fixedDelay = 3000) 	public void schedule2() { 		restTemplate.getForEntity(URI.create(""http://localhost:9090/api2""), String.class); 	} } ``` ``` @ExtendWith({ SpringExtension.class }) @SpringBootTest(classes = Demo1Application.class) class TestTest {  	@Autowired 	private RestTemplate restTemplate;  	private MockRestServiceServer mockServer;  	@Test 	void testSchedule1() { 		mockServer = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build(); 		mockServer 				.expect(ExpectedCount.manyTimes(), 						MockRestRequestMatchers.requestTo(new StringStartsWith(""http://localhost:9090/api1""))) 				.andExpect(MockRestRequestMatchers.method(HttpMethod.GET)) 				.andRespond(MockRestResponseCreators.withStatus(HttpStatus.OK).body(""""));  		mockServer.verify(Duration.ofSeconds(10)); 	}  	@Test 	void testSchedule2() { 		mockServer = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build(); 		mockServer 				.expect(ExpectedCount.manyTimes(), 						MockRestRequestMatchers.requestTo(new StringStartsWith(""http://localhost:9090/api2""))) 				.andExpect(MockRestRequestMatchers.method(HttpMethod.GET)) 				.andRespond(MockRestResponseCreators.withStatus(HttpStatus.OK).body("""")); 		mockServer.verify(Duration.ofSeconds(10)); 	}  } ```  If the **schedule1** executes first, then the **testSchedule2** fails and vice versa. ``` java.lang.AssertionError: No further requests expected: HTTP GET http://localhost:9090/api1 0 request(s) executed. ``` The Map **requestFailures** in **AbstractRequestExpectationManager** seems stores all executed APIs even it is not expected.","open","status: waiting-for-triage,","copsafe","2022-04-03T15:27:56Z","2022-04-03T15:32:28Z"
"","28419","Accept BCP 47 language tags in LocaleEditor","**Affects:** 5.3.18  `org.springframework.beans.propertyeditors.LocaleEditor` should accept BCP 47 language tags too, like `org.springframework.core.convert.support.StringToLocaleConverter` does.  `LocaleEditor` uses `StringUtils.parseLocaleString(text)` that does not accept the language tag string. While the `StringToLocaleConverter` uses `StringUtils.parseLocale(source)` which works with language tags well.","closed","type: enhancement,","foal","2022-05-05T06:29:10Z","2022-05-10T08:40:39Z"
"","28521","HierarchicalUriComponents::getPort() throws NumberFormatException with invalid port in URI","**Affects:** 5.3.18  ---  `HierarchicalUriComponents::toUri()` throws `java.lang.NumberFormatException` instead of the expected `IllegalStateException` when provided with a URI of the format `https://x.com:string`.","closed","type: bug,","Jackson-S","2022-05-25T06:37:38Z","2022-05-25T09:35:18Z"
"","28230","PathMatchingResourcePatternResolver doesn't work in fat-jar run scenario","**Affects:** 5.3.17  I might have found an issue with classpath scanning of resources in a Bazel environment.  Here is some sample code: ```Java URL resource1 = getClass().getResource(""/files/resource1.txt""); LOG.debug(""URL for '/files/resource1.text' is: {}"", resource1);  URL resource2 = getClass().getResource(""/files/resource2.txt""); LOG.debug(""URL for '/files/resource2.text' is: {}"", resource2);  final PathMatchingResourcePatternResolver resolver =         new PathMatchingResourcePatternResolver(MyBuilderCommand.class.getClassLoader()); Resource[] result = resolver.getResources(""classpath*:/files/*.txt""); if (result.length == 0) {     LOG.error(""No results returned from classpath for 'classpath*:/files/*.txt'""); } ```  In all cases - accessing via `getClass().getResource(..)` always works. It's the ` resolver.getResources(""classpath*:/files/*.txt"")` call that's failing in some cases.   Here are steps to reproduce: ``` git clone git@github.com:salesforce/bazel-java-builder-template.git  # works as expected bazel run :mybuilder -- --current-target=foo -i BUILD  -o /var/tmp/ --verbose  # does not work bazel run :mybuilder2 -- --current-target=foo -i BUILD  -o /var/tmp/ --verbose  # building a all-in-one-jar also doesn't work bazel-bin/mybuilder2_deploy.jar java -jar bazel-bin/mybuilder2_deploy.jar --current-target=foo -i BUILD  -o /var/tmp/ --verbose ```  The difference is only in packaging. So I believe it must be something within `PathMatchingResourcePatternResolver`","open","in: core,","guw","2022-03-24T15:40:35Z","2022-04-25T09:53:46Z"
"","28233","Introduce cancel(boolean mayInterruptIfRunning) in ScheduledTask","**Affects:** 5.3.17  ---  Hello everyone,  I am working on a scheduling solution and I want to cancel a scheduled task on demand. I am using `ScheduledTask` which has a `cancel()` method:  https://github.com/spring-projects/spring-framework/blob/42a61b966b7d38f073f65b1c1cacbd92ac0b9c2c/spring-context/src/main/java/org/springframework/scheduling/config/ScheduledTask.java#L55-L63  If I call it, it cancels the task, and it never executes it again unless I resume the task, so, everything is good as expected. But there is a use case which is a problem for me.  I see that the call `future.cancel(true);` means that if the task is currently running it interrupts it immediately, without letting it finish, which could cause issues depending on the task performed. This is because the call is obligatory done with the boolean true, without any other option.  Wouldn't it be more flexible to allow `cancel()` to take this into consideration? It could be enough to create another method `cancel(boolean mayInterruptIfRunning);`.  or even removing the `final` accessor from this class:  `public final class ScheduledTask {....}`  since because of this I can't extend from it and overwrite the method mentioned. I think would be useful to have the chance to make more flexible this behavior.  Of course, please tell me if I am missing some considerations about why this class has to be `final` and this `future.cancel();` method is called always mandatory with `true`.  If in the end you consider any of the changes I proposed, I would be happy to contribute.  My proposed solution:  ```java public final class ScheduledTask {  // . . .    /**    * Trigger cancellation of this scheduled task with optional interruption if running.    *     * @param mayInterruptIfRunning if true, it will force interruption the task if running. If false, it will let it finish before cancelling.    */   public void cancel(final boolean mayInterruptIfRunning) {     ScheduledFuture future = this.future;     if (future != null) {       future.cancel(mayInterruptIfRunning);     }   }    /**    * Trigger cancellation of this scheduled task with forced interruption if running.    */   public void cancel() {     this.cancel(true);   } ```  Thanks","closed","type: enhancement,","fcanovas1986","2022-03-25T12:07:09Z","2022-03-25T17:19:56Z"
"","28252","StompSubProtocolHandler - Authentication Logging","**Affects:** 5.3.17  ---  As part of #26026 the logging in StompSubProtocolHandler was improved to prevent the logging of exceptions pertaining to failed authentication. More specifically, this suppression applies to STOMP CONNECT messages as per (https://github.com/spring-projects/spring-framework/commit/bcd2b9a8a7d4e0b8b6615787122d5f2a2d3eb70c#diff-624b9c9ccd9db4e56263e34b3e865fdce34e9b1dd00a00f956f919ede789265fR337).   Given that Spring Security allows for access decisions to be made at the topic level when users Subscribe (using `MessageSecurityMetaDataSourceRegistry.simpSubscribeDestMatchers(String... patterns)`) should the logging suppression be enhanced to apply to both CONNECT and SUBSCRIBE messages? This will therefore suppress the error level logging when a user fails authorization when subscribing to a topic.","open","status: feedback-provided,","phil-applegate","2022-03-30T09:29:46Z","2022-04-29T08:35:24Z"
"","28137","Unexpected @Bean Definition Behavior when Using Inheritance in @Configuration Classes","**Affects:** 5.3.16  ---  The interaction of Spring @Configuration annotated classes with @Bean annotated method and inheritance behaves sort of like normal java inheritance and sort of like inclusion, but not consistently in either way.    For example if:  1) a parent class has an @Bean method and 2) the child class overrides that method, and  3) then only the child class is registered/imported by the context   and given:   - the normal java rules of annotation inheritance on methods i.e. they are not inherited by overridden methods  one would expect:  1) the bean defined by the parent method to not be defined if the child does not re-annotated the method with an @Bean 2) or, the bean defined by the parent method should be renamed if the method is re-annotated with a @Bean with a different name 3) or, the bean defined by the parent method should be overridden if the method is re-annotated with a @Bean with no name/or the same name.  Expectations 1 and 2 are not met in that the bean defined by the parent class does exist in the context.  And expectation 3 is only met if the names agree between the child and parent.  One could maybe argue that inheritance behaves like inclusion, which I would find weird, but a model, but then that is not consistent with itself, in that the value of the bean will be the result of the overridden method and not the parent method.  Other people have also been confused by this: https://stackoverflow.com/questions/39573558/spring-java-config-extending-an-abstract-configuration.  The answers in that SO post are not really satisfying and amount to ""well that's how it's implemented"".  The following code reproduces the issue (also attached as a gradle project):  ```java public class SpringConfigInheritance {  	@Configuration 	public static class ParentConfig { 		@Bean 		public String bean() { 			return ""parent""; 		} 		 		@Bean 		public String configClass() { 			return getClass().getName(); 		} 	} 	 	@Configuration 	public static class ChildConfig extends ParentConfig { 		@Bean(""renamed-bean"") 		@Override 		public String bean() { 			return ""child""; 		} 	} 	 	public static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { 	 		System.out.println(""Given normal inheritance rules and the rules for annotations on methods the expected output would be:""); 	 		ChildConfig childConfig = new ChildConfig(); 		for ( Method method : ChildConfig.class.getMethods() ) { 			if ( method.isAnnotationPresent(Bean.class) ) { 				String[] names = method.getAnnotation(Bean.class).value(); 				Object   value = method.invoke(childConfig); 				System.out.println(""@Bean method: "" + method.getName() +  								   ""\n\tBean names: "" + Arrays.stream(names).collect(Collectors.joining("", "")) + 								   ""\n\tBean value: "" + Objects.toString(value)); 			} 		} 		 		System.out.println(); 		System.out.println(""What spring gives us is actually: ""); 		 		// Parent with one child config 		try ( AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext() ) { 			context.register(ChildConfig.class); 			context.refresh(); 			 			for ( String name : context.getBeanDefinitionNames() ) { 				BeanDefinition definition = context.getBeanDefinition(name); 				if ( definition.getRole() == BeanDefinition.ROLE_APPLICATION && definition.getFactoryMethodName() != null) 				{ 					Object value = context.getBean(name); 					 					System.out.println(""@Bean method: "" + definition.getFactoryMethodName() +  								   ""\n\tBean names: "" + name +"", "" + Arrays.stream(context.getAliases(name)).collect(Collectors.joining("", "")) + 								   ""\n\tBean value: "" + Objects.toString(value));				 				} 			} 			 			System.out.println(); 			System.out.println(""Let's see if this is consistent with an inheritence == inclusion model by running some tests:"");  			// Why does this bean exist?  We only included ChildConfig. 			// Okay, so inheritance == inclusion?  Maybe this make sense because of parallels to XML config? 			boolean hasParentBean = context.containsBean(""bean""); 			System.out.printf(""parent bean existence: %s -> inheritance %s inclusion\n"", hasParentBean, hasParentBean ?""=="":""!=""); 			 			if ( hasParentBean ) { 				// Let's double check that it isn't just an alias now, which would be consistent with inclusion 				boolean isAlias = context.isAlias(""bean""); 				System.out.printf(""parent bean is alias test: %s -> inheritance %s inclusion\n"", isAlias, isAlias?""!="":""==""); 				 				// Let's double check that it isn't just an alias now, which would be consistent with inclusion 				isAlias = context.isAlias(""renamed-bean""); 				System.out.printf(""child bean is alias test: %s -> inheritance %s inclusion\n"", isAlias, isAlias?""!="":""==""); 				 				// Alright, so if inheritance == inclusion, then the value should be ""parent""  				String parentBean = context.getBean(""bean"", String.class); 				boolean isExpectedValueViaInclusion = parentBean.equals(""parent""); 				System.out.printf(""parent bean value == \""parent\"" test: %s -> inheritance %s inclusion\n"", isExpectedValueViaInclusion, isExpectedValueViaInclusion?""=="":""!=""); 				 				// Alright, so if inheritance == inclusion, then the configClass value should be ""ParentConfig""??? 				String configClass = context.getBean(""configClass"", String.class); 				boolean isExpectedConfigClassViaInclusion = configClass.equals(""springBugs.configInheritance.SpringConfigInheritance$ParentConfig""); 				System.out.printf(""parent configClass value == \""springBugs.configInheritance.SpringConfigInheritance$ParentConfig\"" test: %s -> inheritance %s inclusion\n"", isExpectedConfigClassViaInclusion, isExpectedConfigClassViaInclusion?""=="":""!=""); 			} 		} 	} } ```  Running this program produces the following output:  Given normal inheritance rules and the rules for annotations on methods the expected output would be:  ``` @Bean method: bean 	Bean names: renamed-bean 	Bean value: child @Bean method: configClass 	Bean names:  	Bean value: springBugs.configInheritance.SpringConfigInheritance$ChildConfig ```  What spring gives us is actually:   ``` @Bean method: bean 	Bean names: renamed-bean,  	Bean value: child @Bean method: bean 	Bean names: bean,  	Bean value: child @Bean method: configClass 	Bean names: configClass,  	Bean value: springBugs.configInheritance.SpringConfigInheritance$ChildConfig$$EnhancerBySpringCGLIB$$cb54331c ```  Let's see if this is consistent with an inheritence == inclusion model by running some tests:  ``` parent bean existence: true -> inheritance == inclusion parent bean is alias test: false -> inheritance == inclusion child bean is alias test: false -> inheritance == inclusion parent bean value == ""parent"" test: false -> inheritance != inclusion parent configClass value == ""springBugs.configInheritance.SpringConfigInheritance$ParentConfig"" test: false -> inheritance != inclusion ```  I believe the correct behavior, as outlined above, should be consistent with Java method annotation rules w/r/t inheritance.    I'm not exactly sure I see the exact fix, but it would seem that ConfigurationClassParser should do some checking of overridden @Bean methods prior to adding them to the ConfigurationClass.  Since they are recursively parsed, starting at the actually registered class, it should be possible to do a check for overloads prior to registering.  Or maybe this is the wrong place altogether to do it.  At a minimum, I think that the documentation should be clarified about what the rules and effects are of inheritance in @Configuration annotated classes.  [spring-container-inheritance-bug.tar.gz](https://github.com/spring-projects/spring-framework/files/8188815/spring-container-inheritance-bug.tar.gz)","open","in: core,","mbach979","2022-03-04T21:28:49Z","2022-03-05T14:43:14Z"
"","27987","unexpected backout behaviour with DMLC and Websphere MQ","**Affects:** 5.3.15  Websphere MQ has a strange way of backout handling (i.e. moving poison messages). It does not move poison messages to the backout queue immediately on the ""final"" rollback, but only increments the internal BackoutCount (to be one more than it should be able to be) and leaves the message on the initial queue. The actual move is performed in a subsequent (unrelated!) receive-call. This is documented [here](https://www.ibm.com/docs/en/ibm-mq/9.1?topic=applications-handling-poison-messages-in-mq-classes-jms).  > If an application receives messages synchronously, by calling one of the following methods, the IBM MQ classes for JMS requeue a poison message within the unit of work that was active when the application tried to get the message:  > This means that if the application is using either a transacted JMS context or session, then the moving of the message to the backout queue is not committed until the transaction is committed.  This behaviour does not effect e.g. JavaEE-MDB-Listeners. > If an application is receiving messages asynchronously via a MessageListener, the IBM MQ classes for JMS requeue poison messages without affecting message delivery. The requeue process takes place outside of any unit of work associated with actual message delivery to the application.  DMLC uses a polling approach and thus is susceptible to the described behaviour. It is not really possible to observe this behaviour, as any attempt to ""see"" the messages moves it to the right queue. Only way is to ""not observe"" the message already being in the backout queue.  The practical implications are two-fold: * A single poison message is not immediately visible on the appropriate backout queue for handling. Is is only moved when a next receive-pass **commits** (takes in the worst case the amount of receive-timout + handling of an unrelated msg). * In a scenario where temporarily all/many messages are poison the move-to-backout-operations may also **rollback**. (We found out about this by observing MQ-""uncommited""-metrics showing rising and falling backout queue counts.)  As a browse also seems to (undocumented) trigger the move, which in itself is weird for a read-only-operation, we found a workaround: After the ""final"" rollback try to browse to the message which will move it. This does not seem feasible as a generic solution, as the app needs to know the backout threshold.  Spring probably cannot fix this. The best way would be to fix this in MQ. As this seems unlikely, maybe spring could at least document/warn/... the presence of this behaviour.  Reproducing projects: * Websphere-MQ https://github.com/apinske/playground-mq/tree/backout-wmq * Active-MQ https://github.com/apinske/playground-mq/tree/backout-amq","closed","status: declined,","apinske","2022-01-29T12:19:35Z","2022-02-18T20:00:01Z"
"","28063","Plain JSON strings in the request body are not decoded correctly","**Affects:** 5.3.15  I am doing an ""application/json"" PUT request containing a plain JSON string (with a leading and a trailing double quote) in the body. I am not able to get the (JSON-decoded) string content (without the double quotes) using a correctly declared controller method:  ```java @PutMapping(path = ""/put"", consumes = MediaType.APPLICATION_JSON_VALUE)  public void doPut(@RequestBody String string) ```  Instead this method always gives me the encoded JSON string with the double quotes.  I wonder why Spring behaves differently on JSON objects vs. JSON string literals. It seems that others stumbled about this problem too: https://stackoverflow.com/questions/64990357/parsing-a-request-body-containing-a-quoted-string-as-json-in-spring-boot-2","closed","status: invalid,","markusheiden","2022-02-16T17:22:06Z","2022-02-18T19:03:28Z"
"","27977","dataMimeType use default by connect, can you parse by request?","**Affects:** 5.3.15  ---  When most of my applications provide json calling methods, and very few are transferring files, at below file, use dataMimeType by connect, Can you parse it again here?   https://github.com/spring-projects/spring-framework/blob/main/spring-messaging/src/main/java/org/springframework/messaging/rsocket/annotation/support/MessagingRSocket.java  ```java 	private MessageHeaders createHeaders( 			Payload payload, FrameType frameType, @Nullable AtomicReference> responseRef) {  		MessageHeaderAccessor headers = new MessageHeaderAccessor(); 		headers.setLeaveMutable(true);  		Map metadataValues = this.metadataExtractor.extract(payload, this.metadataMimeType);  		metadataValues.putIfAbsent(MetadataExtractor.ROUTE_KEY, """"); 		for (Map.Entry entry : metadataValues.entrySet()) { 			if (entry.getKey().equals(MetadataExtractor.ROUTE_KEY)) { 				RouteMatcher.Route route = this.routeMatcher.parseRoute((String) entry.getValue()); 				headers.setHeader(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER, route); 			} 			else { 				headers.setHeader(entry.getKey(), entry.getValue()); 			} 		} // here use connect dataMimeType 		headers.setContentType(this.dataMimeType); 		headers.setHeader(RSocketFrameTypeMessageCondition.FRAME_TYPE_HEADER, frameType); 		headers.setHeader(RSocketRequesterMethodArgumentResolver.RSOCKET_REQUESTER_HEADER, this.requester); 		if (responseRef != null) { 			headers.setHeader(RSocketPayloadReturnValueHandler.RESPONSE_HEADER, responseRef); 		} 		headers.setHeader(HandlerMethodReturnValueHandler.DATA_BUFFER_FACTORY_HEADER, 				this.strategies.dataBufferFactory());  		return headers.getMessageHeaders(); 	} ```","closed","in: messaging,","seal90","2022-01-25T15:31:30Z","2022-03-11T10:06:20Z"
"","27959","Deprecate AsyncTaskExecutor.execute(Runnable task, long startTimeout)","**Affects:** 5.3.15  ---  The `ThreadPoolTaskExecutor` implements the `AsyncTaskExecutor` interface, so it has the method `void execute(Runnable task, long startTimeout)`.  The implementation for that method silently ignores the timeout. It just calls the execute method without the timeout specified.  ```java public void execute(Runnable task, long startTimeout) {     execute(task); } ```  The Javadoc for the method says that `startTimeout` is intended as a hint to the executor, but if the implementation does not support it at all I think it would be better to throw a `org.springframework.core.task.TaskRejectedException` instead.  To just silently ignore the `startTimeout` gives no clue to the caller that an unsupported method is called.","closed","type: enhancement,","nytro77","2022-01-20T07:31:00Z","2022-02-04T22:30:39Z"
"","28021","Spring Boot should release test contexts which failed to load","**Affects:** 5.3.15  ---  For a Spring Boot project with many tests loading the Spring context (`@SpringBootTest`): if loading the Spring context fails, the context will remain in memory and test execution will eventually fail with `OutOfMemoryError` (hiding the original problem).  I created a heap dump of a failed run. I see 109 instances of `org.springframework.beans.factory.support.DefaultListableBeanFactory` on the heap. I see these paths to GC roots preventing the context from being garbage collected: ![image](https://user-images.githubusercontent.com/1880345/153160488-0ea523f4-034b-48ac-aae2-41b3180f1341.png)  The context should be closed, when it fails loading. At least for tests.","closed","for: external-project,","ewirch","2022-02-09T08:58:39Z","2022-02-16T11:22:46Z"
"","27969","RestTemplate reading Json prohibits JDK HttpClient connection reuse (keep-alive)","**Affects:** 5.3.14  There is an issue regarding https connection reuse (keep-alive) when using jackson unmarshaller, chunked transfer encoding and RestTemplate. The connections are not reused, which leads to more TLS handshakes for subsequent calls.  * When the Jackson `AUTO_CLOSE_SOURCE`-Feature is enabled (which is the default), jackson closes the `HttpInputStream` in `UTF8StreamJsonParser._closeInput()` after the json doc is fully read. * The stream is not at EOF yet, though. The `last-chunk` (as of [RFC7230 4.1)](https://datatracker.ietf.org/doc/html/rfc7230#section-4.1) is still ""waiting on the wire"". * This leads to a call to `sun.net.www.http.ChunkedInputStream.hurry()` which aims to read all the remaining bytes.  * This does not succeed fully, because in `sun.net.www.http.ChunkedInputStream.readAheadNonBlocking()` `in.available()` may not return all remaining bytes.  * This can lead to a `ChunkedInputStream` that is not in state `STATE_DONE`, which will lead to it being closed, instead of kept alive.  This is a combination of multiple unrelated things, that may not be issues in their own rights.  * JDK-HttpClient `hurry()` may leave unread bytes in the stream, which is probably okay, as close() was called prematurely. * Jackson by default calls `close()` prematurely, having not read all input. * Spring provides Jackson in its default configuration on top of JDK-HttpClient.     * Spring has its own feature to drain http streams, and should probably not rely on Jackson closing the stream.  I open this bug against Spring, because I think it is the best place to fix the issue.  Find a reproducing project at: https://github.com/apinske/playground-http/tree/spring-framework-issues-27969","closed","type: enhancement,","apinske","2022-01-22T15:04:13Z","2022-02-02T17:36:59Z"
"","27923","Cannot read server-sent events without data (a.k.a. heartbeats)","**Affects:** 5.3.11+ `org.springframework.http.codec.ServerSentEventHttpMessageReader.buildEvent(List lines, ResolvableType valueType, boolean shouldWrap, Map hints)` yields a StringIndexOutOfBoundsException if a line equals ""data:"", because `line.charAt(5)` is called. This means that it fails at reading server-sent events that are heartbeats.","closed","type: regression,","BvanMunster","2022-01-12T12:03:19Z","2022-01-12T16:09:14Z"
"","27937","AspectJ: @PostConstruct method cannot invoke @Cacheable method in another bean","**Affects:** 5.3.10  --- I'm using AspectJ `@EnableCaching(mode = AdviceMode.ASPECTJ)`.  Invoking an `@Cacheable` method from a bean's `@PostConstruct` method doesn't work, because the cache aspect is not initialized. (see [code](https://github.com/spring-projects/spring-framework/blob/316e84f04f3dbec3ea5ab8563cc920fb21f49749/spring-context/src/main/java/org/springframework/cache/interceptor/CacheAspectSupport.java#L339)).  The Cache aspect is a `SmartInitializingSingleton` and is initialized too late, after my bean was already created.  My use case: populate cache at startup, before accepting web requests.","open","status: feedback-provided,","cdalexndr","2022-01-15T21:04:59Z","2022-01-17T21:17:47Z"
"","28379","`DefaultWebClientBuilder` should support dynamic loading of default `ClientHttpConnector`","**Affects:** 5.3+  Applications creating `WebClient` instances have the option of either explicitly specifying the `ClientHttpConnector` to be used for that instance via `builder.clientConnector(...)` or using a default `ClientHttpConnector` provided by the builder implementation.  The current `DefaultWebClientBuilder` implementation currently manually chooses the default `ClientHttpConnector` provider to be used for `WebClient` instances. The current implementation is hardcoded to recognize specific implementation classes in a preferred order and chooses the first provider which is present on the class-path as the default connection provider.  We have built our own `ClientHttpConnector` implementation and would like to use it as the default connector in our applications. A current source of errors for our users is forgetting to initialize the `WebClient.Builder.clientConnector(new OurClientHttpConenctor())`. The need to modify existing application source code in order to user our client connector is also an inconvenience.  `DefaultWebClientBuilder` should be improved to use a `SpringFactoriesLoader`,  JDK `ServiceLoader` or other dynamic mechanism for loading/defining the `ClientHttpConnector` factories and choosing the default factory implementation for an application.","open","status: waiting-for-triage,","bondolo","2022-04-25T19:04:25Z","2022-04-25T19:07:33Z"
"","27956","Provide support for post-processing a LocalValidatorFactoryBean's validator Configuration without requiring sub-classing","**Affects:** 5.3  `LocalValidatorFactoryBean` currently allows the validator `Configuration` to be post-processed but this requires a custom sub-class and an override of `postProcessConfiguration`. Given that Framework itself already provides a sub-class (`OptionalValidatorFactoryBean`) this is a little awkward as you have to know which class to sub-class or maybe sub-class both depending on circumstances.  A Spring Boot user has proposed [an enhancement](https://github.com/spring-projects/spring-boot/pull/29429) to make it easier to register `ValueExtractor`s with the `Configuration`. We'd like to do this via composition with some sort of `ConfigurationPostProcessor` or `ConfigurationCustomizer` callback. We could create our own `LocalValidatorFactoryBean` sub-class that enables this customization but that functionality would then be lost by anyone who's using `OptionalValidatorFactoryBean` instead.  We wondered if Framework could add a callback-based mechanism for post-processing the `Configuration` instead. We could then auto-configure the `LocalValidatorFactoryBean` with any post-processors/customizers found in the context and users could implement one to register their `ValueExtractor` without resorting to inheritance.","closed","type: enhancement,","wilkinsona","2022-01-19T17:19:03Z","2022-04-08T12:48:34Z"
"","27940","A Question about default tag parsing","**Affects:** 5.2.8  ```java package org.springframework.beans.factory.xml; 	@Nullable 	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { 		return parseBeanDefinitionElement(ele, null); 	} ```  This `BeanDefinition` parameter is always `null`, and it is impossible to find the case that this parameter is not empty, then whether this parameter is a meaningless judgment.","closed","for: stackoverflow,","mingwang01","2022-01-16T14:34:42Z","2022-01-17T10:41:43Z"
"","28441","Content type multipart/mixed not supported / 415 UNSUPPORTED_MEDIA_TYPE (after Spring + Spring Boot upgrade)","**Affects:** 5.2.4.RELEASE  I was previously using the following versions of Spring + Spring Boot:  ``` 5.0.16.RELEASE 2.0.5.RELEASE ```  And the following classes, which handled a multipart/mixed upload. This is all working fine using the Spring versions above:  StagingApi.java  ``` import io.swagger.annotations.*; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RequestParam; import javax.validation.Valid; import javax.validation.constraints.*; @javax.annotation.Generated(value = ""io.swagger.codegen.v3.generators.java.SpringCodegen"", date = ""2022-05-10T11:14:13.587+01:00[Europe/London]"") @Api(value = ""Staging"", description = ""API"") public interface StagingApi {      @ApiOperation(value = """", nickname = ""createOrReplaceBatch"", notes = """", tags={  })     @ApiResponses(value = {          @ApiResponse(code = 200, message = """"),         @ApiResponse(code = 400, message = """"),         @ApiResponse(code = 500, message = """") })     @RequestMapping(value = ""/batches/{batchId}"",         consumes = { ""multipart/mixed"" },         method = RequestMethod.PUT)     ResponseEntity createOrReplaceBatch(         @ApiParam(value = """" ,required=true) @RequestHeader(value=""X-TENANT-ID"", required=true) String X_TENANT_ID,         @Size(min=1) @ApiParam(value = """",required=true) @PathVariable(""batchId"") String batchId,         @ApiParam(value = """"  )  @Valid @RequestBody Object body); } ```  StagingApiExtension.java  ``` import java.io.IOException; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.stream.Stream;  import com.squareup.okhttp.MediaType; import com.squareup.okhttp.MultipartBuilder; import com.squareup.okhttp.Request; import com.squareup.okhttp.RequestBody; import com.squareup.okhttp.Response; import com.squareup.okhttp.internal.Util;  import okio.BufferedSink; import okio.Okio; import okio.Source;  public class StaginApiExtension {     // This method is used to build a RequestBody from the Stream param, then sends a HTTP request to the API (i.e. this code will call StagingController.java)   public void createOrReplaceBatch(final String tenantId, final String batchId, final Stream uploadData)     throws ApiException   {       final MultipartBuilder mpBuilder = new MultipartBuilder().type(MultipartBuilder.MIXED);       final Iterator uploadDataIterator = uploadData.iterator();       while (uploadDataIterator.hasNext()) {           final MultiPart fileToStage = uploadDataIterator.next();           mpBuilder.addFormDataPart(fileToStage.getName(),                                   null,                                   new StreamingBody(MediaType.parse(fileToStage.getContentType()),                                                       fileToStage::openInputStream)           );       }       final RequestBody requestBody = mpBuilder.build();       final String apiPath = getApiClient().getBasePath() + PUT_API_PATH + batchId;       final Map stagingHeaders = new HashMap<>();       stagingHeaders.put(TENANT_HEADER_NAME, tenantId);       final Request.Builder reqBuilder = new Request.Builder();       getApiClient().processHeaderParams(stagingHeaders, reqBuilder);       final Request request = reqBuilder           .url(apiPath)           .put(requestBody)           .build();       try {           final Response response = getApiClient().getHttpClient().newCall(request).execute();           if (!response.isSuccessful()) {               throw new ApiException(""Error uploading documents for tenant "" + tenantId + "" batch: "" + batchId,                                   response.code(),                                   null,                                   response.message());           }       } catch (IOException e) {           throw new ApiException(e);       }   } } ```  StagingController.java  ``` public ResponseEntity createOrReplaceBatch(     @ApiParam(value = ""Identifies the tenant making the request."", required = true)     @RequestHeader(value = ""X-TENANT-ID"", required = true) String X_TENANT_ID,     @Size(min = 1) @ApiParam(value = ""Identifies the batch."", required = true)     @PathVariable(""batchId"") String batchId,     Object body) {      final ServletFileUpload fileUpload = new ServletFileUpload();     final FileItemIterator fileItemIterator;     try {         fileItemIterator = fileUpload.getItemIterator(request);     } catch (final FileUploadException | IOException ex) {         LOGGER.error(""Error getting FileItemIterator"", ex);         throw new WebMvcHandledRuntimeException(HttpStatus.BAD_REQUEST, ex.getMessage());     }     try {         batchDao.saveFiles(new TenantId(X_TENANT_ID), new BatchId(batchId), fileItemIterator);         return new ResponseEntity<>(HttpStatus.OK);     } catch (final InvalidTenantIdException | InvalidBatchIdException | IncompleteBatchException | InvalidBatchException ex) {         throw new WebMvcHandledRuntimeException(HttpStatus.BAD_REQUEST, ex.getMessage());     } catch (final StagingException ex) {         throw new WebMvcHandledRuntimeException(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());     } } ```  Log of successfully handled request:  ``` [2022-05-10 11:12:14.861Z #bc7.042 DEBUG -            -   ] o.s.w.s.m.m.a.RequestMappingHandlerMapping: Looking up handler method for path /batches/test-batch [2022-05-10 11:12:14.861Z #bc7.042 DEBUG -            -   ] o.s.w.a.FixedContentNegotiationStrategy: Requested media types: [application/json, */*] [2022-05-10 11:12:14.861Z #bc7.042 DEBUG -            -   ] o.s.w.a.FixedContentNegotiationStrategy: Requested media types: [application/json, */*] [2022-05-10 11:12:14.862Z #bc7.042 DEBUG -            -   ] o.s.w.a.FixedContentNegotiationStrategy: Requested media types: [application/json, */*] [2022-05-10 11:12:14.863Z #bc7.042 DEBUG -            -   ] o.s.w.s.m.m.a.RequestMappingHandlerMapping: Returning handler method [public org.springframework.http.ResponseEntity com.acme.corp.staging.StagingController.createOrReplaceBatch(java.lang.String,java.lang.String,java.lang.Object)] [2022-05-10 11:12:14.863Z #bc7.042 DEBUG -            -   ] o.s.b.f.s.DefaultListableBeanFactory: Returning cached instance of singleton bean 'stagingController' [2022-05-10 11:12:14.866Z #bc7.042 DEBUG -            -   ] o.s.b.w.s.f.OrderedRequestContextFilter: Bound request context to thread: org.apache.catalina.connector.RequestFacade@37f2254a [2022-05-10 11:12:14.870Z #bc7.042 DEBUG -            -   ] o.s.w.s.DispatcherServlet: DispatcherServlet with name 'dispatcherServlet' processing PUT request for [/batches/test-batch] [2022-05-10 11:12:14.871Z #bc7.042 DEBUG -            -   ] o.s.w.s.m.m.a.RequestMappingHandlerMapping: Looking up handler method for path /batches/test-batch [2022-05-10 11:12:14.871Z #bc7.042 DEBUG -            -   ] o.s.w.a.FixedContentNegotiationStrategy: Requested media types: [application/json, */*] [2022-05-10 11:12:14.871Z #bc7.042 DEBUG -            -   ] o.s.w.a.FixedContentNegotiationStrategy: Requested media types: [application/json, */*] [2022-05-10 11:12:14.871Z #bc7.042 DEBUG -            -   ] o.s.w.a.FixedContentNegotiationStrategy: Requested media types: [application/json, */*] [2022-05-10 11:12:14.871Z #bc7.042 DEBUG -            -   ] o.s.w.s.m.m.a.RequestMappingHandlerMapping: Returning handler method [public org.springframework.http.ResponseEntity com.acme.corp.staging.StagingController.createOrReplaceBatch(java.lang.String,java.lang.String,java.lang.Object)] [2022-05-10 11:12:14.871Z #bc7.042 DEBUG -            -   ] o.s.b.f.s.DefaultListableBeanFactory: Returning cached instance of singleton bean 'stagingController' [2022-05-10 11:12:14.932Z #bc7.042 DEBUG -            10c9] o.s.w.a.FixedContentNegotiationStrategy: Requested media types: [application/json, */*] [2022-05-10 11:12:14.933Z #bc7.042 DEBUG -        -       ] o.s.w.s.DispatcherServlet: Null ModelAndView returned to DispatcherServlet with name 'dispatcherServlet': assuming HandlerAdapter completed request handling [2022-05-10 11:12:14.933Z #bc7.042 DEBUG -        -       ] o.s.w.s.DispatcherServlet: Successfully completed request ```  However, when I try to update the versions of Spring and Spring Boot to:  ``` 5.2.4.RELEASE 2.2.6.RELEASE ```  the same request fails with a 415 UNSUPPORTED_MEDIA_TYPE response.  Log of failed request:  ``` [2022-05-10 11:31:52.158Z #dc2.024 INFO  -            -   ] o.a.c.c.C..localhost.: Initializing Spring DispatcherServlet 'dispatcherServlet' [2022-05-10 11:31:52.158Z #dc2.024 INFO  -            -   ] o.s.w.s.DispatcherServlet: Initializing Servlet 'dispatcherServlet' [2022-05-10 11:31:52.158Z #dc2.024 DEBUG -            -   ] o.s.w.s.DispatcherServlet: Detected StandardServletMultipartResolver [2022-05-10 11:31:52.162Z #dc2.024 DEBUG -            -   ] o.s.w.s.DispatcherServlet: enableLoggingRequestDetails='false': request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data [2022-05-10 11:31:52.162Z #dc2.024 INFO  -            -   ] o.s.w.s.DispatcherServlet: Completed initialization in 4 ms [2022-05-10 11:31:52.165Z #dc2.024 DEBUG -            -   ] o.s.w.s.DispatcherServlet: PUT ""/batches/test-batch"", parameters={} [2022-05-10 11:31:52.192Z #dc2.024 DEBUG -            -   ] o.s.w.s.m.m.a.RequestMappingHandlerMapping: Mapped to com.acme.corp.staging.StagingController#createOrReplaceBatch(String, String, Object) [2022-05-10 11:31:52.202Z #dc2.024 DEBUG -            a17e] o.s.w.s.m.m.a.ServletInvocableHandlerMethod: Could not resolve parameter [2] in public org.springframework.http.ResponseEntity com.acme.corp.staging.StagingController.createOrReplaceBatch(java.lang.String,java.lang.String,java.lang.Object): Content type 'multipart/mixed;boundary=efb8369b-607b-4dcf-9f92-e6cd8244db1e;charset=UTF-8' not supported [2022-05-10 11:31:52.204Z #dc2.024 DEBUG -            a17e] o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver: Using @ExceptionHandler acme.corp.staging.exceptions.WebMvcExceptionHandler#handleException(Exception, WebRequest) [2022-05-10 11:31:52.206Z #dc2.024 DEBUG -            a17e] o.s.w.s.m.m.a.HttpEntityMethodProcessor: No match for [application/json, */*], supported: [] [2022-05-10 11:31:52.206Z #dc2.024 DEBUG -            a17e] o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver: Resolved [org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'multipart/mixed;boundary=efb8369b-607b-4dcf-9f92-e6cd8244db1e;charset=UTF-8' not supported] [2022-05-10 11:31:52.206Z #dc2.024 DEBUG -            a17e] o.s.w.s.DispatcherServlet: Completed 415 UNSUPPORTED_MEDIA_TYPE ```  Based on this StackOverflow post:  https://stackoverflow.com/questions/48051177/content-type-multipart-form-databoundary-charset-utf-8-not-supported  I tried to change:  ``` @Valid @RequestBody Object body ```  to:  ```  @Valid @ModelAttribute Object body ```  This seemed to work, but I think it caused a new problem due to the order of the parts in the request body not being the same as they were before. i.e I have code that will throw an Exception if the client sends a request where the parts of the body are not in a specific order, and with this change to from `RequestBody` to `ModelAttribute`, the code is no longer throwing an Exception, so I'm not sure how the request is coming in, but its not exactly the same as it was when using `RequestBody`.  I'm also not sure this is the right change here, since `RequestBody` was working fine using the Spring versions at the top of this post?  Any help is much appreciated!","closed","status: duplicate,","rorytorneymf","2022-05-10T18:09:49Z","2022-05-10T19:00:57Z"
"","28387","continued support for CallbackPreferringPlatformTransactionManager for spring-data-couchbase to implement @Transactional","**Affects:** 2.7  --- spring-data-couchbase would like to support @Transactional support. Couchbase's transaction management aligns with the CallbackPreferringPlatformTransactionManager.  There is currently support for CallbackPreferringPlatformManager in TransactionAspectSupport. invokeWithinTransaction() https://github.com/spring-projects/spring-framework/blob/5378572b00d5b9bc6978d117359b059412773288/spring-tx/src/main/java/org/springframework/transaction/interceptor/TransactionAspectSupport.java#L415 https://github.com/spring-projects/spring-framework/issues/13906 I understood from @mp911de that had been added solely for Websphere and may be discontinued, although it is not tagged as deprecated.  We are wondering if spring-data-couchbase can rely on it for support @Transactional. Thanks.","open","status: waiting-for-triage,","mikereiche","2022-04-26T22:53:03Z","2022-07-30T00:02:45Z"
"","27978","Ignore identical BeanDefinition registration when allowBeanDefinitionOverriding is false","**Affects:** 2.5.2 - 5.3, Spring Boot 2.1+  Calling `DefaultListableBeanFactory.registerBeanDefinition()` twice with the same bean name and same or equal `BeanDefinition` object results in an exception if `allowBeanDefinitionOverriding` was set to `false` (as is the default in Spring Boot 2.1+).  The javadoc for `DefaultListableBeanFactory.setAllowBeanDefinitionOverriding` specifically defines (emphasis is mine):  > Set whether it should be allowed to override bean definitions by registering **a different definition** with the same name, automatically replacing the former...  Practically, this makes splitting a monolith into modules and libraries a lot harder as it bans common bean definitions due to recursive imports, e.g.:  1. Module 1 uses db hence `@Import(DbConfig.class)`. 2. Module 2 uses db and also `@Import(DbConfig.class)`. 3. Service 3 uses both module 1 and 2 and fails to load because of the double import if `allowBeanDefinitionOverriding=false`.  Allowing for silent-ignore of identical definitions will ease transitions from ""one large context"" to smaller modules that can be self-descriptive in their dependencies.  This behavior was introduced in #9052.","open","type: enhancement,","bironran","2022-01-26T00:57:03Z","2022-03-15T15:00:23Z"
"","28827","Exception when trying to use HTTP/2 with two different Spring versions","**Affects:** 2.3.12.RELEASE  I'm sending the data from one service (the client) to another (the server) using HTTP/2. Both services use reactive stack. When both services use version `2.7.1` of Spring Boot (reactor-netty version `1.0.20`), everything works fine. But when I downgrade the client to the version `2.3.12.RELEASE` (reactor-netty version `0.9.20.RELEASE`) the code stops working, and exception is thrown:  ```java reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.UnsupportedOperationException: unsupported message type: DefaultFullHttpRequest (expected: ByteBuf, FileRegion) Caused by: java.lang.UnsupportedOperationException: unsupported message type: DefaultFullHttpRequest (expected: ByteBuf, FileRegion) ```  I created a [minimal reproducible example](https://github.com/karolkrasnowski/HTTP2) to demonstrate the issue. It's a multi-module Gradle project. One module represents the server, and another module represents the client. The [main](https://github.com/karolkrasnowski/HTTP2/tree/main) branch contains working example (both services with version `2.7.1`), and the [minimal-reproducible-example](https://github.com/karolkrasnowski/HTTP2/tree/minimal-reproducible-example) branch illustrates the problem.  Unfortunately, in the real project, the client service uses `2.3.12.RELEASE` version, and upgrade to the newest one is not that easy. Is there any way to make it work without the Spring Boot upgrade?","open","status: waiting-for-triage,","karolkrasnowski","2022-07-15T10:40:16Z","2022-07-15T10:43:05Z"
"","27965","Spring Webflux. Memory leak.","**Affects:** 2.3.1.RELEASE  ---  I found that spring webflux doesn't allow gc to collect a garbage. I simplified my code. There is simple pipeline:  ```kotlin @Configuration class RouterConfig(     val operationRepository: OperationRepository // r2dbc repository fun findOperationsRangeForCarrier(ids: Collection,start: LocalDateTime,end: LocalDateTime): Flux ) {     val csvMapper = CsvMapper().apply { findAndRegisterModules() }     val writer = csvMapper.writer(csvMapper.schemaFor(TPPOperation::class.java).withoutHeader())      val carrierIds = listOf(1)     val start = LocalDateTime.of(2021, 3, 10, 0, 0, 0)     val end = LocalDateTime.of(2021, 4, 10, 0, 0, 0)      @Bean     fun routing(): RouterFunction = router {         accept(MediaType.ALL).nest {             GET(""/test"") {                 operationRepository.findOperationsRangeForCarrier(carrierIds, start, end) // returns about 800_000 items                     .map { writer.writeValueAsBytes(it) }                     .reduce(ByteArrayOutputStream()) { output, el ->                         output.write(el)                         output                     }                     .map { output -> output.toByteArray() } // 229Mb                     .flatMap {                         ServerResponse.ok()                             .headers { httpHeaders ->                                 httpHeaders.contentType = MediaType(""application"", ""force-download"")                                 httpHeaders.set(HttpHeaders.CONTENT_DISPOSITION, ""attachment; filename=test.csv"")                             }                             .bodyValue(ByteArrayResource(it))                     }             }         }     } } ```  The result file is downloaded successfully and has a size about 229Mb. After several sequential requests I found that the memory wasn't released and in result I had OOM.  Heap dump showed that the result byte arrays are live objects and GC can't collect them because they have GC root `WindowsSelectorImpl`.   Interesting that if I modify my code: ``` @Bean fun routing(): RouterFunction = router { 	accept(MediaType.ALL).nest { 		GET(""/test"") { 			operationRepository.findOperationsRangeForCarrier(carrierIds, start, end) // returns about 800_000 items 				.map { writer.writeValueAsBytes(it) } 				.reduce(ByteArrayOutputStream()) { output, el -> 					output.write(el) 					output 				} 				.map { output -> output.toByteArray() } // 229Mb 				.subscribe() 			ServerResponse.ok().bodyValue(""OK"") 		} 		} 	} } ``` I see that file is creating. but after process of creating is finished, heap dump doesn't contain resulted bytearray. I conclude that the main reason for the leak is spring webflux and not project reactor.  Maybe something must be configured differently","closed","for: external-project,","typik89","2022-01-21T10:19:48Z","2022-02-07T16:38:45Z"
"","27995","Reflective method invocation does not detect interface method when interface is declared in a subclass (e.g. HashMap.HashIterator.hasNext)","**Affects:**  5.3.14, 6.0.0-M2  If you use spring expression to access a public interface method, it instead accesses the method on the implementation class. If that class is not public, the access will fail.  Example: the standard Java collections have `Iterator` implementations which are private inner classes:  ```java package test;  import java.util.HashMap;  import org.springframework.expression.spel.standard.SpelExpressionParser;  public class SpelTest {  	public static void main(String[] args) {  		var map = new HashMap(); 		map.put(""key"", ""value""); 		var iter = map.entrySet().iterator(); 		final Object output = new SpelExpressionParser().parseExpression(""hasNext()"").getValue(iter); 		System.out.println(""output is "" + output);  	}  } ```  Under Java 11 and Spring Framework 5.3.14, the above will succeed with a warning:  ``` WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.springframework.util.ReflectionUtils (file:/Users/iay/.m2/repository/org/springframework/spring-core/5.3.14/spring-core-5.3.14.jar) to method java.util.HashMap$HashIterator.hasNext() WARNING: Please consider reporting this to the maintainers of org.springframework.util.ReflectionUtils WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release output is true ```  Under Java 17 and either Spring Framework 5.3.14 or 6.0.0-M2, the above will fail:  ``` Exception in thread ""main"" org.springframework.expression.spel.SpelEvaluationException: EL1029E: A problem occurred when trying to execute method 'hasNext' on object of type 'java.util.HashMap$EntryIterator': 'Problem invoking method: public final boolean java.util.HashMap$HashIterator.hasNext()' ```  It's worth noting that the equivalent problem for _property_ accesses was described in issue #22242 and fixed in commit dec6d698192df28e6640d8de2c2745f7dd0c146d for 5.1.18 back in 2019. This issue relates to _methods_ instead but it seems like the same approach should be possible.","closed","in: core,","iay","2022-02-02T14:39:29Z","2022-02-04T22:30:40Z"
"","28184","JPATransactionManager and HibernateJpaDialect is not handling gracefully a org.hibernate.TransactionException","**Affects:**  Spring Orm: 5.3.14 Spring boot version: 2.6.2 Spring data jpa: 2.6.0 Spring Integration version: 5.5.6  **Issue:** Seems like  `JPATransactionManager` and `HibernateJpaDialect` cannot transform a `org.hibernate.TransactionException` to the right JPA exception based on the internal `SQLException`, as you can see in the following stacktrace:  ``` Caused by: org.springframework.dao.CannotAcquireLockException: Failed to lock mutex at 19414b49-c76b-3b77-a05d-3aca07a855aa; nested exception is org.springframework.orm.jpa.JpaSystemException: Unable to commit against JDBC Connection; nested exception is org.hibernate.TransactionException: Unable to commit against JDBC Connection 	at org.springframework.integration.jdbc.lock.JdbcLockRegistry$JdbcLock.rethrowAsLockException(JdbcLockRegistry.java:197) 	at org.springframework.integration.jdbc.lock.JdbcLockRegistry$JdbcLock.tryLock(JdbcLockRegistry.java:262) 	at com.geniussports.geniuslive.ingressmanager.domain.pipeline.ingress.IngressPipelineService.create(IngressPipelineService.kt:35) 	at com.geniussports.geniuslive.ingressmanager.application.adapters.pipeline.ingress.gateway.graphql.PipelineMutationResolver.createFromJSON(PipelineMutationResolver.kt:51) 	at jdk.internal.reflect.GeneratedMethodAccessor254.invoke(Unknown Source) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:568) 	at org.springframework.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:282) 	at com.netflix.graphql.dgs.internal.DgsSchemaProvider.invokeDataFetcher(DgsSchemaProvider.kt:402) 	at com.netflix.graphql.dgs.internal.DgsSchemaProvider.access$invokeDataFetcher(DgsSchemaProvider.kt:64) 	at com.netflix.graphql.dgs.internal.DgsSchemaProvider$createBasicDataFetcher$1.get(DgsSchemaProvider.kt:279) 	at com.netflix.graphql.dgs.metrics.micrometer.DgsGraphQLMetricsInstrumentation$instrumentDataFetcher$1.get(DgsGraphQLMetricsInstrumentation.kt:101) 	at graphql.execution.instrumentation.dataloader.DataLoaderDispatcherInstrumentation.lambda$instrumentDataFetcher$0(DataLoaderDispatcherInstrumentation.java:86) 	at graphql.execution.ExecutionStrategy.fetchField(ExecutionStrategy.java:270) 	... 76 more Caused by: org.springframework.orm.jpa.JpaSystemException: Unable to commit against JDBC Connection; nested exception is org.hibernate.TransactionException: Unable to commit against JDBC Connection 	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:331) 	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:233) 	at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:566) 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:743) 	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:711) 	at org.springframework.cloud.sleuth.instrument.tx.TracePlatformTransactionManager.commit(TracePlatformTransactionManager.java:121) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:654) 	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:407) 	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119) 	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) 	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:753) 	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:698) 	at org.springframework.integration.jdbc.lock.DefaultLockRepository$$EnhancerBySpringCGLIB$$29ab5ce4.acquire() 	at org.springframework.integration.jdbc.lock.JdbcLockRegistry$JdbcLock.doLock(JdbcLockRegistry.java:268) 	at org.springframework.integration.jdbc.lock.JdbcLockRegistry$JdbcLock.tryLock(JdbcLockRegistry.java:249) 	... 88 more Caused by: org.hibernate.TransactionException: Unable to commit against JDBC Connection 			3 lines skipped for [org.hibernate] 	at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:562) 	... 100 more Caused by: org.postgresql.util.PSQLException: ERROR: could not serialize access due to read/write dependencies among transactions   Detail: Reason code: Canceled on identification as a pivot, during commit attempt.   Hint: The transaction might succeed if retried. 	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2674) 	at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2364) 	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:354) 	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:314) 	at org.postgresql.jdbc.PgConnection.executeTransactionCommand(PgConnection.java:853) 	at org.postgresql.jdbc.PgConnection.commit(PgConnection.java:875) 	at com.zaxxer.hikari.pool.ProxyConnection.commit(ProxyConnection.java:387) 	at com.zaxxer.hikari.pool.HikariProxyConnection.commit(HikariProxyConnection.java) 			1 line skipped for [org.hibernate] ```  The transformation process should arrive to a `CannotAcquireLockException`, [here](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-orm/src/main/java/org/springframework/orm/jpa/vendor/HibernateJpaDialect.java#L267), as the error is database serialization related.  I was searching for a way to extend the transform behavior on [this line](https://github.com/spring-projects/spring-framework/blob/5.3.x/spring-orm/src/main/java/org/springframework/orm/jpa/vendor/HibernateJpaDialect.java#L245), but, cannot find a way to customize this transformation on the `HibernateJpaDialect` for that `org.hibernate.TransactionException`.  Note that I created an issue on [Spring Integration](https://github.com/spring-projects/spring-integration/issues/3733) and [Hibernate](https://hibernate.atlassian.net/browse/HHH-15096), as I think Hibernate is the one who is not throwing the right context exception, however, I would like to be able to customize the behavior somehow in the Spring side.","open","in: data,","estigma88","2022-03-15T15:24:42Z","2022-04-25T09:45:22Z"
"","28389","Kotlinx.serialization not used for serializing Page and ignores all configuration","**Affects:**  3.0.0-M1 --- When  returning object from a controller method using `@ResponseBody`, and if the returned type is `Page` where T is a class marked as `@kotlinx.serialization.Serializable`, kotlinx.serialization is not used, it is unclear what exactly is used, and, assuming it's Jackson that is used, all configuration, all annotations and other properties are ignored.  I'm using custom InstantSerializer that serializes dates as strings for Kotlinx.serialization.   My POJO is annotated as follows   ```kotlin @file:UseSerializers(InstantSerializer::class, UUIDSerializer::class)  @kotlinx.serialization.Serializable data class GetProductResponse(     /* ... */     @JsonSerialize(using = JacksonInstantSerializer::class)     @JsonFormat(shape = JsonFormat.Shape.STRING)     val createdAt: Instant,     val id: UUID, ) ```  Returning List or  of this pojo returns string for createdAt field: `""createdAt"": ""2022-03-29T20:19:30.304149Z""` However, returning Page the field is : `""createdAt"": 1650109008.203314000`. This breaks FE and introduces inconsistency.   I must note that I specifically would like to use strings to serialize dates.  I tried to work around this issue by providing custom Jackson configuration:     * Using code:  ```kotlin   @Bean   fun jacksonObjectMapper(): ObjectMapper = ObjectMapper().apply {       registerModule(JavaTimeModule())       disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);   } ``` * Using application.properties:    ```kotlin spring.mvc.converters.preferred-json-mapper=kotlinx.serialization spring.jackson.serialization.write_dates_as_timestamps=false ``` * Using annotations:   ```kotlin  @JsonSerialize(using = JacksonInstantSerializer::class)     @JsonFormat(shape = JsonFormat.Shape.STRING)     val createdAt: Instant, ```  None of the above methods worked, and I'm unable to achieve the desired behavior.  My Controller method is as follows: ```kotlin @GetMapping(""/"")     fun getAll(pageable: Pageable, @RequestBody request: GetProductsFilteredRequest?): Page {         return productRepository.findFiltered(             pageable,            /* ... */         ).map { it.toResponse() }     } ```  Condition evaluations report is as follows: ```plaintext    JacksonAutoConfiguration.JacksonObjectMapperConfiguration#jacksonObjectMapper:       Did not match:          - @ConditionalOnMissingBean (types: com.fasterxml.jackson.databind.ObjectMapper; SearchStrategy: all) found beans of type 'com.fasterxml.jackson.databind.ObjectMapper' jacksonObjectMapper (OnBeanCondition)     JacksonHttpMessageConvertersConfiguration.MappingJackson2HttpMessageConverterConfiguration:       Did not match:          - @ConditionalOnProperty (spring.mvc.converters.preferred-json-mapper=jackson) found different value in property 'spring.mvc.converters.preferred-json-mapper' (OnPropertyCondition)       Matched:          - @ConditionalOnClass found required class 'com.fasterxml.jackson.databind.ObjectMapper' (OnClassCondition)     JacksonHttpMessageConvertersConfiguration.MappingJackson2XmlHttpMessageConverterConfiguration:       Did not match:          - @ConditionalOnClass did not find required class 'com.fasterxml.jackson.dataformat.xml.XmlMapper' (OnClassCondition) ```  UPDATE: Registering kotlin module for ObjectMapper:    ```kotlin @Bean     fun jacksonObjectMapper(): ObjectMapper = ObjectMapper().apply {         registerModule(JavaTimeModule())         registerKotlinModule()         disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)     } ``` Allows to apply a workaround by using Jackson configuration alongside kotlinx.serialization configuration (only for annotation, other properties are still ignored)  **The bug is still valid because kotlinx.serialization is not used for Page content.**","open","in: kotlin,","Nek-12","2022-04-27T08:47:52Z","2022-04-28T13:54:50Z"
"","28247","org.springframework.security.saml2.provider.service.authentication.DefaultSaml2AuthenticatedPrincipal fails to return more than one ""attribute""","**Affects:  5.5.2  \spring-security-saml2-service-provider or    --- I have been testing a SAML SSO integration using Spring framework.   I attach a saml token produced by Keycloak IDP in that testing.   The code to setup the ""authorities"" transmitted in the token use the getAttribute method with a str parm of ""Role"". While there are several attributes with that attribute name, the method consistently produces only a single one of these in the return List object.  It always is the last one physically in the list.  I've tested this carefully, and the behavior is consistent.   Same behavior with the getAttributes method (no parameter) although the returned object is a Map in this case. [SAMLTOKEN.xml.txt](https://github.com/spring-projects/spring-framework/files/8372467/SAMLTOKEN.xml.txt)  All these attributes should be returned from both methods.","closed","for: external-project,","wcpetty99","2022-03-29T15:03:53Z","2022-03-29T15:06:40Z"
"","28155","Request body deserialization failures are not captured by exception handlers in WebFlux","**Affects** versions from 5.3.15 to 6.0.0-20220310.112646-346. I have only tested it with these two versions, but I suspect the problem to exist in all 5.x versions.  ---  When a `@RequestBody`-annotated argument fails to get resolved due to the an exception thrown in the constructor of the argument class, `@ExceptionHandler`s in `@RestControllerAdvice`s are not taken into account in WebFlux, whereas it works as expected in WebMVC.  Below, `CustomWebFluxTest.test()` fails, whereas `CustomWebMvcTest.test()` succeeds.  ```java import com.fasterxml.jackson.annotation.JsonCreator; import org.junit.jupiter.api.Nested; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; import org.springframework.http.*; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.web.reactive.server.WebTestClient; import org.springframework.web.bind.annotation.*; import org.springframework.web.reactive.function.BodyInserters;  import java.util.Collections;  import static org.assertj.core.api.Assertions.assertThat;  public class CtorFailureTest {      @Nested     @SpringBootTest(             webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,             properties = {""spring.main.web-application-type=reactive""},             classes = {CustomConfiguration.class})     @ContextConfiguration(classes = CustomConfiguration.class)     class CustomWebFluxTest {          @Autowired         WebTestClient webTestClient;          @Test         void test() {             webTestClient                     .post()                     .uri(""/custom"")                     .contentType(MediaType.APPLICATION_JSON)                     .body(BodyInserters.fromValue(""{}""))                     .exchange()                     .expectStatus()                     .isEqualTo(HttpStatus.UNPROCESSABLE_ENTITY);         }      }      @Nested     @SpringBootTest(             webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,             classes = {CustomConfiguration.class})     class CustomWebMvcTest {          @Autowired         private TestRestTemplate restTemplate;          @Test         void test() {             HttpHeaders requestHeaders = new HttpHeaders();             requestHeaders.put(HttpHeaders.CONTENT_TYPE, Collections.singletonList(MediaType.APPLICATION_JSON_VALUE));             HttpEntity requestEntity = new HttpEntity<>(""{}"", requestHeaders);             ResponseEntity responseEntity = restTemplate.exchange(""/custom"", HttpMethod.POST, requestEntity, Void.class);             assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.UNPROCESSABLE_ENTITY);         }      }      @Configuration     @EnableAutoConfiguration     @Import({CustomController.class, CustomAdvice.class})     static class CustomConfiguration {}      static final class CustomException extends RuntimeException {}      static final class CustomModel {          @JsonCreator         public CustomModel() {             throw new CustomException();         }      }      @RestController     static class CustomController {          @PostMapping(                 path = ""/custom"",                 consumes = {MediaType.APPLICATION_JSON_VALUE},                 produces = {MediaType.APPLICATION_JSON_VALUE})         @ResponseStatus(HttpStatus.ACCEPTED)         void customResource(@RequestBody CustomModel ignored) {}      }      @RestControllerAdvice     static class CustomAdvice {          @ExceptionHandler         @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)         public void customHandler(CustomException ignored) {}      }  } ```","closed","type: bug,","vy","2022-03-10T14:24:06Z","2022-04-28T10:41:00Z"
"","28172","Memory leak in spring-jms","**Affected versions:** 5.3.10, 5.3.16.  We believe it's in older versions as well.  We are using a `spring-integration:inbound-gateway` with the limitation of number concurrent consumers (for example 4). That's causing 4 threads to be created.  Our application uses Artemis as the JMS server, but it will happen with all types of JMS brokers.  When the application is disconnected from the Artemis server (for example, when restarting the Artemis), the living threads remain, and when the connection is restored, a new set of 4 threads is created.  Over time, the application runs out of memory.   By debugging the `org.springframework.jms.listener.DefaultMessageListenerContainer`, especially the inner `AsyncMessageListenerInvoker`, when an exception is thrown the living threads are not cleared properly.","open","in: messaging,","alexschwarzman","2022-03-12T08:28:29Z","2022-03-12T13:19:18Z"
"","28076","BeanDefinitionParserDelegate.getEnvironment causes NoSuchMethodError","**[Chris Beams](https://jira.spring.io/secure/ViewProfile.jspa?name=cbeams)** commented  Worked around this issue prior to the M1 release with the following:  > commit 1a751de04fe4bc5691a31fb25254ac6064d334b0 > Author: Chris Beams  > Date:   Thu Feb 10 00:30:30 2011 +0000 >      >     Further compensations for STS; binary compat fixes >      >     Defensively catch NoSuchMethodError when calling BDPD.getEnvironment() >     and supply a DefaultEnvironment if not available. >      >     Replace the single-arg constructor for BDPD and deprecate, preserving >     binary compat particularly for Spring Integration who instantiates >     this class directly, which is unusual. >      >     git-svn-id: https://src.springframework.org/svn/spring-framework/trunk@3982 50f2f4bb-b051-0410-bef5-90022cba6387 >  > ``` > diff --git org.springframework.beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionParserDelegate.java org.springframework.beans/src/main/java/org/springframe > index 7236aa6..8cdd39f 100644 > --- org.springframework.beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionParserDelegate.java > +++ org.springframework.beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionParserDelegate.java > @@ -27,6 +27,7 @@ import java.util.Set; >   >  import org.apache.commons.logging.Log; >  import org.apache.commons.logging.LogFactory; > + >  import org.w3c.dom.Element; >  import org.w3c.dom.NamedNodeMap; >  import org.w3c.dom.Node; > @@ -58,6 +59,7 @@ import org.springframework.beans.factory.support.ManagedProperties; >  import org.springframework.beans.factory.support.ManagedSet; >  import org.springframework.beans.factory.support.MethodOverrides; >  import org.springframework.beans.factory.support.ReplaceOverride; > +import org.springframework.core.env.DefaultEnvironment; >  import org.springframework.core.env.Environment; >  import org.springframework.util.Assert; >  import org.springframework.util.ClassUtils; > @@ -266,6 +268,17 @@ public class BeanDefinitionParserDelegate { >         } >   >         /** > +        * Create a new BeanDefinitionParserDelegate associated with the > +        * supplied {@link XmlReaderContext} and a new {@link DefaultEnvironment}. > +        * @deprecated since Spring 3.1 in favor of > +        * {@link #BeanDefinitionParserDelegate(XmlReaderContext, Environment)} > +        */ > +       @Deprecated > +       public BeanDefinitionParserDelegate(XmlReaderContext readerContext) { > +               this(readerContext, new DefaultEnvironment()); > +       } > + > +       /** >          * Get the {@link XmlReaderContext} associated with this helper instance. >          */ >         public final XmlReaderContext getReaderContext() { > diff --git org.springframework.context/src/main/java/org/springframework/context/config/AbstractSpecificationBeanDefinitionParser.java org.springframework.context/src/main/java/o > index 61756a9..58472b5 100644 > --- org.springframework.context/src/main/java/org/springframework/context/config/AbstractSpecificationBeanDefinitionParser.java > +++ org.springframework.context/src/main/java/org/springframework/context/config/AbstractSpecificationBeanDefinitionParser.java > @@ -24,6 +24,7 @@ import org.springframework.beans.factory.parsing.ProblemReporter; >  import org.springframework.beans.factory.parsing.ReaderContext; >  import org.springframework.beans.factory.xml.BeanDefinitionParser; >  import org.springframework.beans.factory.xml.ParserContext; > +import org.springframework.core.env.DefaultEnvironment; >  import org.w3c.dom.Element; >   >  /** > @@ -54,11 +55,19 @@ public abstract class AbstractSpecificationBeanDefinitionParser implements BeanD >                 specContext.setRegistry(parserContext.getRegistry()); >                 specContext.setRegistrar(new ComponentRegistrarAdapter(parserContext)); >                 specContext.setResourceLoader(parserContext.getReaderContext().getResourceLoader()); > -               specContext.setEnvironment(parserContext.getDelegate().getEnvironment()); > +               try { > +                       // again, STS constraints around the addition of the new getEnvironment() > +                       // method in 3.1.0 (it's not present in STS current spring version, 3.0.5) > +                       // TODO 3.1 GA: remove this block prior to 3.1 GA > +                       specContext.setEnvironment(parserContext.getDelegate().getEnvironment()); > +               } catch (NoSuchMethodError ex) { > +                       specContext.setEnvironment(new DefaultEnvironment()); > +               } >                 try { >                         // access the reader context's problem reporter reflectively in order to >                         // compensate for tooling (STS) constraints around introduction of changes >                         // to parser context / reader context classes. > +                       // TODO 3.1 GA: remove this block prior to 3.1 GA >                         Field field = ReaderContext.class.getDeclaredField(""problemReporter""); >                         field.setAccessible(true); >                         ProblemReporter problemReporter = (ProblemReporter)field.get(parserContext.getReaderContext()); > ```  _Originally posted by @spring-projects-issues in https://github.com/spring-projects/spring-framework/issues/12706#issuecomment-453357685_","closed","in: core,","prakashbxr85","2022-02-19T00:26:25Z","2022-03-05T08:01:10Z"
"","28852","added missing @Nullable annotations to methods that may return null and are overridden by methods already using @Nullable","**1/4 Added `@Nullable` to return type of  `org.springframework.asm.AnnotationVisitor::visitAnnotation`**  _Reasons:_  1. On inspection, the method may return null 2. The method is overridden by methods with nullable annotation (violating LSP indicating that return types should not be generalised in overridden methods, assuming that most static null checkers will use the nonull-by-default assumption):  - org.springframework.core.type.classreading.MergedAnnotationReadingVisitor::visitAnnotation - org.springframework.core.type.classreading.MergedAnnotationReadingVisitor$ArrayVisitor::visitAnnotation   **2/4 Added `@Nullable` to return type of  `org.springframework.asm.ClassVisitor::visitMethod`**  _Reasons:_  1. On inspection, the method may return null 2. The method is overridden by methods with nullable annotation (violating LSP indicating that return types should not be generalised in overridden methods, assuming that most static null checkers will use the nonull-by-default assumption):  - org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor::visitMethod - org.springframework.core.LocalVariableTableParameterNameDiscoverer$ParameterNameDiscoveringVisitor::visitMethod  **3/4 Added `@Nullable` to return type of  `org.springframework.asm.ClassVisitor::visitAnnotation`**  _Reasons:_  1. On inspection, the method may return null 2. The method is overridden by methods with nullable annotation (violating LSP indicating that return types should not be generalised in overridden methods, assuming that most static null checkers will use the nonull-by-default assumption):  - org.springframework.core.type.classreading.SimpleAnnotationMetadataReadingVisitor::visitAnnotation  **4/4 Added `@Nullable` to return type of  `org.springframework.asm.MethodVisitor::visitAnnotation`**  _Reasons:_  1. On inspection, the method may return null 2. The method is overridden by methods with nullable annotation (violating LSP indicating that return types should not be generalised in overridden methods, assuming that most static null checkers will use the nonull-by-default assumption):  - org.springframework.core.type.classreading.SimpleMethodMetadataReadingVisitor::visitAnnotation   Note that there are similar methods in those classes that could also be annotated as `@Nullable` based on code inspection. This PR is conservative as it only adds `@Nullable` to methods where there are multiple reasons. If this gets accepted, I can create a separate PR for those.","closed","status: declined,","jensdietrich","2022-07-21T21:57:14Z","2022-07-23T08:24:36Z"
"","28499","The url attribute of PutExchange and DeleteExchange does not match the url type in HttpExchange","* Spring 6.0.0-M4 * Java 17 * Example Codes to reproduce: https://github.com/hantsy/spring6-sandbox/tree/master/declarative-http-client  The client example is like this.  ```java  @HttpExchange(url = ""/posts"", accept = ""application/json"", contentType = ""application/json"") public interface PostClient {     @GetExchange("""")     Flux allPosts();      @GetExchange(""/{id}"")     Mono getById(@PathVariable(""id"") UUID id);      @PostExchange("""")     Mono> save(@RequestBody Post post);      @PutExchange(""/{id}"")     Mono> update(@PathVariable UUID id, @RequestBody Post post);      //@DeleteExchange(""/{id}"")     Mono> delete(@PathVariable UUID id);  } ```  When I tried to run my tests, got the exceptions like this.  ```bash  Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.example.demo.PostClient]: Factory method 'postClient' threw exception; nested exception is o rg.springframework.core.annotation.AnnotationConfigurationException: Misconfigured aliases: attribute 'url' in annotation [org.springframework.web.service.annotation.PutExchange] and a ttribute 'url' in annotation [org.springframework.web.service.annotation.HttpExchange] must declare the same return type. ```  In the `HttpExchange`, the `url` is a String.  ```java public @interface HttpExchange {  	/** 	 * This is an alias for {@link #url}. 	 */ 	@AliasFor(""url"") 	String value() default """";  	/** 	 * The URL for the request, either a full URL or a path only that is relative 	 * to a URL declared in a type-level {@code @HttpExchange}, and/or a globally 	 * configured base URL. 	 * By default, this is empty. 	 */ 	@AliasFor(""value"") 	String url() default """"; ```  But in the `PutExchange`, it becomes `String[]`.  ```java public @interface PutExchange {  	/** 	 * Alias for {@link HttpExchange#value}. 	 */ 	@AliasFor(annotation = HttpExchange.class) 	String[] value() default {};  	/** 	 * Alias for {@link HttpExchange#url()}. 	 */ 	@AliasFor(annotation = HttpExchange.class) 	String[] url() default {};  ```","closed","in: web,","hantsy","2022-05-22T09:28:56Z","2022-05-22T09:45:01Z"
"","28845","NPE when a bean has generic inline-class as a public property","* Kotlin 1.7.0 * Spring Boot 2.7.1  I have a service with a public property, `myMap`, typed as an inline class, which has a generic parameter.  ```kotlin @Service class ValueClassService {     val myMap = MyValueClass(emptyMap()) }  @JvmInline value class MyValueClass(     val map: Map ) : Map by map ```  However, I get an NPE when Spring starts up.  ```none Failed to load ApplicationContext java.lang.IllegalStateException: Failed to load ApplicationContext 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) 	... Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '...ValueClassService' defined in file [.../build/classes/kotlin/test/.../ValueClassService.class]: Initialization of bean failed; nested exception is java.lang.NullPointerException 	at app//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:628) 	... Caused by: java.lang.NullPointerException 	at java.desktop/com.sun.beans.TypeResolver.resolve(TypeResolver.java:203) ```    #### Workarounds:  1. make the `val myMap` private 2. make `value class MyValueClass` non-generic  #### Test reproducer  ```kotlin import org.junit.jupiter.api.Test import org.springframework.beans.factory.annotation.Autowired import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT import org.springframework.stereotype.Service  @SpringBootTest(     classes = [Application::class],     webEnvironment = RANDOM_PORT ) internal class ApplicationTest {      @Autowired     lateinit var valueClassService: ValueClassService      @Test     fun `test value class`() {         println(valueClassService.myMap)     } } ```  #### `Application.kt`  ```kotlin import org.springframework.boot.autoconfigure.AutoConfigurationExcludeFilter import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.context.TypeExcludeFilter import org.springframework.boot.context.properties.ConfigurationPropertiesScan import org.springframework.boot.context.properties.EnableConfigurationProperties import org.springframework.boot.runApplication import org.springframework.context.annotation.ComponentScan import org.springframework.context.annotation.ComponentScan.Filter import org.springframework.context.annotation.FilterType.CUSTOM import org.springframework.context.annotation.FullyQualifiedAnnotationBeanNameGenerator  @SpringBootApplication @ComponentScan(     basePackages = [""my.package""],     excludeFilters = [         Filter(type = CUSTOM, classes = [TypeExcludeFilter::class]),         Filter(type = CUSTOM, classes = [AutoConfigurationExcludeFilter::class])     ],     nameGenerator = FullyQualifiedAnnotationBeanNameGenerator::class ) @EnableConfigurationProperties @ConfigurationPropertiesScan(basePackages = [""my.package""]) class Application ```  #### Stacktrace  ```none Failed to load ApplicationContext java.lang.IllegalStateException: Failed to load ApplicationContext 	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) 	at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:118) 	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83) 	at org.springframework.boot.test.autoconfigure.SpringBootDependencyInjectionTestExecutionListener.prepareTestInstance(SpringBootDependencyInjectionTestExecutionListener.java:43) 	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:248) 	at org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:138) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$8(ClassBasedTestDescriptor.java:363) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.executeAndMaskThrowable(ClassBasedTestDescriptor.java:368) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$9(ClassBasedTestDescriptor.java:363) 	at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) 	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177) 	at java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1655) 	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484) 	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) 	at java.base/java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:312) 	at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:735) 	at java.base/java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:734) 	at java.base/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:658) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestInstancePostProcessors(ClassBasedTestDescriptor.java:362) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$instantiateAndPostProcessTestInstance$6(ClassBasedTestDescriptor.java:283) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:282) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$4(ClassBasedTestDescriptor.java:272) 	at java.base/java.util.Optional.orElseGet(Optional.java:369) 	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$5(ClassBasedTestDescriptor.java:271) 	at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:31) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:102) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:101) 	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:66) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$2(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:123) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:90) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:41) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$6(NodeTestTask.java:155) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:141) 	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:137) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$9(NodeTestTask.java:139) 	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:138) 	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:95) 	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:35) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) 	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:107) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:88) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.lambda$execute$0(EngineExecutionOrchestrator.java:54) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.withInterceptedStreams(EngineExecutionOrchestrator.java:67) 	at org.junit.platform.launcher.core.EngineExecutionOrchestrator.execute(EngineExecutionOrchestrator.java:52) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:114) 	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:86) 	at org.junit.platform.launcher.core.DefaultLauncherSession$DelegatingLauncher.execute(DefaultLauncherSession.java:86) 	at org.junit.platform.launcher.core.SessionPerRequestLauncher.execute(SessionPerRequestLauncher.java:53) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:99) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$000(JUnitPlatformTestClassProcessor.java:79) 	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:75) 	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 	at java.base/java.lang.reflect.Method.invoke(Method.java:566) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:36) 	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24) 	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:33) 	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:94) 	at com.sun.proxy.$Proxy5.stop(Unknown Source) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker$3.run(TestWorker.java:193) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.executeAndMaintainThreadName(TestWorker.java:129) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:100) 	at org.gradle.api.internal.tasks.testing.worker.TestWorker.execute(TestWorker.java:60) 	at org.gradle.process.internal.worker.child.ActionExecutionWorker.execute(ActionExecutionWorker.java:56) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:133) 	at org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker.call(SystemApplicationClassLoaderWorker.java:71) 	at worker.org.gradle.process.internal.worker.GradleWorkerMain.run(GradleWorkerMain.java:69) 	at worker.org.gradle.process.internal.worker.GradleWorkerMain.main(GradleWorkerMain.java:74) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name '...ValueClassService' defined in file [.../build/classes/kotlin/test/.../ValueClassService.class]: Initialization of bean failed; nested exception is java.lang.NullPointerException 	at app//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:628) 	at app//org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:542) 	at app//org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:335) 	at app//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) 	at app//org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:333) 	at app//org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208) 	at app//org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:955) 	at app//org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918) 	at app//org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583) 	at app//org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147) 	at app//org.springframework.boot.SpringApplication.refresh(SpringApplication.java:734) 	at app//org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:408) 	at app//org.springframework.boot.SpringApplication.run(SpringApplication.java:308) 	at app//org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:132) 	at app//org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:99) 	at app//org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) 	... 88 more Caused by: java.lang.NullPointerException 	at java.desktop/com.sun.beans.TypeResolver.resolve(TypeResolver.java:203) 	at java.desktop/com.sun.beans.TypeResolver.resolve(TypeResolver.java:218) 	at java.desktop/com.sun.beans.TypeResolver.resolve(TypeResolver.java:169) 	at java.desktop/com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:81) 	at java.desktop/com.sun.beans.introspect.MethodInfo.resolve(MethodInfo.java:63) 	at java.desktop/com.sun.beans.introspect.MethodInfo.(MethodInfo.java:50) 	at java.desktop/com.sun.beans.introspect.PropertyInfo.add(PropertyInfo.java:245) 	at java.desktop/com.sun.beans.introspect.PropertyInfo.get(PropertyInfo.java:285) 	at java.desktop/com.sun.beans.introspect.ClassInfo.getProperties(ClassInfo.java:82) 	at java.desktop/java.beans.Introspector.getTargetPropertyInfo(Introspector.java:516) 	at java.desktop/java.beans.Introspector.getBeanInfo(Introspector.java:464) 	at java.desktop/java.beans.Introspector.getBeanInfo(Introspector.java:295) 	at java.desktop/java.beans.Introspector.getBeanInfo(Introspector.java:237) 	at org.springframework.beans.CachedIntrospectionResults.getBeanInfo(CachedIntrospectionResults.java:254) 	at org.springframework.beans.CachedIntrospectionResults.(CachedIntrospectionResults.java:279) 	at org.springframework.beans.CachedIntrospectionResults.forClass(CachedIntrospectionResults.java:183) 	at org.springframework.beans.BeanWrapperImpl.getCachedIntrospectionResults(BeanWrapperImpl.java:174) 	at org.springframework.beans.BeanWrapperImpl.getPropertyDescriptors(BeanWrapperImpl.java:248) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.filterPropertyDescriptorsForDependencyCheck(AbstractAutowireCapableBeanFactory.java:1594) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.filterPropertyDescriptorsForDependencyCheck(AbstractAutowireCapableBeanFactory.java:1574) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1434) 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:619) 	... 103 more ```","open","in: kotlin,","aSemy","2022-07-20T10:22:10Z","2022-07-27T14:13:53Z"
"","28059","Upgrade client support to R2DBC 0.9","* `DatabaseClient.map(…)` now a mapping `Function` for `Readable` to consume tabular and stored procedure results (via `OutParameters`). Also, `DatabaseClient.flatMap(…)` allows consuming individual segments from a response (update counts, database messages, rows, out parameters). * `R2dbcTransactionManager` now supports extensible transaction definitions to provide all transaction attributes upon transaction start * We use consistently R2DBC's `Parameters` instead of our own `Parameter` type. Our own `Parameter` is deprecated now. * Switch to `Long` for update operations in preparation for R2DBC 1.0","closed","type: dependency-upgrade,","mp911de","2022-02-16T08:39:58Z","2022-03-16T18:29:51Z"
"","28552","Deprecate trailing slash match and change default value from true to false","> Whether to match to URLs irrespective of the presence of a trailing slash. If enabled a method mapped to `""/users""` also matches to `""/users/""`. > The default value is `true`.  Even though this behavior has been long present in Spring, it introduces ambiguity that can (combined with some other choices) easily have consequences in shape of security vulnerabilities. Consider this example:  ```java @SpringBootApplication @RestController public class SampleApplication {      public static void main(String[] args) {         SpringApplication.run(SampleApplication.class, args);     }      @GetMapping(""/resources"")     String resources() {         return ""Hello from /resources"";     }      @GetMapping(""/resources/{id}"")     String resourceById(@PathVariable Long id) {         return ""Hello from /resources/"" + id;     }      @Bean     SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {         return httpSecurity                 .authorizeHttpRequests(requests -> {                     requests.antMatchers(""/resources"").hasRole(""admin"");                     requests.antMatchers(""/resources/**"").hasRole(""user"");                     requests.anyRequest().denyAll();                 })                 .httpBasic(Customizer.withDefaults())                 .build();     }  } ```  ```properties spring.security.user.password=password spring.security.user.roles=user ```  Default user (with role `user`) will get `403` attempting to `GET /resources` but can avoid protection by issuing `GET /resources/`, which wouldn't be possible with trailing slash matching disabled.  Let me note that I'm aware that using `mvcMatchers` instead of `antMatchers` would have prevented this issue but that doesn't change the fact that there are many configurations out there relying on `antMatchers` and that sometimes `antMatchers` are simply more suitable for other reasons.  Also, I personally see little real benefit of having trailing slash matching enabled because: - if application renders server-side generated views navigation is either way established using hyperlinks - if application exposes APIs then even more so it is expected that requests are aligned with the API docs  For places where it's really needed for application to respond to both requests, I'd argue that it's either way better solution to configure redirects instead of application wide ambiguous request mappings.  Please consider making this change for `6.0`.","closed","type: enhancement,","vpavic","2022-06-01T13:43:46Z","2022-07-01T17:09:55Z"
"","28592","About register ""BeanPostProcessor"" use""BeanFactoryPostProcessor""","> When I use ""BeanFactoryPostProcessor"" to register ""BeanPostProcessor"" and at the same time use AutoConfiguration to wire up my defined ""BeanFactoryPostProcessor"", I found that my ""BeanPostProcessor"" execution order is after ""@PostConstruct"", I am curious why, and please what is good way to deal with  > The key code is as follows > JDK17\SpringBoot3.0.0-M3 ```java @RequiredArgsConstructor public class MapstructFactory implements BeanPostProcessor {  	private final MapstructRegistry registry;  	@Override 	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { 		if (bean instanceof Converter) { 			registry.addConverter((Converter) bean); 		} 		return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName); 	}  } ``` ```java @RequiredArgsConstructor public class MapstructFactoryRegister implements BeanFactoryPostProcessor {  	private final MapstructRegistry registry;  	@Override 	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { 		 beanFactory.addBeanPostProcessor(new MapstructFactory(registry)); 	}  } ```  ```java @AutoConfiguration public class MapstructAutoConfiguration {  	@Bean 	public MapstructFactoryRegister mapstructFactoryRegister(MapstructRegistry registry) { 		return new MapstructFactoryRegister(registry); 	} } ```","closed","for: stackoverflow,","livk-cloud","2022-06-09T08:23:19Z","2022-06-09T08:27:30Z"
"","28435","spring webflux gets http header data","> Use the following method to get the header information as null ```java @RequestHeader(TenantContext.ATTRIBUTES) String tenant ``` > But this way you can get the data ```java @RequestHeader Map headers ```  Why is this","closed","for: stackoverflow,","livk-cloud","2022-05-10T06:50:59Z","2022-05-10T09:37:25Z"
"","28473","Failed to create AnnotationConfigApplicationContext instance","> I don't know why the creation failed, I did nothing but just created the ApplicationContext > My JDK version is 17 and spring version is 6.0.0-M4(But the M3 version does not have this problem) ```java @Configuration public class Application {      public static void main(String[] args) {         ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Application.class);     } } ``` > This is the exception message ```text Exception in thread ""main"" java.lang.NoClassDefFoundError: org/springframework/beans/factory/aot/BeanFactoryInitializationAotProcessor 	at java.base/java.lang.ClassLoader.defineClass1(Native Method) 	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1012) 	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150) 	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862) 	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760) 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681) 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520) 	at org.springframework.context.annotation.AnnotationConfigUtils.registerAnnotationConfigProcessors(AnnotationConfigUtils.java:165) 	at org.springframework.context.annotation.AnnotationConfigUtils.registerAnnotationConfigProcessors(AnnotationConfigUtils.java:138) 	at org.springframework.context.annotation.AnnotatedBeanDefinitionReader.(AnnotatedBeanDefinitionReader.java:88) 	at org.springframework.context.annotation.AnnotatedBeanDefinitionReader.(AnnotatedBeanDefinitionReader.java:71) 	at org.springframework.context.annotation.AnnotationConfigApplicationContext.(AnnotationConfigApplicationContext.java:69) 	at org.springframework.context.annotation.AnnotationConfigApplicationContext.(AnnotationConfigApplicationContext.java:91) 	at com.livk.http.Application.main(Application.java:19) Caused by: java.lang.ClassNotFoundException: org.springframework.beans.factory.aot.BeanFactoryInitializationAotProcessor 	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) 	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) 	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520) 	... 16 more ```","closed","status: invalid,","livk-cloud","2022-05-18T03:26:47Z","2022-05-18T06:03:47Z"
"","28618","Remove support for cyclic annotation parameter types in Kotlin","#28012 introduced support for cyclic annotation parameter types in Kotlin. However, in Kotlin 1.7 the compiler gives a warning for these cyclic parameters, which will turn into an error in Kotlin 1.9. See [KT-47932](https://youtrack.jetbrains.com/issue/KT-47932).  We could theoretically keep supporting cyclic annotation parameters, but by this point it is clear that this feature was never intended to be there. So removal seems better.  Effectively, this would mean reverting https://github.com/spring-projects/spring-framework/commit/3ec612aaf8611d2ad6e6f7f3d5868feee5024477 and https://github.com/spring-projects/spring-framework/commit/3188c0f7db54cffdb95e7127e2adde959dd078f9.","closed","in: kotlin,","poutsma","2022-06-14T10:41:31Z","2022-06-14T11:14:33Z"
"","27981","Provide testing infrastructure for RuntimeHints","#27829 introduced `RuntimeHints` - a new infrastructure to register the need for runtime reflection, resources, proxying, and serialization on components.  While this infrastructure will help Spring modules to register such concerns, we don't have the testing infrastructure to ensure that existing registrations are enough to cover actual runtime behavior. Since most of those calls are done on JDK APIs, we should provide testing support that:  * intercepts such calls and records invocations * collects invocations and perform assertions in our test suite","closed","theme: aot,","bclozel","2022-01-27T17:48:26Z","2022-06-30T16:21:59Z"
"","28216","Avoid loading XML files for default SQL exception translation","#25335 allowed the use of `SQLErrorCodeSQLExceptionTranslator` to be disabled by configuring `spring.ignore.xml` to `true`. This successfully reduced the footprint when running in a GraalVM native image, but at the cost of potentially different exception translation. To ensure consistent behavior, it would be useful if `SQLErrorCodeSQLExceptionTranslator` could be used without loading `sql-error-codes.xml`.  From @jhoeller:  > For our default purposes, we could even keep those error code mappings in a hard-coded class - and possibly get rid of the default `sql-error-codes.xml` file completely, just supporting that file format for user-provided files.","closed","theme: aot,","wilkinsona","2022-03-22T13:49:29Z","2022-06-14T12:04:24Z"
"","28138","CodeGenerationException thrown when using AnnotationMBeanExporter on JDK 17","### Versions  - Spring Version 5.3.16 - JDK Version : Eclipse Adoptium Temurin-17.0.2+  ### Overview  create some bean (`com.alibaba.druid.filter.stat.StatFilter`) with class extends `javax.management.NotificationBroadcasterSupport`.    `AnnotationMBeanExporter` Bean:  ```java @Configuration public class TestJmxBean {     private static final Logger LOG = LoggerFactory.getLogger(TestJmxBean.class);     @Bean     @Lazy(false)     public AnnotationMBeanExporter annotationMBeanExporter() {         LOG.info(""TestJmxBean.annotationMBeanExporter|REPLACE_EXISTING"");         AnnotationMBeanExporter exporter = new AnnotationMBeanExporter();         exporter.setRegistrationPolicy(RegistrationPolicy.REPLACE_EXISTING);         return exporter;     } } ```  the demo project in the attach file:  [springquartzdemo.zip](https://github.com/spring-projects/spring-framework/files/8190778/springquartzdemo.zip)  ### Steps to Reproduce  1. import the project to ide. 2. run gradlew build 3. use jdk 8 run the main class success. 4. use jdk 17 run the main class  fail 5. see the stack trace。 6. cause : the package name `$javax.management` is not equals to `javax.management` ?  ``` D:\Java\ide\workspace\springquartzdemo>D:\Java\jdk-17.0.2+8\bin\java -verbose:gc --add-opens java.management/javax.management=ALL-UNNAMED  -cp dist/conf;dist/lib/* -Dcom.sun.management.jmxremote.port=19881 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dfile.encoding=UTF-8 com.lizongbo.springdemo.SpringQuartzBugTest [0.025s][info][gc] Using G1 [0.870s][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 23M->5M(128M) 7.105ms 2022-03-05 21:39:11,366 main INFO The lookups option will be ignored. Message Lookups are no longer supported. [1.398s][info][gc] GC(1) Pause Young (Normal) (G1 Evacuation Pause) 29M->7M(128M) 6.926ms 2022-03-05 21:39:11.987 [main] INFO  TestJmxBean.annotationMBeanExporter(TestJmxBean.java:17) - TestJmxBean.annotationMBeanExporter|REPLACE_EXISTING Exception in thread ""main"" org.springframework.jmx.export.UnableToRegisterMBeanException: Unable to register MBean [stat-filter] with key 'stat-filter'; nested exception is org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalArgumentException-->$javax.management.NotificationBroadcasterSupport$$FastClassBySpringCGLIB$$824990df not in same package as lookup class         at org.springframework.jmx.export.MBeanExporter.registerBeanNameOrInstance(MBeanExporter.java:626)         at org.springframework.jmx.export.MBeanExporter.lambda$registerBeans$2(MBeanExporter.java:552)         at java.base/java.util.HashMap.forEach(HashMap.java:1421)         at org.springframework.jmx.export.MBeanExporter.registerBeans(MBeanExporter.java:552)         at org.springframework.jmx.export.MBeanExporter.afterSingletonsInstantiated(MBeanExporter.java:435)         at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:972)         at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:918)         at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:583)         at com.lizongbo.springdemo.SpringQuartzBugTest.main(SpringQuartzBugTest.java:18) Caused by: org.springframework.cglib.core.CodeGenerationException: java.lang.IllegalArgumentException-->$javax.management.NotificationBroadcasterSupport$$FastClassBySpringCGLIB$$824990df not in same package as lookup class         at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:580)         at org.springframework.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:363)         at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:110)         at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:108)         at org.springframework.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54)         at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)         at org.springframework.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61)         at org.springframework.cglib.core.internal.LoadingCache.get(LoadingCache.java:34)         at org.springframework.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:134)         at org.springframework.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:319)         at org.springframework.cglib.reflect.FastClass$Generator.create(FastClass.java:65)         at org.springframework.cglib.proxy.MethodProxy.helper(MethodProxy.java:135)         at org.springframework.cglib.proxy.MethodProxy.init(MethodProxy.java:76)         at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:216)         at org.springframework.aop.framework.CglibAopProxy$DynamicUnadvisedInterceptor.intercept(CglibAopProxy.java:481)         at com.lizongbo.springdemo.SqlChcekStatFilter$$EnhancerBySpringCGLIB$$f714b8d3.getNotificationInfo()         at java.management/com.sun.jmx.mbeanserver.MBeanIntrospector.findNotifications(MBeanIntrospector.java:447)         at java.management/com.sun.jmx.mbeanserver.MBeanIntrospector.getMBeanInfo(MBeanIntrospector.java:393)         at java.management/com.sun.jmx.mbeanserver.MBeanSupport.(MBeanSupport.java:139)         at java.management/com.sun.jmx.mbeanserver.StandardMBeanSupport.(StandardMBeanSupport.java:60)         at java.management/com.sun.jmx.mbeanserver.Introspector.makeDynamicMBean(Introspector.java:194)         at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerObject(DefaultMBeanServerInterceptor.java:893)         at java.management/com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.registerMBean(DefaultMBeanServerInterceptor.java:320)         at java.management/com.sun.jmx.mbeanserver.JmxMBeanServer.registerMBean(JmxMBeanServer.java:523)         at org.springframework.jmx.support.MBeanRegistrationSupport.doRegister(MBeanRegistrationSupport.java:138)         at org.springframework.jmx.export.MBeanExporter.registerLazyInit(MBeanExporter.java:715)         at org.springframework.jmx.export.MBeanExporter.registerBeanNameOrInstance(MBeanExporter.java:597)         ... 8 more Caused by: java.lang.IllegalArgumentException: $javax.management.NotificationBroadcasterSupport$$FastClassBySpringCGLIB$$824990df not in same package as lookup class         at java.base/java.lang.invoke.MethodHandleStatics.newIllegalArgumentException(MethodHandleStatics.java:167)         at java.base/java.lang.invoke.MethodHandles$Lookup$ClassFile.newInstance(MethodHandles.java:2283)         at java.base/java.lang.invoke.MethodHandles$Lookup.makeClassDefiner(MethodHandles.java:2318)         at java.base/java.lang.invoke.MethodHandles$Lookup.defineClass(MethodHandles.java:1843)         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         at java.base/java.lang.reflect.Method.invoke(Method.java:568)         at org.springframework.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:577)         ... 34 more [1.809s][info][gc] GC(2) Pause Young (Concurrent Start) (Metadata GC Threshold) 32M->9M(128M) 5.691ms [1.811s][info][gc] GC(3) Concurrent Mark Cycle [1.821s][info][gc] GC(3) Pause Remark 10M->10M(40M) 2.380ms [1.823s][info][gc] GC(3) Pause Cleanup 10M->10M(40M) 0.067ms [1.826s][info][gc] GC(3) Concurrent Mark Cycle 15.156ms ```  ![bug004](https://user-images.githubusercontent.com/1670666/156886423-8557462f-93b3-4f94-8b28-9e5efeb34722.png)  ![bug005](https://user-images.githubusercontent.com/1670666/156886432-97dfcb3f-2700-4bd7-96f6-ded43c75e797.png)","closed","status: feedback-provided,","lizongbo","2022-03-05T13:58:59Z","2022-04-08T11:26:57Z"
"","28743","PathResourceResolver leaks URI paths","### Summary When resolving a resource path Spring creates a class path resource for the URI path. In use cases where the application is hit with a variety of request paths that are not mapped in a controller, this results in memory being leaked over time as these resources are not collected.   ### Steps to reproduce Create a new spring boot application with a single controller endpoint. Use a script to generate HTTP requests to hit your spring boot app. The request paths must be randomly generated and miss your controller, resulting in a 404 response from Spring. With request rates of 1000 req/s it took me only a few minutes to see massive amounts of leaked memory.   ### Likely Cause If you look at `PathResourceResolver::getResource` on the line that reads `Resource resource = location.createRelative(resourcePath);`, this creates a class path resource for every incoming request. After a while, this builds up resulting in lots of leaked resource paths.   ### My setup pom.xml ```xml       4.0.0              org.springframework.boot         spring-boot-starter-parent         2.6.7                    com.example     playground     0.0.1-SNAPSHOT     playground     playground              11                                org.springframework.boot             spring-boot-starter-webflux                               org.springframework.boot             spring-boot-starter-test             test                               io.projectreactor             reactor-test             test                ```  PlaygroundApplication.java ```java import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import reactor.core.publisher.Mono;  @SpringBootApplication @Controller(""/"") public class PlaygroundApplication {      @GetMapping(""test"")     public Mono doTest() {         return Mono.just(""test"");     }      public static void main(String[] args) {         SpringApplication.run(PlaygroundApplication.class, args);     } } ```  Class I wrote to generate requests ```java import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.time.Duration; import java.util.Random; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit;  public class QuickTester {     private static final Random RND = new Random();     private static final ScheduledExecutorService timerExecutor = Executors.newScheduledThreadPool(40);      public static void main(String[] args) {         HttpClient client = HttpClient.newBuilder()                 .version(HttpClient.Version.HTTP_1_1)                 .build();          timerExecutor.scheduleAtFixedRate(() -> {             HttpRequest request = HttpRequest.newBuilder()                     .uri(URI.create(String.format(""http://localhost:8080/%d"",                             RND.nextInt(1000000000))))                     .timeout(Duration.ofSeconds(5))                     .GET()                     .build();              try {                 client.send(request, HttpResponse.BodyHandlers.ofString());             } catch (Exception ignored) {}         }, 0, 1, TimeUnit.MILLISECONDS);     } } ```","closed","status: invalid,","LoganEarl","2022-07-01T19:59:02Z","2022-07-02T07:38:38Z"
"","28079","Deprecate ""enclosing classes"" search strategy for MergedAnnotations","### Overview  The `TYPE_HIERARCHY_AND_ENCLOSING_CLASSES` search strategy for `MergedAnnotations` was originally introduced to support `@Nested` test classes in JUnit Jupiter.  However, while implementing #19930, we determined that the `TYPE_HIERARCHY_AND_ENCLOSING_CLASSES` search strategy unfortunately could not be used since it does not allow the user to control when to recurse up the enclosing class hierarchy. For example, this search strategy will automatically search on enclosing classes for static nested classes as well as for inner classes, when the user probably only wants one such category of ""enclosing class"" to be searched. Consequently, [`TestContextAnnotationUtils`](https://github.com/spring-projects/spring-framework/blob/main/spring-test/src/main/java/org/springframework/test/context/TestContextAnnotationUtils.java) was introduced in the _Spring TestContext Framework_ to address the shortcomings of the `TYPE_HIERARCHY_AND_ENCLOSING_CLASSES` search strategy.  Since this search strategy is unlikely to be useful to general users, the team should consider deprecating this search strategy in Spring Framework 6.0.  ### Related Issues  - #19930 - #23378 - #28080","closed","type: enhancement,","sbrannen","2022-02-19T15:32:00Z","2022-03-16T18:36:16Z"
"","28105","Support custom HTTP status in client-side REST testing support","## TL; DR; Add supporting for custom http statuses in mocked responses I copied logic from `org.springframework.http.ResponseEntity`  ## Foreword In my company we use ""custom not found status"" in our REST API's to prevent mixing network error (404 ""not found"" for unknown routes) with rest responses (when entity with given id not found). There are good example for rest controller tests. Suppose we have a rest endpoint for car entity: `GET /car/{id}`.  Let's try to write test for case when entity with given id not found. Something like that: ```java mockMvc.perform(get(""/car/{id}/"", nonExistsId.toString()))         .andExpect(status().is(404)); ``` And if our code in rest controller have bug, then test will fail with something like ""500 internal server error"" But if we also make mistake in test in request's path, like that: ```java mockMvc.perform(get(""/carS/{id}/"", nonExistsId.toString()))         .andExpect(status().is(404)); ``` then test will pass and we don't catch bugs in cases when entity with given id is non-exists. So, for this reason we used ""454"" as http status for ""not found"" case.  ## Problem In our clients code we also write tests and want to cover this case with custom http status, but we cant because MockRestResponseCreators and MockClientHttpResponse not support custom http codes: ```java   mockRestServiceServer.expect(requestTo(serverURI)           .andExpect(method(HttpMethod.GET))           .andRespond(withStatus(454)); // <-- will not work cause support only HttpStatus  ```","closed","type: enhancement,","AzZureman","2022-02-25T01:14:36Z","2022-03-16T09:29:46Z"
"","28128","spring @Transactional annotation lose efficacy","## spring version ？ 4.3.13RELEASE ## question ？ A service is not TransactionInterceptor  intercepted，cause transactional to fail，all configurations are correct under the same circumstances ，some transactional will take effect ## solution？ `   @Autowired  MaterialService materialService; ` materialService the method inside have question， all add  private  succeed  What kind of question is that？ Looking forward to your reply","open","in: data,","zhao190775705","2022-03-03T06:20:10Z","2022-04-25T09:38:33Z"
"","28283","Using AOP and DI itself causes Spring ApplicationListener to be fired twice","## Software versions  - Spring Version  5.3.18 and earlier  - JDK Version 1.8.0_202  ## Overview  When I use Spring ApplicationListener, in order to prevent transaction invalidation, my ApplicationListener implementation class writes the following code (of course, the code can be written differently to avoid this problem), which will cause my listener to trigger twice after the event is published. I think it's not normal, but not sure if it's a bug, so I want to ask everyone's opinion.  ```java @Component public class EventDemoListener implements ApplicationListener {     @Autowired     DemoService1 demoService1;     @Autowired     DemoService2 demoService2;     @Autowired     EventDemoListener eventDemoListener;      @Override     public void onApplicationEvent(EventDemo event) {         eventDemoListener.testTransaction();         System.out.println(""receiver "" + event.getMessage());     }      @Transactional(rollbackFor = Exception.class)     public void testTransaction() {         demoService1.doService();         demoService2.doService();     } } ``` Through this demo project, this problem can be reproduced. Please read the README.md document before running.     [https://github.com/ZiFeng-Wu/spring-study](https://github.com/ZiFeng-Wu/spring-study)  ## Analysis  1. After analysis, because here DI itself , When `EventDemoListener` is created, property filling will trigger `DefaultSingletonBeanRegistry#getSingleton(String, boolean)` in advance.  2. Then `singletonFactory.getObject()` executed in `getSingleton()` will cause the unproxyed `EventDemoListener` object to be put into `AbstractAutoProxyCreator#earlyProxyReferences`.  3. After the properties are filled, calling `AbstractAutowireCapableBeanFactory#initializeBean(String, Object, RootBeanDefinition)` and executing `ApplicationListenerDetector#postProcessAfterInitialization(Object, String)` will cause the unproxyed `EventDemoListener` object to be put into the `AbstractApplicationEventMulticaster.DefaultListenerRetriever#applicationListeners` container.      [![enter image description here][1]][1]  4. Then when the event is published, execute `AbstractApplicationEventMulticaster.DefaultListenerRetriever#getApplicationListeners()`  and use `ApplicationListener listener =beanFactory.getBean(listenerBeanName, ApplicationListener.class)` to obtain the listener is the proxied `EventDemoListener` object.  5. At this time, there are only unproxyed `EventDemoListener` object in the `applicationListeners` container, so the proxied `EventDemoListener` object will be added to the final returned allListeners collection, as shown in the figure below, which will eventually cause the listener to be triggered twice.      [![enter image description here][2]][2]     [1]: https://i.stack.imgur.com/lz51c.png   [2]: https://i.stack.imgur.com/oZ8OA.png","open","in: core,","ZiFeng-Wu","2022-04-04T15:48:07Z","2022-04-25T09:59:10Z"
"","28579","Update documentation regarding nested test class support","## Overview  With the introduction of `@NestedTestConfiguration` in 5.3, we introduced first-class support for inheriting test configuration in `@Nested` test classes, but the documentation was not consistently updated to reflect this.  ## Related Issues  - #19930 - #28466","closed","type: documentation,","sbrannen","2022-06-07T13:07:26Z","2022-06-08T08:01:40Z"
"","28826","Introduce SPI for processing ApplicationContext failures in the TestContext framework","## Overview  When a failure occurs while loading an `ApplicationContext` in the Spring TestContext Framework, it would be useful to have a first-class SPI for processing the exception.  For example, Spring Boot's testing support currently has a `SpringBootDependencyInjectionTestExecutionListener` that is responsible for generating a detailed failure report to help diagnose what went wrong; however, Spring Boot has to replace the standard `DependencyInjectionTestExecutionListener` with the Spring Boot specific one. In addition, the `SpringBootDependencyInjectionTestExecutionListener` has some drawbacks (see https://github.com/spring-projects/spring-boot/issues/24888).  We should therefor introduce a first-class SPI in the TestContext framework for ""processing"" `ApplicationContext` load failures -- basically a new interface that third parties like Spring Boot can implement and register (potentially via the `spring.factories` mechanism).  ## Related Issues  - https://github.com/spring-projects/spring-boot/issues/24888 - #14182","open","type: enhancement,","sbrannen","2022-07-15T08:29:51Z","2022-07-19T14:54:29Z"
"","28769","Avoid proxy hint generation for annotations that are never synthesized","## Overview  We can reduce the amount of generated proxy configuration and the native footprint by avoiding inclusion of unused annotation proxy classes in the native images.  ## Rationale  Annotations like `@GetMapping` in Spring MVC are composed annotations for `@RequestMapping`; however, there is nowhere in the core Spring Framework where a lookup is performed for a `@GetMapping` annotation. Rather, the corresponding lookups are only for merged `@RequestMapping` annotations.  Consequently, `@RequestMapping` needs to be synthesized, but the composed annotations `@GetMapping`, `@PostMapping`, etc. do not need to be synthesized.  In other words, `WebAnnotationsRuntimeHintsRegistrar.registerHints()` can be greatly simplified.  ## Brainstorming  We could analyze how we use `RuntimeHintsUtils.registerAnnotation`, simplify our usage by only registering annotations we know will need to be synthesized, and update the documentation to reflect this mindset/guidance.  We could introduce support (potentially in the _agent_) to detect the use of `@AliasFor` referencing a meta-annotation's attribute and automatically register the target meta-annotation for a synthesized annotation proxy.  ## Related Issues  - #28767","open","theme: aot,","sbrannen","2022-07-06T13:38:00Z","2022-08-01T12:35:51Z"
"","28055","Introduce landing page for JavaDoc and KDoc","## Overview  Spring Framework's Kotlin API documentation is not discoverable via https://spring.io/projects/spring-framework#learn.  The `API Doc.` link points to the [JavaDoc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/), and there is no way to navigate to the KDoc unless you follow one of the links buried in the reference manual.  ## Deliverables  - [ ] Introduce a new HTML ""landing page"" for the API docs that provides links to the [JavaDoc](https://docs.spring.io/spring-framework/docs/current/javadoc-api/) and [KDocs](https://docs.spring.io/spring-framework/docs/current/kdoc-api/).    - For example, this could be a new `api/index.html` file so that `/api` would be the link for the landing page. - [ ] Update spring.io so that the `API Doc.` links point to the new landing page. - [ ] Ensure that the landing page is included in the ZIP distribution that gets unzipped on the spring.io server.","open","type: task,","sbrannen","2022-02-15T16:02:06Z","2022-06-07T13:26:41Z"
"","28911","Remove deprecated GenericPropertiesContextLoader from the TestContext framework","## Overview  Since `GenericPropertiesContextLoader` was deprecated in Spring Framework 5.3, we have decided to remove it in Spring Framework 6.0.  ## Related Issues  - #24875","closed","type: enhancement,","sbrannen","2022-08-02T09:51:35Z","2022-08-02T10:09:47Z"
"","28080","Remove TYPE_HIERARCHY_AND_ENCLOSING_CLASSES search strategy for MergedAnnotations","## Overview  Since #28207 has introduced support for providing a `Predicate>` that allows for complete control over the ""enclosing classes"" aspect of the search algorithm in `MergedAnnotations`, the deprecated `TYPE_HIERARCHY_AND_ENCLOSING_CLASSES` search strategy can now be completely removed.  ## Related Issues  - #28079 - #28207","closed","type: enhancement,","sbrannen","2022-02-19T15:34:31Z","2022-03-24T15:35:59Z"
"","28824","Introduce TestClassScanner to locate Spring test classes for AOT processing","## Overview  Similar to the `org.springframework.aot.test.build.TestClassesFinder` from the Spring Native project, we need something that can scan the classpath (from classpath roots provided by the user or build tool) to locate Spring test classes.  ## Related Issues  - #28204  - #28205  - #28825  ## Deliverables  - [x] Introduce `TestClassScanner` in `spring-test` that effectively scans the classpath for Spring test classes using the `Launcher` API from the JUnit Platform (JUnit 5). - [x] Find JUnit Jupiter test classes annotated with `@ExtendWith(SpringExtension.class)`. - [x] Find JUnit 4 test classes annotated with `@RunWith(SpringRunner.class)` or `@RunWith(SpringJUnit4ClassRunner.class)`. - [x] Find _other_ test classes (for example, TestNG) annotated with `@ContextConfiguration` or `@BootstrapWith`. - [x] Ensure that test classes are properly detected within JUnit Platform `@Suite` hierarchies.","closed","theme: aot,","sbrannen","2022-07-14T12:31:20Z","2022-07-15T14:34:35Z"
"","28825","Introduce command-line application for triggering AOT test context processing","## Overview  Similar to the `org.springframework.aot.test.build.GenerateTestBootstrapCommand` from the Spring Native project, we need a command-line application that triggers AOT context processing for the TestContext framework.  This application should use the `TestClassScanner` (see #28824) to locate Spring test classes and then pass those test classes to the component(s) created in conjunction with #28204.  ## Related Issues  - #28204  - #28205  - #28824","open","theme: aot,","sbrannen","2022-07-14T12:35:17Z","2022-07-14T12:35:18Z"
"","27919","Update examples for JavaScript ScriptEngine support","## Overview  Several existing tests as well as examples in the reference manual refer to Nashorn as the supported `ScriptEngine` for JavaScript; however, Nashorn is no longer supported since Java 15.  In the interim, [GraalVM](https://www.graalvm.org/reference-manual/js/NashornMigrationGuide/) has superseded Nashorn for JavaScript `ScriptEngine` support.  ## Deliverables  - [ ] Update [Web MVC](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#spring-web) and [WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-view-script) examples so that they mention GraalVM JS support instead of Nashorn. - [ ] Create an example project (location yet to be determined) which verifies that GraalVM can be used as the JavaScript `ScriptEngine` for use with:    - [ ] `StandardScriptFactory`    - [ ] `ScriptTemplateView` - [x] Delete all Nashorn-specific tests which are currently disabled anyway (via `@DisabledForJreRange(min = JAVA_15)`)","open","in: core,","sbrannen","2022-01-11T13:37:25Z","2022-06-07T13:28:37Z"
"","28495","Invoke default methods in dynamic proxies automatically","## Overview  See #28491 for background information.  In JDK dynamic proxies created by Spring AOP, we could potentially introduce support for automatically invoking default methods (or make it easier via a utility).  ## Available Java APIs  - `java.lang.reflect.Method.isDefault()` - `java.lang.reflect.InvocationHandler.invokeDefault(Object, Method, Object...)`","open","type: enhancement,","sbrannen","2022-05-20T11:18:19Z","2022-07-12T07:48:14Z"
"","28205","Add hook-point in the TCF to use pre-processed AOT context","## Overview  Once we've done #28204, we need to be able to configure the TCF so that it uses our optimized context rather than doing all the parsing again. Given that our input is the test class, it would be interesting to see if we can shortcut most of the processing and go straight to starting (or reusing) the context.  ## Related Issues  - #28066 - #28205  - #28824  - #28825","open","theme: aot,","snicoll","2022-03-21T13:56:37Z","2022-07-14T12:36:37Z"
"","28797","Migrate to JSpecify annotations for nullability constraints","## Overview  Once [JSpecify](https://github.com/jspecify/jspecify) releases a relatively stable (potentially beta) version, we should migrate to JSpecify annotations for nullability constraints.  The current plan is to meta-annotate annotations in the `org.springframework.lang` package with JSpecify annotations alongside the JSR-305 annotations. Doing so will allow a transition period away from JSR-305 annotations while JSpecify annotations gain traction in the community and proper support from IDEs and build tools.  ## Related Issues  - #27183","open","type: enhancement,","sbrannen","2022-07-12T12:42:06Z","2022-07-12T12:42:06Z"
"","28204","Add support for processing test contexts ahead-of-time","## Overview  Now that we can process an application context, we'd like to extend that feature by providing support in other part of the portfolio. One  that we have experimented in Spring Native is processing the application contexts that the TCF use for a module so that they are ""native-friendly"".   In practice, this would mean introducing something like `TestContextAotProcessor` that builds on top of `ApplicationContextAotProcessor`, pre-processing the test infrastructure for each context identified amongst a set of test classes.  We'd need at least one additional context to provide a ""prepared"" `GenericApplicationContext` for a `MergedContextConfiguration` as each ""bootstrapper"" can have its own logic baked in.  ## Related Issues  - #28205  - #28824  - #28825","open","theme: aot,","snicoll","2022-03-21T13:53:35Z","2022-08-02T13:31:55Z"
"","28208","Introduce fluent API for search options in MergedAnnotations","## Overview  Inspired by the requirements for implementing #28207, we have decided to introduce a fluent API for search options in [`MergedAnnotations`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/MergedAnnotations.html).  The following is an example of how one would supply search options using the existing API.  ```java MergedAnnotations annotations = MergedAnnotations.from(myClass, SearchStrategy.TYPE_HIERARCHY, 		RepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class), 		myCustomAnnotationFilter); ```  ## Proposal  For each strategy in [`SearchStrategy`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/MergedAnnotations.SearchStrategy.html), we will introduce a corresponding `find*()` method that starts the fluent API. Methods such as `usingRepeatableContainers()` and `withAnnotationFilter()` will be optional. The fluent API culminates with an invocation of `from(...)` which performs the search and returns the `MergedAnnotations` instance.  With a fluent API, the above can be rewritten as follows.  ```java MergedAnnotations annotations = MergedAnnotations     .findAnnotationsInTypeHierarchy()     .usingRepeatableContainers(RepeatableContainers.of(MyRepeatable.class, MyRepeatableContainer.class))     .withAnnotationFilter(myCustomAnnotationFilter)     .from(myClass); ```  For a less involved use case that relies on the defaults for repeatable containers and filtering, the code would reduce to the following.  ```java MergedAnnotations annotations = MergedAnnotations.findAnnotationsInTypeHierarchy().from(myClass); ```","closed","type: enhancement,","sbrannen","2022-03-21T16:43:40Z","2022-03-22T19:04:35Z"
"","28906","Introduce ""no refresh"" SmartContextLoader.loadContext() variant","## Overview  In order to support AOT processing within the _Spring TestContext Framework_ (TCF), we need a way to signal to `SmartContextLoader` implementations that they should load the test's `ApplicationContext` without _refreshing_ it or registering a JVM shutdown hook.  ## Proposal  - Introduce a new `loadContext(MergedContextConfiguration, )` method that accepts an additional argument -- for example, a `boolean` flag -- that allows the TCF to signal whether the returned `ApplicationContext` should be refreshed. - Deprecate the existing `loadContext(MergedContextConfiguration)` method in favor of the new method. - Remove all use of the deprecated method within the `spring-test` module.  ## Related Issues  - #28204","open","theme: aot,","sbrannen","2022-08-01T15:05:30Z","2022-08-02T07:47:00Z"
"","28562","Stop initializing DataSize at build time for GraalVM","## Overview  In light of #28560, we can now revert the change made in #28328.  ## Related Issues  - #28560 - #28328 - https://github.com/oracle/graal/issues/4489","closed","in: core,","sbrannen","2022-06-03T14:39:08Z","2022-06-03T14:52:23Z"
"","28176","@Lazy injection point target is proxied twice for @Resource not matching bean name","## Overview  If the field name for a `@Lazy @Resource` does not match the bean name of the desired dependency, both `CommonAnnotationBeanPostProcessor.buildLazyResourceProxy(...)` and `ContextAnnotationAutowireCandidateResolver.buildLazyResolutionProxy(...)` will create proxies for the injected bean, with the latter creating a proxy that wraps the proxy created by the former.  For example, in the following test case, the `fieldNameMatchesBeanName()` test passes; whereas, the `fieldNameDoesNotMatchBeanName()` test fails with an error similar to the following.  ``` Expected size: 2 but was: 3 in: [example.LazyResourceTests$MyBean$$EnhancerBySpringCGLIB$$c2407600,     example.LazyResourceTests$MyBean$$EnhancerBySpringCGLIB$$c2407600,     example.LazyResourceTests.MyBean] ```  ```java @SpringJUnitConfig class LazyResourceTests {  	@Lazy 	@Resource 	MyBean myBean;  	@Lazy 	@Resource 	MyBean bean;  	@Test 	void fieldNameMatchesBeanName() throws Exception { 		assertPathToTarget(this.myBean); 	}  	@Test 	void fieldNameDoesNotMatchBeanName() throws Exception { 		assertPathToTarget(this.bean); 	}  	private static void assertPathToTarget(Object beanToInspect) throws Exception { 		List> classes = new ArrayList<>(); 		Object current = beanToInspect; 		while (current != null) { 			classes.add(current.getClass()); 			if (AopUtils.isAopProxy(current) && current instanceof Advised) { 				current = ((Advised) current).getTargetSource().getTarget(); 			} 			else { 				break; 			} 		} 		assertThat(classes).hasSize(2); 	}  	@Configuration 	static class Config { 		@Bean 		MyBean myBean() { 			return new MyBean(); 		} 	}  	static class MyBean { 	}  } ```  ## Related Issues  - #28173","closed","in: core,","sbrannen","2022-03-13T14:24:01Z","2022-03-15T13:42:44Z"
"","27947","PropertySourcesPlaceholderConfigurer ignores ignoreUnresolvablePlaceholders flag","## Overview  If a `PropertySourcesPlaceholderConfigurer` bean has its `ignoreUnresolvablePlaceholders` flag set to `true`, that flag is not always honored when asking the `Environment` to resolve a property containing placeholders.  As a consequence, given a property declared as `my.app.var = ${var}` _without_ a corresponding `var` property declared, an attempt to resolve `@Value(""${my.app.var}"")` will result in the following exception.  ``` java.lang.IllegalArgumentException: Could not resolve placeholder 'var' in value ""${var}"" ```  ## Related Issues  - #9628  ## Deliverables  - [x] Ensure that unresolvable placeholders are always ignored if the `ignoreUnresolvablePlaceholders` flag in `PropertySourcesPlaceholderConfigurer` is set to `true`.","closed","in: core,","sbrannen","2022-01-18T13:49:21Z","2022-01-18T15:29:24Z"
"","28207","Introduce predicate for searching enclosing classes in MergedAnnotations","## Overview  Due to the deprecation of `SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES` (see #28079), we will introduce a way for users to provide a `Predicate>` that is used to decide when the enclosing class for the class supplied to the predicate should be searched.  This will give the user complete control over the ""enclosing classes"" aspect of the search algorithm in `MergedAnnotations`.  - To achieve the same behavior as `TYPE_HIERARCHY_AND_ENCLOSING_CLASSES`, a user can provide `clazz -> true` as the predicate. - To limit the enclosing class search to inner classes, a user can provide `ClassUtils::isInnerClass` as the predicate. - To limit the enclosing class search to static nested classes, a user can provide `ClassUtils::isStaticClass` as the predicate. - For any other use case (such as in `TestContextAnnotationUtils` in `spring-test`), the user can provide a custom predicate.  ## Proposal  Based on the outcome of #28208, a `searchEnclosingClass` predicate could be supplied when using the `TYPE_HIERARCHY` search strategy as follows.  ```java MergedAnnotations annotations = MergedAnnotations     .search(SearchStrategy.TYPE_HIERARCHY)     .withEnclosingClasses(ClassUtils::isInnerClass)     .from(myClass); ```  By limiting when a `searchEnclosingClass` predicate can be supplied in the fluent search API, we can prevent users from trying to supply such a predicate for other `SearchStrategy` types.","closed","type: enhancement,","sbrannen","2022-03-21T16:28:20Z","2022-03-24T14:44:09Z"
"","28202","Determine why previous isolation level is never set in R2dbcTransactionManager","## Overview  Currently, the `previousIsolationLevel` is never set in `R2dbcTransactionManager.ConnectionFactoryTransactionObject`; however, there is code in place to read the previous isolation level in `R2dbcTransactionManager.doCleanupAfterCompletion(TransactionSynchronizationManager, Object)`.  ## Deliverables  - [x] Determine why `previousIsolationLevel` is never set. - [x] Introduce code to set the `previousIsolationLevel` if appropriate; otherwise, delete all code related to `previousIsolationLevel`.","closed","type: task,","sbrannen","2022-03-20T12:15:47Z","2022-03-21T15:30:03Z"
"","28811","Reintroduce Javadoc links to Apache HttpClient 5.1 APIs","## Overview  Commit 3af6a22b9f728d1029be41c06b064170f2f6b016 temporarily disabled the links due to issues with the Apache web site that break our Gradle build.  ## Related Issues  - https://issues.apache.org/jira/browse/HTTPCLIENT-2227","closed","status: superseded,","sbrannen","2022-07-13T10:39:48Z","2022-07-19T12:44:48Z"
"","28501","Create UrlResource factory methods that throw unchecked exceptions","## Overview  `UrlResource` constructors throw checked exceptions which makes it difficult to use them in `java.util.Stream` and `java.util.Optional` APIs or other scenarios when a checked `IOException` is undesirable.  ## Proposal  To support such use cases, we should introduce factory methods in `UrlResource` that throw `UncheckedIOException`, initially for the constructor variants that accept a `URI` or `String`.  ## Related Issues  - #21515","closed","type: enhancement,","sbrannen","2022-05-22T16:57:15Z","2022-05-23T12:30:00Z"
"","28760","Deprecate convention-based annotation attribute overrides in favor of @AliasFor","## Overview  **Implicit** convention-based annotation attribute overrides have been supported for a long time; however, Spring Framework 4.2 introduced support for **explicit** annotation attribute overrides via `@AliasFor`.  Since explicit overrides are favorable to implicit overrides, and since the support for convention-based overrides increases the complexity of Spring's annotation search algorithms, we will deprecate convention-based overrides in 6.0 and remove the support in 6.1 (see #28761).  ## Deliverables  - [x] in 6.0, whenever a convention-based override is detected, log a warning stating the reasons mentioned above","closed","type: enhancement,","sbrannen","2022-07-05T13:49:56Z","2022-07-07T15:42:23Z"
"","28061","IllegalStateException is thrown due to a lack of Kotlin nullable support in Spring Messaging","## Library versions  - spring-boot-starter-amqp: 2.6.3 - spring-messaging: 5.3.15 - kotlin: 1.6.10 - kotlin-stdlib: 1.6.10 - kotlint-reflect: 1.6.10  ## Scenario  Subscribing a particular topic by invoking one of the methods in my controller.  ```kotlin @SubscribeMapping(""/sometopic"") fun foo(bar: Bar?) {   // Method implementation } ```  ## Bug triggered  The nullable `Bar` in Kotlin cannot be recognized by the `HandlerMethod` in `org.framework.messaging.handler`.  `Bar` is treated as a normal Java object inside the method.  When I invoke the method by passing a nullable object, which would be converted to a `Optional` object in Java at the end, the exception is then thrown.","closed","in: kotlin,","kimkaesar","2022-02-16T08:58:36Z","2022-03-30T14:29:07Z"
"","28090","When SQL init, 'PostgresqlBadGrammarException' is thrown by improperly splitting a valid statement that ';' containing","## Issue  The syntax below is valid in PostgreSQL, but ';' characters cause improper separation and execution.  ```sql CREATE OR REPLACE RULE insert_docents AS ON INSERT TO docents DO INSTEAD (     INSERT INTO users     VALUES (default,             new.email,             new.name,             new.hash_salt,             new.roles)     ON CONFLICT (id) DO NOTHING;     INSERT     INTO docent_users     VALUES (currval('users_id_seq'),             new.introduce_short,             new.introduce_long,             new.video,             new.images)     ); ```  ``` Caused by: org.springframework.r2dbc.connection.init.ScriptStatementFailedException: Failed to execute SQL script statement #4 of class path resource [db/schema.sql]: CREATE OR REPLACE RULE insert_docents AS ON INSERT TO docents DO INSTEAD ( INSERT INTO users VALUES (default, new.email, new.name, new.hash_salt, new.roles) ON CONFLICT (id) DO NOTHING; nested exception is io.r2dbc.postgresql.ExceptionFactory$PostgresqlBadGrammarException: [42601] syntax error at end of input ```  another example  ```sql CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$     BEGIN         --         -- Perform the required operation on emp, and create a row in emp_audit         -- to reflect the change made to emp.         --         IF (TG_OP = 'DELETE') THEN             DELETE FROM emp WHERE empname = OLD.empname;             IF NOT FOUND THEN RETURN NULL; END IF;              OLD.last_updated = now();             INSERT INTO emp_audit VALUES('D', user, OLD.*);             RETURN OLD;         ELSIF (TG_OP = 'UPDATE') THEN             UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;             IF NOT FOUND THEN RETURN NULL; END IF;              NEW.last_updated = now();             INSERT INTO emp_audit VALUES('U', user, NEW.*);             RETURN NEW;         ELSIF (TG_OP = 'INSERT') THEN             INSERT INTO emp VALUES(NEW.empname, NEW.salary);              NEW.last_updated = now();             INSERT INTO emp_audit VALUES('I', user, NEW.*);             RETURN NEW;         END IF;     END; $$ LANGUAGE plpgsql; ```  ## Expect  Not use `;` character between `$$` ... `$$` or `(` ... `)` as statement separator","closed","status: superseded,","wickedev","2022-02-22T03:07:43Z","2022-02-22T07:15:30Z"
"","28888","Fix memory leak with CglibAopProxy$ProxyCallbackFilter","## Bug report Bug report and reason is explained very well here #26266.  In the cglib side, this issue [#80](https://github.com/cglib/cglib/issues/80#issue-160623315) is the consequence of trying to solve `CallbackFilter` leak. As vlsi said > ""weakly reachable CallbackFilters"" and ""classloader reuse"" do not play together well.  ## Solution * This solution is to try to reduce the leak by make `advisors` and `advisorChainFactory` WeakReference , so that there should have no chance to leak 'big object'. Think about class created by cglib is also 'leaked', I think that should be acceptable.  * Another quick solution is to make `AbstractAutoProxyCreator` implements `DisposableBean`, clear `CallbackFilter` field in generated class.","open","status: waiting-for-triage,","vikeychen","2022-07-29T16:19:17Z","2022-07-31T05:08:17Z"
"","28037","Adds observation support for R2DBC","# What is it about?  Adds observation support for R2DBC.  - adds micrometer BOM - adds micrometer tracing BOM - adds micrometer & micrometer tracing optional deps to R2DBC module - adds tracing support for R2DBC (metrics come out of the box)  # To discuss  - I have left a commented out section in the listener where in Sleuth we needed to check if the context is ready. The listener might be called early in the lifecycle of Spring and certain beans might not have been initialized (micrometer or tracing related ones) - I would like to add the automated asciidoctor documentation generation from sources (check [this project out](https://github.com/micrometer-metrics/micrometer-docs)) - I've a test annotated as `@Disabled` that is typically used for manual assertion of spans in Zipkin or Wavefront. Do we want to leave it there in the code or are there some dedicated samples that we can reuse for that?  cc @mp911de","open","theme: observability,","marcingrzejszczak","2022-02-11T13:03:11Z","2022-02-15T14:00:59Z"
"","28133","R2DBC Connection is closed during transaction when using TransactionAwareConnectionFactoryProxy","# summary of problem  It seems that `org.springframework.r2dbc.connection.TransactionAwareConnectionFactoryProxy` closes a connection during transaction.  When using `TransactionAwareConnectionFactoryProxy`, the following exception is thrown:  ``` org.springframework.transaction.IllegalTransactionStateException: Transaction is already completed - do not call commit or rollback more than once per transaction         at org.springframework.transaction.reactive.AbstractReactiveTransactionManager.rollback(AbstractReactiveTransactionManager.java:492) ~[spring-tx-5.3.16.jar:5.3.16]         Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:  ```  To get full stacktrace, see the README of the reproducible project.  # version  Spring Framework 5.3.16 Spring Boot 2.6.4  # reproducible project  https://github.com/nakamura-to/issue-spring-r2dbc-connection  To reproduce the issue, execute `./gradlew bootRun` and access `http://localhost:8080/ng`.  # solution  I think this issue could be solved by returning `Mono.empty()` instead of `Mono.from(connection.close())` during transaction execution.  https://github.com/spring-projects/spring-framework/blob/v5.3.16/spring-r2dbc/src/main/java/org/springframework/r2dbc/connection/ConnectionFactoryUtils.java#L177-L181","open","in: data,","nakamura-to","2022-03-03T22:43:54Z","2022-05-31T15:16:35Z"
"","28166","Fix a performance problem in CachedIntrospectionResults","# Description This commit fixes a performance problem in CachedIntrospectionResults. If multiple threads call `CachedIntrospectionResults::forClass` at the same time, more than one CachedIntrospectionResults will be created redundantly and consume a lot of CPU time.  # Reproduce I have a server with only one CPU. Assume that 100 requests come simultaneously and each request will call `BeanUtils::getPropertyDescriptor` directly and `CachedIntrospectionResults::forClass` indirectly. When loading the same keys by different threads, keys are not locked. In my test, each `CachedIntrospectionResults::forClass` call consumes more than 100ms CPU time, so 100 requests consume 10000ms CPU time in total.","open","type: enhancement,","luozhenyu","2022-03-11T16:41:12Z","2022-03-31T12:49:52Z"
"","28668","can't open spring.io in china","","closed","status: invalid,","lzj960515","2022-06-21T06:56:56Z","2022-06-21T07:00:29Z"
"","28862","5.3.x","","closed","status: invalid,","disaster1-tesk","2022-07-23T12:07:57Z","2022-07-23T13:45:35Z"
"","28857","spring-orm mvp conversion to hibernate6","","closed","status: declined,","hduerkop","2022-07-22T14:18:55Z","2022-07-25T07:14:53Z"
"","28843","Fix inferred methods code generation","","closed","theme: aot,","OlgaMaciaszek","2022-07-19T17:41:01Z","2022-07-20T08:48:39Z"
"","28822","Fix typos in Javadoc, documentation and code","","open","type: documentation,","marcwrobel","2022-07-14T11:05:10Z","2022-08-01T09:42:49Z"
"","28817","Fix broken link in rsocket documentation","","closed","type: documentation,","jupiterhub","2022-07-14T01:45:13Z","2022-07-19T08:54:32Z"
"","28805","Fix typos in reference docs and project documentation","","closed","type: documentation,","marcwrobel","2022-07-12T17:34:24Z","2022-07-13T13:19:19Z"
"","28803","Fix and improve Javadoc in spring-beans and spring-aop","","closed","type: documentation,","marcwrobel","2022-07-12T16:00:29Z","2022-07-14T08:46:46Z"
"","28802","Fix and improve Javadoc in spring-core and spring-context","","closed","type: documentation,","marcwrobel","2022-07-12T15:28:53Z","2022-07-13T13:10:12Z"
"","28800","Fix and improve Javadoc in spring-messaging, spring-jms and spring-expression","","closed","type: documentation,","marcwrobel","2022-07-12T13:58:37Z","2022-07-13T12:14:06Z"
"","28796","Fix and improve Javadoc in spring-r2dbc, spring-oxm, spring-orm and spring-jdbc","","closed","type: documentation,","marcwrobel","2022-07-12T12:27:45Z","2022-07-13T12:14:23Z"
"","28795","Fix and improve Javadoc in spring-test","","closed","type: documentation,","marcwrobel","2022-07-12T10:23:08Z","2022-07-12T12:38:54Z"
"","28794","Fix and improve Javadoc in spring-tx","","closed","type: documentation,","marcwrobel","2022-07-12T09:54:22Z","2022-07-12T13:41:51Z"
"","28792","try","","closed","status: invalid,","abhigar9","2022-07-12T06:30:02Z","2022-07-12T07:02:02Z"
"","28791","Fix and improve Javadoc in spring-web","","closed","in: web,","marcwrobel","2022-07-11T21:31:08Z","2022-07-12T13:41:56Z"
"","28790","Fix and improve Javadoc in spring-webflux","","closed","in: web,","marcwrobel","2022-07-11T21:16:55Z","2022-07-12T10:05:00Z"
"","28789","Fix and improve Javadoc in spring-webmvc","","closed","in: web,","marcwrobel","2022-07-11T20:56:31Z","2022-07-12T09:16:27Z"
"","28788","Fix and improve Javadoc in spring-websocket","","closed","in: web,","marcwrobel","2022-07-11T17:27:55Z","2022-07-12T09:16:56Z"
"","28786","Reject JDK proxy hint registration for sealed interfaces","","closed","type: enhancement,","sbrannen","2022-07-11T15:44:55Z","2022-07-11T15:52:19Z"
"","28784","Upgrade to Kotlin 1.7.10","","closed","in: kotlin,","sdeleuze","2022-07-11T08:07:14Z","2022-07-11T08:14:21Z"
"","28766","Upgrade to Reactor 2022.0.0-M4","","closed","type: dependency-upgrade,","rstoyanchev","2022-07-06T10:30:21Z","2022-07-13T09:58:08Z"
"","28765","Upgrade to Reactor 2020.0.21","","closed","type: dependency-upgrade,","rstoyanchev","2022-07-06T10:25:24Z","2022-07-12T12:32:36Z"
"","28742","Remove code duplication in AopUtils.isAopProxy() to improve readability","","closed","in: core,","waahhh","2022-07-01T18:53:24Z","2022-07-02T17:24:33Z"
"","28733","Only use JPMS exports as we don't need reflection access","","closed","theme: aot,","mhalbritter","2022-06-30T08:23:33Z","2022-06-30T12:54:51Z"
"","28720","注释部分代码","","closed","status: invalid,","boerzi","2022-06-28T13:20:00Z","2022-06-28T13:25:16Z"
"","28694","5.2.x.study","","closed","status: invalid,","zDream","2022-06-24T03:23:09Z","2022-06-24T06:26:27Z"
"","28674","Interested to work on issue #28651","","closed","status: invalid,","VFigliolino","2022-06-22T04:01:29Z","2022-06-22T05:44:11Z"
"","28661","Update Gradle Enterprise plugin","","closed","type: task,","jprinet","2022-06-20T09:27:15Z","2022-06-20T09:50:32Z"
"","28646","Use putAll in WebFlux for possibly better performance","","closed","type: task,","vikeychen","2022-06-17T10:01:11Z","2022-07-01T08:42:35Z"
"","28641","Upgrade Dokka to 1.7","","closed","type: dependency-upgrade,","poutsma","2022-06-16T14:36:30Z","2022-06-24T11:20:29Z"
"","28640","5.3.x","","closed","status: invalid,","JamesLiuft","2022-06-16T12:15:55Z","2022-06-16T12:50:46Z"
"","28635","Add Kotlinx Serialization support to BindingReflectionHintsRegistrar","","closed","in: kotlin,","sdeleuze","2022-06-15T15:43:11Z","2022-06-15T15:55:02Z"
"","28612","Upgrade to Reactor 2020.0.20","","closed","type: dependency-upgrade,","snicoll","2022-06-13T09:14:14Z","2022-06-14T17:30:34Z"
"","28606","Reflection configuration for parameter types with an inner class have wrong name","","closed","theme: aot,","snicoll","2022-06-10T13:15:52Z","2022-06-10T13:33:00Z"
"","28553","Test BackportBot","","closed","in: core,","rwinch","2022-06-01T15:24:08Z","2022-06-01T15:35:20Z"
"","28493","Correctly detect Optional return type for `@HttpExchange` methods","","closed","type: bug,","wonwoo","2022-05-20T04:33:46Z","2022-05-20T09:27:26Z"
"","28445","Refine CachedIntrospectionResults property introspection","","closed","type: enhancement,","jhoeller","2022-05-11T06:25:35Z","2022-05-11T06:57:14Z"
"","28443","Ignore invalid STOMP frame","","closed","type: bug,","rstoyanchev","2022-05-11T06:19:29Z","2022-05-20T06:59:16Z"
"","28440","Polishing regarding JDK baseline upgrade","","closed","status: feedback-provided,","aooohan","2022-05-10T13:33:52Z","2022-05-10T15:03:46Z"
"","28437","Upgrade to Reactor 2020.0.19","","closed","type: dependency-upgrade,","jhoeller","2022-05-10T10:18:03Z","2022-05-10T11:43:27Z"
"","28431","Fix typo in declarative HTTP interfaces docs","","closed","type: task,","maciejwalkowiak","2022-05-09T12:05:21Z","2022-05-09T13:00:31Z"
"","28406","a","","closed","","guyukou","2022-05-02T11:32:24Z","2022-05-02T11:32:38Z"
"","28384","BeanRegistrationContributionProvider should have access to the bean factory","","closed","theme: aot,","snicoll","2022-04-26T11:54:53Z","2022-04-26T13:15:58Z"
"","28372","Fix github issue reference in RequestMappingHandlerMapping","","closed","type: documentation,","zhangmingqi09","2022-04-24T06:06:20Z","2022-04-24T07:57:41Z"
"","28346","sync","","closed","status: invalid,","mostcool","2022-04-15T06:31:26Z","2022-04-15T06:45:11Z"
"","28338","Update Gradle Enterprise plugin to 3.9","","closed","type: task,","jprinet","2022-04-14T07:28:34Z","2022-04-14T09:05:39Z"
"","28333","Improve documentation and matching algorithm in data binders","","closed","in: core,","sbrannen","2022-04-13T14:04:34Z","2022-04-13T14:09:33Z"
"","28332","Use ""instanceof pattern matching"" in sample in reference docs","","closed","type: documentation,","jjank","2022-04-13T07:28:36Z","2022-04-13T11:58:41Z"
"","28329","Upgrade to Reactor 2020.0.18","","closed","type: dependency-upgrade,","snicoll","2022-04-12T13:41:41Z","2022-04-12T14:14:22Z"
"","28311","5.0.x","","closed","","Encyclopedias","2022-04-10T02:14:41Z","2022-04-10T02:15:06Z"
"","28261","Restrict access to property paths on Class references","","closed","in: core,","rstoyanchev","2022-03-31T10:52:19Z","2022-04-04T08:42:34Z"
"","28254","Polish","","closed","","vikeychen","2022-03-30T14:04:52Z","2022-04-04T17:01:59Z"
"","28226","Prevent org.jetbrains.annotations imports","","closed","type: task,","quaff","2022-03-24T01:03:23Z","2022-03-24T14:44:45Z"
"","28188","Apply ""instanceof pattern matching"" in spring-core","","closed","in: core,","diguage","2022-03-16T16:13:58Z","2022-05-31T02:57:25Z"
"","28162","Upgrade to Reactor 2022.0.0-M1","","closed","type: dependency-upgrade,","snicoll","2022-03-11T09:04:21Z","2022-05-09T13:37:53Z"
"","28161","当采用XML配置文件 如果当前只配置一个Bean的情况下 同时实现BeanPostProcessor和BeanFactoryPostProcessor BeanPostProcessor的两个方法不会执行 但是如果再增加一个Service方式就会执行","","closed","for: stackoverflow,","10zh","2022-03-11T08:54:35Z","2022-03-15T07:16:38Z"
"","28143","5.1.x","","closed","status: invalid,","pengbina","2022-03-07T13:23:28Z","2022-03-07T13:26:13Z"
"","28139","1. 添加spring注释。","","closed","status: invalid,","1Tickets","2022-03-05T15:59:13Z","2022-03-05T17:45:21Z"
"","28119","添加测试用例","","closed","status: invalid,","szd1007","2022-03-01T11:56:36Z","2022-03-01T13:52:27Z"
"","28116","Fix debug log for no matching acceptableTypes","","closed","type: enhancement,","GatinMI","2022-02-28T20:31:16Z","2022-04-04T16:38:42Z"
"","28078","5.1.x","","closed","status: invalid,","pengbina","2022-02-19T13:49:03Z","2022-02-19T15:05:54Z"
"","28064","Upgrade to Reactor 2020.0.17","","closed","type: dependency-upgrade,","jhoeller","2022-02-16T18:40:39Z","2022-03-15T15:05:12Z"
"","28060","Upgrade to AspectJ 1.9.8","","closed","type: dependency-upgrade,","snicoll","2022-02-16T08:49:05Z","2022-02-16T14:19:10Z"
"","28039","Upgrade to Reactor 2020.0.16","","closed","type: dependency-upgrade,","snicoll","2022-02-11T14:40:48Z","2022-02-15T12:41:04Z"
"","28014","Use enhanced switch expressions where feasible","","closed","type: task,","AbstractCoderX","2022-02-07T17:53:19Z","2022-02-19T13:51:42Z"
"","28011","Apply ""instanceof pattern matching"" in AbstractRoutingDataSource","","closed","type: task,","diguage","2022-02-05T12:51:54Z","2022-02-06T02:59:07Z"
"","27990","Update to OkHttp 4.9.3","","closed","status: declined,","larsgrefer","2022-01-30T22:13:05Z","2022-02-01T13:19:51Z"
"","27985","Upgrade to Groovy 4.0","","closed","type: dependency-upgrade,","jhoeller","2022-01-28T17:22:01Z","2022-02-04T20:13:51Z"
"","27961","Can I use a SpEL expression to call a local Java method?","","closed","for: stackoverflow,","daidai21","2022-01-20T09:34:03Z","2022-01-20T13:30:28Z"
"","27942","Upgrade to Gradle Enterprise 3.8.1","","closed","type: task,","jprinet","2022-01-17T14:19:21Z","2022-01-17T17:06:43Z"
"","27918","Typos in STOMP documentation","","closed","","iotdeveloper-iotservice","2022-01-11T11:25:22Z","2022-01-11T11:25:43Z"
"","27912","Update README.md","","closed","status: invalid,","binababar","2022-01-10T16:51:33Z","2022-01-10T16:58:25Z"
"","27907","Fix syntax in WebFlux Validation example","","closed","type: documentation,","waahhh","2022-01-09T10:11:11Z","2022-01-09T18:23:19Z"
"","27897","Upgrade to Reactor 2020.0.15","","closed","type: dependency-upgrade,","snicoll","2022-01-06T15:39:43Z","2022-01-12T08:40:27Z"